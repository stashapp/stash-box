// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/gofrs/uuid"
)

type DraftData interface {
	IsDraftData()
}

type EditDetails interface {
	IsEditDetails()
}

type EditTarget interface {
	IsEditTarget()
}

type SceneDraftPerformer interface {
	IsSceneDraftPerformer()
}

type SceneDraftStudio interface {
	IsSceneDraftStudio()
}

type SceneDraftTag interface {
	IsSceneDraftTag()
}

type ActivateNewUserInput struct {
	Name          string `json:"name"`
	Email         string `json:"email"`
	ActivationKey string `json:"activation_key"`
	Password      string `json:"password"`
}

type ApplyEditInput struct {
	ID uuid.UUID `json:"id"`
}

type BodyModificationCriterionInput struct {
	Location    *string           `json:"location"`
	Description *string           `json:"description"`
	Modifier    CriterionModifier `json:"modifier"`
}

type BreastTypeCriterionInput struct {
	Value    *BreastTypeEnum   `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type CancelEditInput struct {
	ID uuid.UUID `json:"id"`
}

type DateCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type DraftEntityInput struct {
	Name string     `json:"name"`
	ID   *uuid.UUID `json:"id"`
}

type DraftFingerprint struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type DraftSubmissionStatus struct {
	ID *uuid.UUID `json:"id"`
}

type EditCommentInput struct {
	ID      uuid.UUID `json:"id"`
	Comment string    `json:"comment"`
}

type EditInput struct {
	// Not required for create type
	ID        *uuid.UUID    `json:"id"`
	Operation OperationEnum `json:"operation"`
	// Only required for merge type
	MergeSourceIds []uuid.UUID `json:"merge_source_ids"`
	Comment        *string     `json:"comment"`
	// Edit submitted by an automated script. Requires bot permission
	Bot *bool `json:"bot"`
}

type EditQueryInput struct {
	// Filter by user id
	UserID *uuid.UUID `json:"user_id"`
	// Filter by status
	Status *VoteStatusEnum `json:"status"`
	// Filter by operation
	Operation *OperationEnum `json:"operation"`
	// Filter by vote count
	VoteCount *IntCriterionInput `json:"vote_count"`
	// Filter by applied status
	Applied *bool `json:"applied"`
	// Filter by target type
	TargetType *TargetTypeEnum `json:"target_type"`
	// Filter by target id
	TargetID *uuid.UUID `json:"target_id"`
	// Filter by favorite status
	IsFavorite *bool `json:"is_favorite"`
	// Filter by user voted status
	Voted *UserVotedFilterEnum `json:"voted"`
	// Filter to bot edits only
	IsBot     *bool             `json:"is_bot"`
	Page      int               `json:"page"`
	PerPage   int               `json:"per_page"`
	Direction SortDirectionEnum `json:"direction"`
	Sort      EditSortEnum      `json:"sort"`
}

type EditVoteInput struct {
	ID   uuid.UUID    `json:"id"`
	Vote VoteTypeEnum `json:"vote"`
}

type EyeColorCriterionInput struct {
	Value    *EyeColorEnum     `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Fingerprint struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
	// number of times this fingerprint has been submitted (excluding reports)
	Submissions int `json:"submissions"`
	// number of times this fingerprint has been reported
	Reports       int       `json:"reports"`
	Created       time.Time `json:"created"`
	Updated       time.Time `json:"updated"`
	UserSubmitted bool      `json:"user_submitted"`
}

type FingerprintEditInput struct {
	UserIds     []uuid.UUID          `json:"user_ids"`
	Hash        string               `json:"hash"`
	Algorithm   FingerprintAlgorithm `json:"algorithm"`
	Duration    int                  `json:"duration"`
	Created     time.Time            `json:"created"`
	Submissions *int                 `json:"submissions"`
	Updated     *time.Time           `json:"updated"`
}

type FingerprintInput struct {
	// assumes current user if omitted. Ignored for non-modify Users
	UserIds   []uuid.UUID          `json:"user_ids"`
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type FingerprintQueryInput struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
}

type FingerprintSubmission struct {
	SceneID     uuid.UUID         `json:"scene_id"`
	Fingerprint *FingerprintInput `json:"fingerprint"`
	Unmatch     *bool             `json:"unmatch"`
	// positive for default behaviour, negative to report as invalid, zero to remove vote
	Vote *int `json:"vote"`
}

type FuzzyDate struct {
	Date     string           `json:"date"`
	Accuracy DateAccuracyEnum `json:"accuracy"`
}

type GrantInviteInput struct {
	UserID uuid.UUID `json:"user_id"`
	Amount int       `json:"amount"`
}

type HairColorCriterionInput struct {
	Value    *HairColorEnum    `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type IDCriterionInput struct {
	Value    []uuid.UUID       `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type ImageCreateInput struct {
	URL  *string         `json:"url"`
	File *graphql.Upload `json:"file"`
}

type ImageDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type ImageUpdateInput struct {
	ID  uuid.UUID `json:"id"`
	URL *string   `json:"url"`
}

type IntCriterionInput struct {
	Value    int               `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Measurements struct {
	CupSize  *string `json:"cup_size"`
	BandSize *int    `json:"band_size"`
	Waist    *int    `json:"waist"`
	Hip      *int    `json:"hip"`
}

type MultiIDCriterionInput struct {
	Value    []uuid.UUID       `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type MultiStringCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type NewUserInput struct {
	Email     string  `json:"email"`
	InviteKey *string `json:"invite_key"`
}

type PerformerAppearance struct {
	Performer *Performer `json:"performer"`
	// Performing as alias
	As *string `json:"as"`
}

type PerformerAppearanceInput struct {
	PerformerID uuid.UUID `json:"performer_id"`
	// Performing as alias
	As *string `json:"as"`
}

type PerformerCreateInput struct {
	Name            string              `json:"name"`
	Disambiguation  *string             `json:"disambiguation"`
	Aliases         []string            `json:"aliases"`
	Gender          *GenderEnum         `json:"gender"`
	Urls            []*URLInput         `json:"urls"`
	Birthdate       *string             `json:"birthdate"`
	Ethnicity       *EthnicityEnum      `json:"ethnicity"`
	Country         *string             `json:"country"`
	EyeColor        *EyeColorEnum       `json:"eye_color"`
	HairColor       *HairColorEnum      `json:"hair_color"`
	Height          *int                `json:"height"`
	CupSize         *string             `json:"cup_size"`
	BandSize        *int                `json:"band_size"`
	WaistSize       *int                `json:"waist_size"`
	HipSize         *int                `json:"hip_size"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	ImageIds        []uuid.UUID         `json:"image_ids"`
	DraftID         *uuid.UUID          `json:"draft_id"`
}

type PerformerDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type PerformerDraftInput struct {
	ID              *uuid.UUID      `json:"id"`
	Name            string          `json:"name"`
	Aliases         *string         `json:"aliases"`
	Gender          *string         `json:"gender"`
	Birthdate       *string         `json:"birthdate"`
	Urls            []string        `json:"urls"`
	Ethnicity       *string         `json:"ethnicity"`
	Country         *string         `json:"country"`
	EyeColor        *string         `json:"eye_color"`
	HairColor       *string         `json:"hair_color"`
	Height          *string         `json:"height"`
	Measurements    *string         `json:"measurements"`
	BreastType      *string         `json:"breast_type"`
	Tattoos         *string         `json:"tattoos"`
	Piercings       *string         `json:"piercings"`
	CareerStartYear *int            `json:"career_start_year"`
	CareerEndYear   *int            `json:"career_end_year"`
	Image           *graphql.Upload `json:"image"`
}

type PerformerEditDetailsInput struct {
	Name            *string             `json:"name"`
	Disambiguation  *string             `json:"disambiguation"`
	Aliases         []string            `json:"aliases"`
	Gender          *GenderEnum         `json:"gender"`
	Urls            []*URLInput         `json:"urls"`
	Birthdate       *string             `json:"birthdate"`
	Ethnicity       *EthnicityEnum      `json:"ethnicity"`
	Country         *string             `json:"country"`
	EyeColor        *EyeColorEnum       `json:"eye_color"`
	HairColor       *HairColorEnum      `json:"hair_color"`
	Height          *int                `json:"height"`
	CupSize         *string             `json:"cup_size"`
	BandSize        *int                `json:"band_size"`
	WaistSize       *int                `json:"waist_size"`
	HipSize         *int                `json:"hip_size"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	ImageIds        []uuid.UUID         `json:"image_ids"`
	DraftID         *uuid.UUID          `json:"draft_id"`
}

type PerformerEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *PerformerEditDetailsInput `json:"details"`
	// Controls aliases modification for merges and name modifications
	Options *PerformerEditOptionsInput `json:"options"`
}

type PerformerEditOptions struct {
	// Set performer alias on scenes without alias to old name if name is changed
	SetModifyAliases bool `json:"set_modify_aliases"`
	// Set performer alias on scenes attached to merge sources to old name
	SetMergeAliases bool `json:"set_merge_aliases"`
}

type PerformerEditOptionsInput struct {
	// Set performer alias on scenes without alias to old name if name is changed
	SetModifyAliases *bool `json:"set_modify_aliases"`
	// Set performer alias on scenes attached to merge sources to old name
	SetMergeAliases *bool `json:"set_merge_aliases"`
}

type PerformerQueryInput struct {
	// Searches name and disambiguation - assumes like query unless quoted
	Names *string `json:"names"`
	// Searches name only - assumes like query unless quoted
	Name *string `json:"name"`
	// Search aliases only - assumes like query unless quoted
	Alias          *string               `json:"alias"`
	Disambiguation *StringCriterionInput `json:"disambiguation"`
	Gender         *GenderFilterEnum     `json:"gender"`
	// Filter to search urls - assumes like query unless quoted
	URL             *string                         `json:"url"`
	Birthdate       *DateCriterionInput             `json:"birthdate"`
	BirthYear       *IntCriterionInput              `json:"birth_year"`
	Age             *IntCriterionInput              `json:"age"`
	Ethnicity       *EthnicityFilterEnum            `json:"ethnicity"`
	Country         *StringCriterionInput           `json:"country"`
	EyeColor        *EyeColorCriterionInput         `json:"eye_color"`
	HairColor       *HairColorCriterionInput        `json:"hair_color"`
	Height          *IntCriterionInput              `json:"height"`
	CupSize         *StringCriterionInput           `json:"cup_size"`
	BandSize        *IntCriterionInput              `json:"band_size"`
	WaistSize       *IntCriterionInput              `json:"waist_size"`
	HipSize         *IntCriterionInput              `json:"hip_size"`
	BreastType      *BreastTypeCriterionInput       `json:"breast_type"`
	CareerStartYear *IntCriterionInput              `json:"career_start_year"`
	CareerEndYear   *IntCriterionInput              `json:"career_end_year"`
	Tattoos         *BodyModificationCriterionInput `json:"tattoos"`
	Piercings       *BodyModificationCriterionInput `json:"piercings"`
	// Filter by performerfavorite status for the current user
	IsFavorite *bool `json:"is_favorite"`
	// Filter by a performer they have performed in scenes with
	PerformedWith *uuid.UUID `json:"performed_with"`
	// Filter by a studio
	StudioID  *uuid.UUID        `json:"studio_id"`
	Page      int               `json:"page"`
	PerPage   int               `json:"per_page"`
	Direction SortDirectionEnum `json:"direction"`
	Sort      PerformerSortEnum `json:"sort"`
}

type PerformerScenesInput struct {
	// Filter by another performer that also performs in the scenes
	PerformedWith *uuid.UUID `json:"performed_with"`
	// Filter by a studio
	StudioID *uuid.UUID `json:"studio_id"`
	// Filter by tags
	Tags *MultiIDCriterionInput `json:"tags"`
}

type PerformerUpdateInput struct {
	ID              uuid.UUID           `json:"id"`
	Name            *string             `json:"name"`
	Disambiguation  *string             `json:"disambiguation"`
	Aliases         []string            `json:"aliases"`
	Gender          *GenderEnum         `json:"gender"`
	Urls            []*URLInput         `json:"urls"`
	Birthdate       *string             `json:"birthdate"`
	Ethnicity       *EthnicityEnum      `json:"ethnicity"`
	Country         *string             `json:"country"`
	EyeColor        *EyeColorEnum       `json:"eye_color"`
	HairColor       *HairColorEnum      `json:"hair_color"`
	Height          *int                `json:"height"`
	CupSize         *string             `json:"cup_size"`
	BandSize        *int                `json:"band_size"`
	WaistSize       *int                `json:"waist_size"`
	HipSize         *int                `json:"hip_size"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	ImageIds        []uuid.UUID         `json:"image_ids"`
}

type QueryExistingSceneInput struct {
	Title        *string             `json:"title"`
	StudioID     *uuid.UUID          `json:"studio_id"`
	Fingerprints []*FingerprintInput `json:"fingerprints"`
}

type QuerySitesResultType struct {
	Count int     `json:"count"`
	Sites []*Site `json:"sites"`
}

type QueryStudiosResultType struct {
	Count   int       `json:"count"`
	Studios []*Studio `json:"studios"`
}

type QueryTagCategoriesResultType struct {
	Count         int            `json:"count"`
	TagCategories []*TagCategory `json:"tag_categories"`
}

type QueryTagsResultType struct {
	Count int    `json:"count"`
	Tags  []*Tag `json:"tags"`
}

type QueryUsersResultType struct {
	Count int     `json:"count"`
	Users []*User `json:"users"`
}

type ResetPasswordInput struct {
	Email string `json:"email"`
}

type RevokeInviteInput struct {
	UserID uuid.UUID `json:"user_id"`
	Amount int       `json:"amount"`
}

type RoleCriterionInput struct {
	Value    []RoleEnum        `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type SceneCreateInput struct {
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URLInput                 `json:"urls"`
	Date         string                      `json:"date"`
	StudioID     *uuid.UUID                  `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []uuid.UUID                 `json:"tag_ids"`
	ImageIds     []uuid.UUID                 `json:"image_ids"`
	Fingerprints []*FingerprintEditInput     `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
	Code         *string                     `json:"code"`
}

type SceneDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type SceneDraftInput struct {
	ID           *uuid.UUID          `json:"id"`
	Title        *string             `json:"title"`
	Code         *string             `json:"code"`
	Details      *string             `json:"details"`
	Director     *string             `json:"director"`
	URL          *string             `json:"url"`
	Date         *string             `json:"date"`
	Studio       *DraftEntityInput   `json:"studio"`
	Performers   []*DraftEntityInput `json:"performers"`
	Tags         []*DraftEntityInput `json:"tags"`
	Image        *graphql.Upload     `json:"image"`
	Fingerprints []*FingerprintInput `json:"fingerprints"`
}

type SceneEditDetailsInput struct {
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URLInput                 `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *uuid.UUID                  `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []uuid.UUID                 `json:"tag_ids"`
	ImageIds     []uuid.UUID                 `json:"image_ids"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
	Code         *string                     `json:"code"`
	Fingerprints []*FingerprintInput         `json:"fingerprints"`
	DraftID      *uuid.UUID                  `json:"draft_id"`
}

type SceneEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *SceneEditDetailsInput `json:"details"`
}

type SceneQueryInput struct {
	// Filter to search title and details - assumes like query unless quoted
	Text *string `json:"text"`
	// Filter to search title - assumes like query unless quoted
	Title *string `json:"title"`
	// Filter to search urls - assumes like query unless quoted
	URL *string `json:"url"`
	// Filter by date
	Date *DateCriterionInput `json:"date"`
	// Filter to only include scenes with this studio
	Studios *MultiIDCriterionInput `json:"studios"`
	// Filter to only include scenes with this studio as primary or parent
	ParentStudio *string `json:"parentStudio"`
	// Filter to only include scenes with these tags
	Tags *MultiIDCriterionInput `json:"tags"`
	// Filter to only include scenes with these performers
	Performers *MultiIDCriterionInput `json:"performers"`
	// Filter to include scenes with performer appearing as alias
	Alias *StringCriterionInput `json:"alias"`
	// Filter to only include scenes with these fingerprints
	Fingerprints *MultiStringCriterionInput `json:"fingerprints"`
	// Filter by favorited entity
	Favorites *FavoriteFilter `json:"favorites"`
	// Filter to scenes with fingerprints submitted by the user
	HasFingerprintSubmissions *bool             `json:"has_fingerprint_submissions"`
	Page                      int               `json:"page"`
	PerPage                   int               `json:"per_page"`
	Direction                 SortDirectionEnum `json:"direction"`
	Sort                      SceneSortEnum     `json:"sort"`
}

type SceneUpdateInput struct {
	ID           uuid.UUID                   `json:"id"`
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URLInput                 `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *uuid.UUID                  `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []uuid.UUID                 `json:"tag_ids"`
	ImageIds     []uuid.UUID                 `json:"image_ids"`
	Fingerprints []*FingerprintEditInput     `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
	Code         *string                     `json:"code"`
}

type SiteCreateInput struct {
	Name        string              `json:"name"`
	Description *string             `json:"description"`
	URL         *string             `json:"url"`
	Regex       *string             `json:"regex"`
	ValidTypes  []ValidSiteTypeEnum `json:"valid_types"`
}

type SiteDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type SiteUpdateInput struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	Description *string             `json:"description"`
	URL         *string             `json:"url"`
	Regex       *string             `json:"regex"`
	ValidTypes  []ValidSiteTypeEnum `json:"valid_types"`
}

type StashBoxConfig struct {
	HostURL                    string `json:"host_url"`
	RequireInvite              bool   `json:"require_invite"`
	RequireActivation          bool   `json:"require_activation"`
	VotePromotionThreshold     *int   `json:"vote_promotion_threshold"`
	VoteApplicationThreshold   int    `json:"vote_application_threshold"`
	VotingPeriod               int    `json:"voting_period"`
	MinDestructiveVotingPeriod int    `json:"min_destructive_voting_period"`
	VoteCronInterval           string `json:"vote_cron_interval"`
}

type StringCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type StudioCreateInput struct {
	Name     string      `json:"name"`
	Urls     []*URLInput `json:"urls"`
	ParentID *uuid.UUID  `json:"parent_id"`
	ImageIds []uuid.UUID `json:"image_ids"`
}

type StudioDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type StudioEditDetailsInput struct {
	Name     *string     `json:"name"`
	Urls     []*URLInput `json:"urls"`
	ParentID *uuid.UUID  `json:"parent_id"`
	ImageIds []uuid.UUID `json:"image_ids"`
}

type StudioEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *StudioEditDetailsInput `json:"details"`
}

type StudioQueryInput struct {
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to search studio and parent studio name - assumes like query unless quoted
	Names *string `json:"names"`
	// Filter to search url - assumes like query unless quoted
	URL       *string           `json:"url"`
	Parent    *IDCriterionInput `json:"parent"`
	HasParent *bool             `json:"has_parent"`
	// Filter by studio favorite status for the current user
	IsFavorite *bool             `json:"is_favorite"`
	Page       int               `json:"page"`
	PerPage    int               `json:"per_page"`
	Direction  SortDirectionEnum `json:"direction"`
	Sort       StudioSortEnum    `json:"sort"`
}

type StudioUpdateInput struct {
	ID       uuid.UUID   `json:"id"`
	Name     *string     `json:"name"`
	Urls     []*URLInput `json:"urls"`
	ParentID *uuid.UUID  `json:"parent_id"`
	ImageIds []uuid.UUID `json:"image_ids"`
}

type TagCategoryCreateInput struct {
	Name        string       `json:"name"`
	Group       TagGroupEnum `json:"group"`
	Description *string      `json:"description"`
}

type TagCategoryDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type TagCategoryUpdateInput struct {
	ID          uuid.UUID     `json:"id"`
	Name        *string       `json:"name"`
	Group       *TagGroupEnum `json:"group"`
	Description *string       `json:"description"`
}

type TagCreateInput struct {
	Name        string     `json:"name"`
	Description *string    `json:"description"`
	Aliases     []string   `json:"aliases"`
	CategoryID  *uuid.UUID `json:"category_id"`
}

type TagDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type TagEditDetailsInput struct {
	Name        *string    `json:"name"`
	Description *string    `json:"description"`
	Aliases     []string   `json:"aliases"`
	CategoryID  *uuid.UUID `json:"category_id"`
}

type TagEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *TagEditDetailsInput `json:"details"`
}

type TagQueryInput struct {
	// Filter to search name, aliases and description - assumes like query unless quoted
	Text *string `json:"text"`
	// Searches name and aliases - assumes like query unless quoted
	Names *string `json:"names"`
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to category ID
	CategoryID *uuid.UUID        `json:"category_id"`
	Page       int               `json:"page"`
	PerPage    int               `json:"per_page"`
	Direction  SortDirectionEnum `json:"direction"`
	Sort       TagSortEnum       `json:"sort"`
}

type TagUpdateInput struct {
	ID          uuid.UUID  `json:"id"`
	Name        *string    `json:"name"`
	Description *string    `json:"description"`
	Aliases     []string   `json:"aliases"`
	CategoryID  *uuid.UUID `json:"category_id"`
}

type UserChangePasswordInput struct {
	// Password in plain text
	ExistingPassword *string `json:"existing_password"`
	NewPassword      string  `json:"new_password"`
	ResetKey         *string `json:"reset_key"`
}

type UserCreateInput struct {
	Name string `json:"name"`
	// Password in plain text
	Password    string     `json:"password"`
	Roles       []RoleEnum `json:"roles"`
	Email       string     `json:"email"`
	InvitedByID *uuid.UUID `json:"invited_by_id"`
}

type UserDestroyInput struct {
	ID uuid.UUID `json:"id"`
}

type UserEditCount struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	Pending           int `json:"pending"`
	ImmediateAccepted int `json:"immediate_accepted"`
	ImmediateRejected int `json:"immediate_rejected"`
	Failed            int `json:"failed"`
	Canceled          int `json:"canceled"`
}

type UserQueryInput struct {
	// Filter to search user name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to search email - assumes like query unless quoted
	Email *string `json:"email"`
	// Filter by roles
	Roles *RoleCriterionInput `json:"roles"`
	// Filter by api key
	APIKey *string `json:"apiKey"`
	// Filter by successful edits
	SuccessfulEdits *IntCriterionInput `json:"successful_edits"`
	// Filter by unsuccessful edits
	UnsuccessfulEdits *IntCriterionInput `json:"unsuccessful_edits"`
	// Filter by votes on successful edits
	SuccessfulVotes *IntCriterionInput `json:"successful_votes"`
	// Filter by votes on unsuccessful edits
	UnsuccessfulVotes *IntCriterionInput `json:"unsuccessful_votes"`
	// Filter by number of API calls
	APICalls *IntCriterionInput `json:"api_calls"`
	// Filter by user that invited
	InvitedBy *uuid.UUID `json:"invited_by"`
	Page      int        `json:"page"`
	PerPage   int        `json:"per_page"`
}

type UserUpdateInput struct {
	ID   uuid.UUID `json:"id"`
	Name *string   `json:"name"`
	// Password in plain text
	Password *string    `json:"password"`
	Roles    []RoleEnum `json:"roles"`
	Email    *string    `json:"email"`
}

type UserVoteCount struct {
	Abstain         int `json:"abstain"`
	Accept          int `json:"accept"`
	Reject          int `json:"reject"`
	ImmediateAccept int `json:"immediate_accept"`
	ImmediateReject int `json:"immediate_reject"`
}

type Version struct {
	Hash      string `json:"hash"`
	BuildTime string `json:"build_time"`
	BuildType string `json:"build_type"`
	Version   string `json:"version"`
}

type BreastTypeEnum string

const (
	BreastTypeEnumNatural BreastTypeEnum = "NATURAL"
	BreastTypeEnumFake    BreastTypeEnum = "FAKE"
	BreastTypeEnumNa      BreastTypeEnum = "NA"
)

var AllBreastTypeEnum = []BreastTypeEnum{
	BreastTypeEnumNatural,
	BreastTypeEnumFake,
	BreastTypeEnumNa,
}

func (e BreastTypeEnum) IsValid() bool {
	switch e {
	case BreastTypeEnumNatural, BreastTypeEnumFake, BreastTypeEnumNa:
		return true
	}
	return false
}

func (e BreastTypeEnum) String() string {
	return string(e)
}

func (e *BreastTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BreastTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BreastTypeEnum", str)
	}
	return nil
}

func (e BreastTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CriterionModifier string

const (
	// =
	CriterionModifierEquals CriterionModifier = "EQUALS"
	// !=
	CriterionModifierNotEquals CriterionModifier = "NOT_EQUALS"
	// >
	CriterionModifierGreaterThan CriterionModifier = "GREATER_THAN"
	// <
	CriterionModifierLessThan CriterionModifier = "LESS_THAN"
	// IS NULL
	CriterionModifierIsNull CriterionModifier = "IS_NULL"
	// IS NOT NULL
	CriterionModifierNotNull CriterionModifier = "NOT_NULL"
	// INCLUDES ALL
	CriterionModifierIncludesAll CriterionModifier = "INCLUDES_ALL"
	CriterionModifierIncludes    CriterionModifier = "INCLUDES"
	CriterionModifierExcludes    CriterionModifier = "EXCLUDES"
)

var AllCriterionModifier = []CriterionModifier{
	CriterionModifierEquals,
	CriterionModifierNotEquals,
	CriterionModifierGreaterThan,
	CriterionModifierLessThan,
	CriterionModifierIsNull,
	CriterionModifierNotNull,
	CriterionModifierIncludesAll,
	CriterionModifierIncludes,
	CriterionModifierExcludes,
}

func (e CriterionModifier) IsValid() bool {
	switch e {
	case CriterionModifierEquals, CriterionModifierNotEquals, CriterionModifierGreaterThan, CriterionModifierLessThan, CriterionModifierIsNull, CriterionModifierNotNull, CriterionModifierIncludesAll, CriterionModifierIncludes, CriterionModifierExcludes:
		return true
	}
	return false
}

func (e CriterionModifier) String() string {
	return string(e)
}

func (e *CriterionModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CriterionModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CriterionModifier", str)
	}
	return nil
}

func (e CriterionModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DateAccuracyEnum string

const (
	DateAccuracyEnumYear  DateAccuracyEnum = "YEAR"
	DateAccuracyEnumMonth DateAccuracyEnum = "MONTH"
	DateAccuracyEnumDay   DateAccuracyEnum = "DAY"
)

var AllDateAccuracyEnum = []DateAccuracyEnum{
	DateAccuracyEnumYear,
	DateAccuracyEnumMonth,
	DateAccuracyEnumDay,
}

func (e DateAccuracyEnum) IsValid() bool {
	switch e {
	case DateAccuracyEnumYear, DateAccuracyEnumMonth, DateAccuracyEnumDay:
		return true
	}
	return false
}

func (e DateAccuracyEnum) String() string {
	return string(e)
}

func (e *DateAccuracyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DateAccuracyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DateAccuracyEnum", str)
	}
	return nil
}

func (e DateAccuracyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EditSortEnum string

const (
	EditSortEnumCreatedAt EditSortEnum = "CREATED_AT"
	EditSortEnumUpdatedAt EditSortEnum = "UPDATED_AT"
	EditSortEnumClosedAt  EditSortEnum = "CLOSED_AT"
)

var AllEditSortEnum = []EditSortEnum{
	EditSortEnumCreatedAt,
	EditSortEnumUpdatedAt,
	EditSortEnumClosedAt,
}

func (e EditSortEnum) IsValid() bool {
	switch e {
	case EditSortEnumCreatedAt, EditSortEnumUpdatedAt, EditSortEnumClosedAt:
		return true
	}
	return false
}

func (e EditSortEnum) String() string {
	return string(e)
}

func (e *EditSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EditSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EditSortEnum", str)
	}
	return nil
}

func (e EditSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityEnum string

const (
	EthnicityEnumCaucasian     EthnicityEnum = "CAUCASIAN"
	EthnicityEnumBlack         EthnicityEnum = "BLACK"
	EthnicityEnumAsian         EthnicityEnum = "ASIAN"
	EthnicityEnumIndian        EthnicityEnum = "INDIAN"
	EthnicityEnumLatin         EthnicityEnum = "LATIN"
	EthnicityEnumMiddleEastern EthnicityEnum = "MIDDLE_EASTERN"
	EthnicityEnumMixed         EthnicityEnum = "MIXED"
	EthnicityEnumOther         EthnicityEnum = "OTHER"
)

var AllEthnicityEnum = []EthnicityEnum{
	EthnicityEnumCaucasian,
	EthnicityEnumBlack,
	EthnicityEnumAsian,
	EthnicityEnumIndian,
	EthnicityEnumLatin,
	EthnicityEnumMiddleEastern,
	EthnicityEnumMixed,
	EthnicityEnumOther,
}

func (e EthnicityEnum) IsValid() bool {
	switch e {
	case EthnicityEnumCaucasian, EthnicityEnumBlack, EthnicityEnumAsian, EthnicityEnumIndian, EthnicityEnumLatin, EthnicityEnumMiddleEastern, EthnicityEnumMixed, EthnicityEnumOther:
		return true
	}
	return false
}

func (e EthnicityEnum) String() string {
	return string(e)
}

func (e *EthnicityEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityEnum", str)
	}
	return nil
}

func (e EthnicityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityFilterEnum string

const (
	EthnicityFilterEnumUnknown       EthnicityFilterEnum = "UNKNOWN"
	EthnicityFilterEnumCaucasian     EthnicityFilterEnum = "CAUCASIAN"
	EthnicityFilterEnumBlack         EthnicityFilterEnum = "BLACK"
	EthnicityFilterEnumAsian         EthnicityFilterEnum = "ASIAN"
	EthnicityFilterEnumIndian        EthnicityFilterEnum = "INDIAN"
	EthnicityFilterEnumLatin         EthnicityFilterEnum = "LATIN"
	EthnicityFilterEnumMiddleEastern EthnicityFilterEnum = "MIDDLE_EASTERN"
	EthnicityFilterEnumMixed         EthnicityFilterEnum = "MIXED"
	EthnicityFilterEnumOther         EthnicityFilterEnum = "OTHER"
)

var AllEthnicityFilterEnum = []EthnicityFilterEnum{
	EthnicityFilterEnumUnknown,
	EthnicityFilterEnumCaucasian,
	EthnicityFilterEnumBlack,
	EthnicityFilterEnumAsian,
	EthnicityFilterEnumIndian,
	EthnicityFilterEnumLatin,
	EthnicityFilterEnumMiddleEastern,
	EthnicityFilterEnumMixed,
	EthnicityFilterEnumOther,
}

func (e EthnicityFilterEnum) IsValid() bool {
	switch e {
	case EthnicityFilterEnumUnknown, EthnicityFilterEnumCaucasian, EthnicityFilterEnumBlack, EthnicityFilterEnumAsian, EthnicityFilterEnumIndian, EthnicityFilterEnumLatin, EthnicityFilterEnumMiddleEastern, EthnicityFilterEnumMixed, EthnicityFilterEnumOther:
		return true
	}
	return false
}

func (e EthnicityFilterEnum) String() string {
	return string(e)
}

func (e *EthnicityFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityFilterEnum", str)
	}
	return nil
}

func (e EthnicityFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EyeColorEnum string

const (
	EyeColorEnumBlue  EyeColorEnum = "BLUE"
	EyeColorEnumBrown EyeColorEnum = "BROWN"
	EyeColorEnumGrey  EyeColorEnum = "GREY"
	EyeColorEnumGreen EyeColorEnum = "GREEN"
	EyeColorEnumHazel EyeColorEnum = "HAZEL"
	EyeColorEnumRed   EyeColorEnum = "RED"
)

var AllEyeColorEnum = []EyeColorEnum{
	EyeColorEnumBlue,
	EyeColorEnumBrown,
	EyeColorEnumGrey,
	EyeColorEnumGreen,
	EyeColorEnumHazel,
	EyeColorEnumRed,
}

func (e EyeColorEnum) IsValid() bool {
	switch e {
	case EyeColorEnumBlue, EyeColorEnumBrown, EyeColorEnumGrey, EyeColorEnumGreen, EyeColorEnumHazel, EyeColorEnumRed:
		return true
	}
	return false
}

func (e EyeColorEnum) String() string {
	return string(e)
}

func (e *EyeColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EyeColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EyeColorEnum", str)
	}
	return nil
}

func (e EyeColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FavoriteFilter string

const (
	FavoriteFilterPerformer FavoriteFilter = "PERFORMER"
	FavoriteFilterStudio    FavoriteFilter = "STUDIO"
	FavoriteFilterAll       FavoriteFilter = "ALL"
)

var AllFavoriteFilter = []FavoriteFilter{
	FavoriteFilterPerformer,
	FavoriteFilterStudio,
	FavoriteFilterAll,
}

func (e FavoriteFilter) IsValid() bool {
	switch e {
	case FavoriteFilterPerformer, FavoriteFilterStudio, FavoriteFilterAll:
		return true
	}
	return false
}

func (e FavoriteFilter) String() string {
	return string(e)
}

func (e *FavoriteFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FavoriteFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FavoriteFilter", str)
	}
	return nil
}

func (e FavoriteFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FingerprintAlgorithm string

const (
	FingerprintAlgorithmMd5    FingerprintAlgorithm = "MD5"
	FingerprintAlgorithmOshash FingerprintAlgorithm = "OSHASH"
	FingerprintAlgorithmPhash  FingerprintAlgorithm = "PHASH"
)

var AllFingerprintAlgorithm = []FingerprintAlgorithm{
	FingerprintAlgorithmMd5,
	FingerprintAlgorithmOshash,
	FingerprintAlgorithmPhash,
}

func (e FingerprintAlgorithm) IsValid() bool {
	switch e {
	case FingerprintAlgorithmMd5, FingerprintAlgorithmOshash, FingerprintAlgorithmPhash:
		return true
	}
	return false
}

func (e FingerprintAlgorithm) String() string {
	return string(e)
}

func (e *FingerprintAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FingerprintAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FingerprintAlgorithm", str)
	}
	return nil
}

func (e FingerprintAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderEnum string

const (
	GenderEnumMale              GenderEnum = "MALE"
	GenderEnumFemale            GenderEnum = "FEMALE"
	GenderEnumTransgenderMale   GenderEnum = "TRANSGENDER_MALE"
	GenderEnumTransgenderFemale GenderEnum = "TRANSGENDER_FEMALE"
	GenderEnumIntersex          GenderEnum = "INTERSEX"
	GenderEnumNonBinary         GenderEnum = "NON_BINARY"
)

var AllGenderEnum = []GenderEnum{
	GenderEnumMale,
	GenderEnumFemale,
	GenderEnumTransgenderMale,
	GenderEnumTransgenderFemale,
	GenderEnumIntersex,
	GenderEnumNonBinary,
}

func (e GenderEnum) IsValid() bool {
	switch e {
	case GenderEnumMale, GenderEnumFemale, GenderEnumTransgenderMale, GenderEnumTransgenderFemale, GenderEnumIntersex, GenderEnumNonBinary:
		return true
	}
	return false
}

func (e GenderEnum) String() string {
	return string(e)
}

func (e *GenderEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderEnum", str)
	}
	return nil
}

func (e GenderEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderFilterEnum string

const (
	GenderFilterEnumUnknown           GenderFilterEnum = "UNKNOWN"
	GenderFilterEnumMale              GenderFilterEnum = "MALE"
	GenderFilterEnumFemale            GenderFilterEnum = "FEMALE"
	GenderFilterEnumTransgenderMale   GenderFilterEnum = "TRANSGENDER_MALE"
	GenderFilterEnumTransgenderFemale GenderFilterEnum = "TRANSGENDER_FEMALE"
	GenderFilterEnumIntersex          GenderFilterEnum = "INTERSEX"
	GenderFilterEnumNonBinary         GenderFilterEnum = "NON_BINARY"
)

var AllGenderFilterEnum = []GenderFilterEnum{
	GenderFilterEnumUnknown,
	GenderFilterEnumMale,
	GenderFilterEnumFemale,
	GenderFilterEnumTransgenderMale,
	GenderFilterEnumTransgenderFemale,
	GenderFilterEnumIntersex,
	GenderFilterEnumNonBinary,
}

func (e GenderFilterEnum) IsValid() bool {
	switch e {
	case GenderFilterEnumUnknown, GenderFilterEnumMale, GenderFilterEnumFemale, GenderFilterEnumTransgenderMale, GenderFilterEnumTransgenderFemale, GenderFilterEnumIntersex, GenderFilterEnumNonBinary:
		return true
	}
	return false
}

func (e GenderFilterEnum) String() string {
	return string(e)
}

func (e *GenderFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderFilterEnum", str)
	}
	return nil
}

func (e GenderFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HairColorEnum string

const (
	HairColorEnumBlonde   HairColorEnum = "BLONDE"
	HairColorEnumBrunette HairColorEnum = "BRUNETTE"
	HairColorEnumBlack    HairColorEnum = "BLACK"
	HairColorEnumRed      HairColorEnum = "RED"
	HairColorEnumAuburn   HairColorEnum = "AUBURN"
	HairColorEnumGrey     HairColorEnum = "GREY"
	HairColorEnumBald     HairColorEnum = "BALD"
	HairColorEnumVarious  HairColorEnum = "VARIOUS"
	HairColorEnumOther    HairColorEnum = "OTHER"
)

var AllHairColorEnum = []HairColorEnum{
	HairColorEnumBlonde,
	HairColorEnumBrunette,
	HairColorEnumBlack,
	HairColorEnumRed,
	HairColorEnumAuburn,
	HairColorEnumGrey,
	HairColorEnumBald,
	HairColorEnumVarious,
	HairColorEnumOther,
}

func (e HairColorEnum) IsValid() bool {
	switch e {
	case HairColorEnumBlonde, HairColorEnumBrunette, HairColorEnumBlack, HairColorEnumRed, HairColorEnumAuburn, HairColorEnumGrey, HairColorEnumBald, HairColorEnumVarious, HairColorEnumOther:
		return true
	}
	return false
}

func (e HairColorEnum) String() string {
	return string(e)
}

func (e *HairColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HairColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HairColorEnum", str)
	}
	return nil
}

func (e HairColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationEnum string

const (
	OperationEnumCreate  OperationEnum = "CREATE"
	OperationEnumModify  OperationEnum = "MODIFY"
	OperationEnumDestroy OperationEnum = "DESTROY"
	OperationEnumMerge   OperationEnum = "MERGE"
)

var AllOperationEnum = []OperationEnum{
	OperationEnumCreate,
	OperationEnumModify,
	OperationEnumDestroy,
	OperationEnumMerge,
}

func (e OperationEnum) IsValid() bool {
	switch e {
	case OperationEnumCreate, OperationEnumModify, OperationEnumDestroy, OperationEnumMerge:
		return true
	}
	return false
}

func (e OperationEnum) String() string {
	return string(e)
}

func (e *OperationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationEnum", str)
	}
	return nil
}

func (e OperationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PerformerSortEnum string

const (
	PerformerSortEnumName            PerformerSortEnum = "NAME"
	PerformerSortEnumBirthdate       PerformerSortEnum = "BIRTHDATE"
	PerformerSortEnumSceneCount      PerformerSortEnum = "SCENE_COUNT"
	PerformerSortEnumCareerStartYear PerformerSortEnum = "CAREER_START_YEAR"
	PerformerSortEnumDebut           PerformerSortEnum = "DEBUT"
	PerformerSortEnumLastScene       PerformerSortEnum = "LAST_SCENE"
	PerformerSortEnumCreatedAt       PerformerSortEnum = "CREATED_AT"
	PerformerSortEnumUpdatedAt       PerformerSortEnum = "UPDATED_AT"
)

var AllPerformerSortEnum = []PerformerSortEnum{
	PerformerSortEnumName,
	PerformerSortEnumBirthdate,
	PerformerSortEnumSceneCount,
	PerformerSortEnumCareerStartYear,
	PerformerSortEnumDebut,
	PerformerSortEnumLastScene,
	PerformerSortEnumCreatedAt,
	PerformerSortEnumUpdatedAt,
}

func (e PerformerSortEnum) IsValid() bool {
	switch e {
	case PerformerSortEnumName, PerformerSortEnumBirthdate, PerformerSortEnumSceneCount, PerformerSortEnumCareerStartYear, PerformerSortEnumDebut, PerformerSortEnumLastScene, PerformerSortEnumCreatedAt, PerformerSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e PerformerSortEnum) String() string {
	return string(e)
}

func (e *PerformerSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PerformerSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PerformerSortEnum", str)
	}
	return nil
}

func (e PerformerSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleEnum string

const (
	RoleEnumRead   RoleEnum = "READ"
	RoleEnumVote   RoleEnum = "VOTE"
	RoleEnumEdit   RoleEnum = "EDIT"
	RoleEnumModify RoleEnum = "MODIFY"
	RoleEnumAdmin  RoleEnum = "ADMIN"
	// May generate invites without tokens
	RoleEnumInvite RoleEnum = "INVITE"
	// May grant and rescind invite tokens and resind invite keys
	RoleEnumManageInvites RoleEnum = "MANAGE_INVITES"
	RoleEnumBot           RoleEnum = "BOT"
)

var AllRoleEnum = []RoleEnum{
	RoleEnumRead,
	RoleEnumVote,
	RoleEnumEdit,
	RoleEnumModify,
	RoleEnumAdmin,
	RoleEnumInvite,
	RoleEnumManageInvites,
	RoleEnumBot,
}

func (e RoleEnum) IsValid() bool {
	switch e {
	case RoleEnumRead, RoleEnumVote, RoleEnumEdit, RoleEnumModify, RoleEnumAdmin, RoleEnumInvite, RoleEnumManageInvites, RoleEnumBot:
		return true
	}
	return false
}

func (e RoleEnum) String() string {
	return string(e)
}

func (e *RoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleEnum", str)
	}
	return nil
}

func (e RoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SceneSortEnum string

const (
	SceneSortEnumTitle     SceneSortEnum = "TITLE"
	SceneSortEnumDate      SceneSortEnum = "DATE"
	SceneSortEnumTrending  SceneSortEnum = "TRENDING"
	SceneSortEnumCreatedAt SceneSortEnum = "CREATED_AT"
	SceneSortEnumUpdatedAt SceneSortEnum = "UPDATED_AT"
)

var AllSceneSortEnum = []SceneSortEnum{
	SceneSortEnumTitle,
	SceneSortEnumDate,
	SceneSortEnumTrending,
	SceneSortEnumCreatedAt,
	SceneSortEnumUpdatedAt,
}

func (e SceneSortEnum) IsValid() bool {
	switch e {
	case SceneSortEnumTitle, SceneSortEnumDate, SceneSortEnumTrending, SceneSortEnumCreatedAt, SceneSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e SceneSortEnum) String() string {
	return string(e)
}

func (e *SceneSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SceneSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SceneSortEnum", str)
	}
	return nil
}

func (e SceneSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StudioSortEnum string

const (
	StudioSortEnumName      StudioSortEnum = "NAME"
	StudioSortEnumCreatedAt StudioSortEnum = "CREATED_AT"
	StudioSortEnumUpdatedAt StudioSortEnum = "UPDATED_AT"
)

var AllStudioSortEnum = []StudioSortEnum{
	StudioSortEnumName,
	StudioSortEnumCreatedAt,
	StudioSortEnumUpdatedAt,
}

func (e StudioSortEnum) IsValid() bool {
	switch e {
	case StudioSortEnumName, StudioSortEnumCreatedAt, StudioSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e StudioSortEnum) String() string {
	return string(e)
}

func (e *StudioSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StudioSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StudioSortEnum", str)
	}
	return nil
}

func (e StudioSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagGroupEnum string

const (
	TagGroupEnumPeople TagGroupEnum = "PEOPLE"
	TagGroupEnumScene  TagGroupEnum = "SCENE"
	TagGroupEnumAction TagGroupEnum = "ACTION"
)

var AllTagGroupEnum = []TagGroupEnum{
	TagGroupEnumPeople,
	TagGroupEnumScene,
	TagGroupEnumAction,
}

func (e TagGroupEnum) IsValid() bool {
	switch e {
	case TagGroupEnumPeople, TagGroupEnumScene, TagGroupEnumAction:
		return true
	}
	return false
}

func (e TagGroupEnum) String() string {
	return string(e)
}

func (e *TagGroupEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagGroupEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagGroupEnum", str)
	}
	return nil
}

func (e TagGroupEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagSortEnum string

const (
	TagSortEnumName      TagSortEnum = "NAME"
	TagSortEnumCreatedAt TagSortEnum = "CREATED_AT"
	TagSortEnumUpdatedAt TagSortEnum = "UPDATED_AT"
)

var AllTagSortEnum = []TagSortEnum{
	TagSortEnumName,
	TagSortEnumCreatedAt,
	TagSortEnumUpdatedAt,
}

func (e TagSortEnum) IsValid() bool {
	switch e {
	case TagSortEnumName, TagSortEnumCreatedAt, TagSortEnumUpdatedAt:
		return true
	}
	return false
}

func (e TagSortEnum) String() string {
	return string(e)
}

func (e *TagSortEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagSortEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagSortEnum", str)
	}
	return nil
}

func (e TagSortEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetTypeEnum string

const (
	TargetTypeEnumScene     TargetTypeEnum = "SCENE"
	TargetTypeEnumStudio    TargetTypeEnum = "STUDIO"
	TargetTypeEnumPerformer TargetTypeEnum = "PERFORMER"
	TargetTypeEnumTag       TargetTypeEnum = "TAG"
)

var AllTargetTypeEnum = []TargetTypeEnum{
	TargetTypeEnumScene,
	TargetTypeEnumStudio,
	TargetTypeEnumPerformer,
	TargetTypeEnumTag,
}

func (e TargetTypeEnum) IsValid() bool {
	switch e {
	case TargetTypeEnumScene, TargetTypeEnumStudio, TargetTypeEnumPerformer, TargetTypeEnumTag:
		return true
	}
	return false
}

func (e TargetTypeEnum) String() string {
	return string(e)
}

func (e *TargetTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetTypeEnum", str)
	}
	return nil
}

func (e TargetTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserVotedFilterEnum string

const (
	UserVotedFilterEnumAbstain  UserVotedFilterEnum = "ABSTAIN"
	UserVotedFilterEnumAccept   UserVotedFilterEnum = "ACCEPT"
	UserVotedFilterEnumReject   UserVotedFilterEnum = "REJECT"
	UserVotedFilterEnumNotVoted UserVotedFilterEnum = "NOT_VOTED"
)

var AllUserVotedFilterEnum = []UserVotedFilterEnum{
	UserVotedFilterEnumAbstain,
	UserVotedFilterEnumAccept,
	UserVotedFilterEnumReject,
	UserVotedFilterEnumNotVoted,
}

func (e UserVotedFilterEnum) IsValid() bool {
	switch e {
	case UserVotedFilterEnumAbstain, UserVotedFilterEnumAccept, UserVotedFilterEnumReject, UserVotedFilterEnumNotVoted:
		return true
	}
	return false
}

func (e UserVotedFilterEnum) String() string {
	return string(e)
}

func (e *UserVotedFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserVotedFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserVotedFilterEnum", str)
	}
	return nil
}

func (e UserVotedFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValidSiteTypeEnum string

const (
	ValidSiteTypeEnumPerformer ValidSiteTypeEnum = "PERFORMER"
	ValidSiteTypeEnumScene     ValidSiteTypeEnum = "SCENE"
	ValidSiteTypeEnumStudio    ValidSiteTypeEnum = "STUDIO"
)

var AllValidSiteTypeEnum = []ValidSiteTypeEnum{
	ValidSiteTypeEnumPerformer,
	ValidSiteTypeEnumScene,
	ValidSiteTypeEnumStudio,
}

func (e ValidSiteTypeEnum) IsValid() bool {
	switch e {
	case ValidSiteTypeEnumPerformer, ValidSiteTypeEnumScene, ValidSiteTypeEnumStudio:
		return true
	}
	return false
}

func (e ValidSiteTypeEnum) String() string {
	return string(e)
}

func (e *ValidSiteTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidSiteTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidSiteTypeEnum", str)
	}
	return nil
}

func (e ValidSiteTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteStatusEnum string

const (
	VoteStatusEnumAccepted          VoteStatusEnum = "ACCEPTED"
	VoteStatusEnumRejected          VoteStatusEnum = "REJECTED"
	VoteStatusEnumPending           VoteStatusEnum = "PENDING"
	VoteStatusEnumImmediateAccepted VoteStatusEnum = "IMMEDIATE_ACCEPTED"
	VoteStatusEnumImmediateRejected VoteStatusEnum = "IMMEDIATE_REJECTED"
	VoteStatusEnumFailed            VoteStatusEnum = "FAILED"
	VoteStatusEnumCanceled          VoteStatusEnum = "CANCELED"
)

var AllVoteStatusEnum = []VoteStatusEnum{
	VoteStatusEnumAccepted,
	VoteStatusEnumRejected,
	VoteStatusEnumPending,
	VoteStatusEnumImmediateAccepted,
	VoteStatusEnumImmediateRejected,
	VoteStatusEnumFailed,
	VoteStatusEnumCanceled,
}

func (e VoteStatusEnum) IsValid() bool {
	switch e {
	case VoteStatusEnumAccepted, VoteStatusEnumRejected, VoteStatusEnumPending, VoteStatusEnumImmediateAccepted, VoteStatusEnumImmediateRejected, VoteStatusEnumFailed, VoteStatusEnumCanceled:
		return true
	}
	return false
}

func (e VoteStatusEnum) String() string {
	return string(e)
}

func (e *VoteStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteStatusEnum", str)
	}
	return nil
}

func (e VoteStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteTypeEnum string

const (
	VoteTypeEnumAbstain VoteTypeEnum = "ABSTAIN"
	VoteTypeEnumAccept  VoteTypeEnum = "ACCEPT"
	VoteTypeEnumReject  VoteTypeEnum = "REJECT"
	// Immediately accepts the edit - bypassing the vote
	VoteTypeEnumImmediateAccept VoteTypeEnum = "IMMEDIATE_ACCEPT"
	// Immediately rejects the edit - bypassing the vote
	VoteTypeEnumImmediateReject VoteTypeEnum = "IMMEDIATE_REJECT"
)

var AllVoteTypeEnum = []VoteTypeEnum{
	VoteTypeEnumAbstain,
	VoteTypeEnumAccept,
	VoteTypeEnumReject,
	VoteTypeEnumImmediateAccept,
	VoteTypeEnumImmediateReject,
}

func (e VoteTypeEnum) IsValid() bool {
	switch e {
	case VoteTypeEnumAbstain, VoteTypeEnumAccept, VoteTypeEnumReject, VoteTypeEnumImmediateAccept, VoteTypeEnumImmediateReject:
		return true
	}
	return false
}

func (e VoteTypeEnum) String() string {
	return string(e)
}

func (e *VoteTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteTypeEnum", str)
	}
	return nil
}

func (e VoteTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
