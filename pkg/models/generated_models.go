// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

type EditDetails interface {
	IsEditDetails()
}

type EditTarget interface {
	IsEditTarget()
}

type ActivateNewUserInput struct {
	Name          string `json:"name"`
	Email         string `json:"email"`
	ActivationKey string `json:"activation_key"`
	Password      string `json:"password"`
}

type ApplyEditInput struct {
	ID string `json:"id"`
}

type BodyModificationCriterionInput struct {
	Location    *string           `json:"location"`
	Description *string           `json:"description"`
	Modifier    CriterionModifier `json:"modifier"`
}

type BreastTypeCriterionInput struct {
	Value    *BreastTypeEnum   `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type CancelEditInput struct {
	ID string `json:"id"`
}

type DateCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type EditCommentInput struct {
	ID      string `json:"id"`
	Comment string `json:"comment"`
}

type EditFilterType struct {
	// Filter by user id
	UserID *string `json:"user_id"`
	// Filter by status
	Status *VoteStatusEnum `json:"status"`
	// Filter by operation
	Operation *OperationEnum `json:"operation"`
	// Filter by vote count
	VoteCount *IntCriterionInput `json:"vote_count"`
	// Filter by applied status
	Applied *bool `json:"applied"`
	// Filter by target type
	TargetType *TargetTypeEnum `json:"target_type"`
	// Filter by target id
	TargetID *string `json:"target_id"`
}

type EditInput struct {
	// Not required for create type
	ID        *string       `json:"id"`
	Operation OperationEnum `json:"operation"`
	// Required for amending an existing edit
	EditID *string `json:"edit_id"`
	// Only required for merge type
	MergeSourceIds []string `json:"merge_source_ids"`
	Comment        *string  `json:"comment"`
}

type EditVoteInput struct {
	ID      string       `json:"id"`
	Comment *string      `json:"comment"`
	Type    VoteTypeEnum `json:"type"`
}

type EyeColorCriterionInput struct {
	Value    *EyeColorEnum     `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Fingerprint struct {
	Hash        string               `json:"hash"`
	Algorithm   FingerprintAlgorithm `json:"algorithm"`
	Duration    int                  `json:"duration"`
	Submissions int                  `json:"submissions"`
	Created     time.Time            `json:"created"`
	Updated     time.Time            `json:"updated"`
}

type FingerprintEditInput struct {
	UserIds     []string             `json:"user_ids"`
	Hash        string               `json:"hash"`
	Algorithm   FingerprintAlgorithm `json:"algorithm"`
	Duration    int                  `json:"duration"`
	Created     time.Time            `json:"created"`
	Submissions *int                 `json:"submissions"`
	Updated     *time.Time           `json:"updated"`
}

type FingerprintInput struct {
	// assumes current user if omitted. Ignored for non-modify Users
	UserIds   []string             `json:"user_ids"`
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
	Duration  int                  `json:"duration"`
}

type FingerprintQueryInput struct {
	Hash      string               `json:"hash"`
	Algorithm FingerprintAlgorithm `json:"algorithm"`
}

type FingerprintSubmission struct {
	SceneID     string            `json:"scene_id"`
	Fingerprint *FingerprintInput `json:"fingerprint"`
	Unmatch     *bool             `json:"unmatch"`
}

type FuzzyDate struct {
	Date     string           `json:"date"`
	Accuracy DateAccuracyEnum `json:"accuracy"`
}

type FuzzyDateInput struct {
	Date     string           `json:"date"`
	Accuracy DateAccuracyEnum `json:"accuracy"`
}

type GrantInviteInput struct {
	UserID string `json:"user_id"`
	Amount int    `json:"amount"`
}

type HairColorCriterionInput struct {
	Value    *HairColorEnum    `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type IDCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type ImageCreateInput struct {
	URL  *string         `json:"url"`
	File *graphql.Upload `json:"file"`
}

type ImageDestroyInput struct {
	ID string `json:"id"`
}

type ImageUpdateInput struct {
	ID  string  `json:"id"`
	URL *string `json:"url"`
}

type IntCriterionInput struct {
	Value    int               `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Measurements struct {
	CupSize  *string `json:"cup_size"`
	BandSize *int    `json:"band_size"`
	Waist    *int    `json:"waist"`
	Hip      *int    `json:"hip"`
}

type MeasurementsInput struct {
	CupSize  *string `json:"cup_size"`
	BandSize *int    `json:"band_size"`
	Waist    *int    `json:"waist"`
	Hip      *int    `json:"hip"`
}

type MultiIDCriterionInput struct {
	Value    []string          `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type NewUserInput struct {
	Email     string  `json:"email"`
	InviteKey *string `json:"invite_key"`
}

type PerformerAppearance struct {
	Performer *Performer `json:"performer"`
	// Performing as alias
	As *string `json:"as"`
}

type PerformerAppearanceInput struct {
	PerformerID string `json:"performer_id"`
	// Performing as alias
	As *string `json:"as"`
}

type PerformerCreateInput struct {
	Name            string              `json:"name"`
	Disambiguation  *string             `json:"disambiguation"`
	Aliases         []string            `json:"aliases"`
	Gender          *GenderEnum         `json:"gender"`
	Urls            []*URL              `json:"urls"`
	Birthdate       *FuzzyDateInput     `json:"birthdate"`
	Ethnicity       *EthnicityEnum      `json:"ethnicity"`
	Country         *string             `json:"country"`
	EyeColor        *EyeColorEnum       `json:"eye_color"`
	HairColor       *HairColorEnum      `json:"hair_color"`
	Height          *int                `json:"height"`
	Measurements    *MeasurementsInput  `json:"measurements"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	ImageIds        []string            `json:"image_ids"`
}

type PerformerDestroyInput struct {
	ID string `json:"id"`
}

type PerformerEditDetailsInput struct {
	Name            *string             `json:"name"`
	Disambiguation  *string             `json:"disambiguation"`
	Aliases         []string            `json:"aliases"`
	Gender          *GenderEnum         `json:"gender"`
	Urls            []*URL              `json:"urls"`
	Birthdate       *FuzzyDateInput     `json:"birthdate"`
	Ethnicity       *EthnicityEnum      `json:"ethnicity"`
	Country         *string             `json:"country"`
	EyeColor        *EyeColorEnum       `json:"eye_color"`
	HairColor       *HairColorEnum      `json:"hair_color"`
	Height          *int                `json:"height"`
	Measurements    *MeasurementsInput  `json:"measurements"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	ImageIds        []string            `json:"image_ids"`
}

type PerformerEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *PerformerEditDetailsInput `json:"details"`
	// Controls aliases modification for merges and name modifications
	Options *PerformerEditOptionsInput `json:"options"`
}

type PerformerEditOptions struct {
	// Set performer alias on scenes without alias to old name if name is changed
	SetModifyAliases bool `json:"set_modify_aliases"`
	// Set performer alias on scenes attached to merge sources to old name
	SetMergeAliases bool `json:"set_merge_aliases"`
}

type PerformerEditOptionsInput struct {
	// Set performer alias on scenes without alias to old name if name is changed
	SetModifyAliases *bool `json:"set_modify_aliases"`
	// Set performer alias on scenes attached to merge sources to old name
	SetMergeAliases *bool `json:"set_merge_aliases"`
}

type PerformerFilterType struct {
	// Searches name and aliases - assumes like query unless quoted
	Names *string `json:"names"`
	// Searches name only - assumes like query unless quoted
	Name *string `json:"name"`
	// Search aliases only - assumes like query unless quoted
	Alias          *string               `json:"alias"`
	Disambiguation *StringCriterionInput `json:"disambiguation"`
	Gender         *GenderFilterEnum     `json:"gender"`
	// Filter to search urls - assumes like query unless quoted
	URL             *string                         `json:"url"`
	Birthdate       *DateCriterionInput             `json:"birthdate"`
	BirthYear       *IntCriterionInput              `json:"birth_year"`
	Age             *IntCriterionInput              `json:"age"`
	Ethnicity       *EthnicityFilterEnum            `json:"ethnicity"`
	Country         *StringCriterionInput           `json:"country"`
	EyeColor        *EyeColorCriterionInput         `json:"eye_color"`
	HairColor       *HairColorCriterionInput        `json:"hair_color"`
	Height          *IntCriterionInput              `json:"height"`
	CupSize         *StringCriterionInput           `json:"cup_size"`
	BandSize        *IntCriterionInput              `json:"band_size"`
	WaistSize       *IntCriterionInput              `json:"waist_size"`
	HipSize         *IntCriterionInput              `json:"hip_size"`
	BreastType      *BreastTypeCriterionInput       `json:"breast_type"`
	CareerStartYear *IntCriterionInput              `json:"career_start_year"`
	CareerEndYear   *IntCriterionInput              `json:"career_end_year"`
	Tattoos         *BodyModificationCriterionInput `json:"tattoos"`
	Piercings       *BodyModificationCriterionInput `json:"piercings"`
}

type PerformerUpdateInput struct {
	ID              string              `json:"id"`
	Name            *string             `json:"name"`
	Disambiguation  *string             `json:"disambiguation"`
	Aliases         []string            `json:"aliases"`
	Gender          *GenderEnum         `json:"gender"`
	Urls            []*URL              `json:"urls"`
	Birthdate       *FuzzyDateInput     `json:"birthdate"`
	Ethnicity       *EthnicityEnum      `json:"ethnicity"`
	Country         *string             `json:"country"`
	EyeColor        *EyeColorEnum       `json:"eye_color"`
	HairColor       *HairColorEnum      `json:"hair_color"`
	Height          *int                `json:"height"`
	Measurements    *MeasurementsInput  `json:"measurements"`
	BreastType      *BreastTypeEnum     `json:"breast_type"`
	CareerStartYear *int                `json:"career_start_year"`
	CareerEndYear   *int                `json:"career_end_year"`
	Tattoos         []*BodyModification `json:"tattoos"`
	Piercings       []*BodyModification `json:"piercings"`
	ImageIds        []string            `json:"image_ids"`
}

type QueryEditsResultType struct {
	Count int     `json:"count"`
	Edits []*Edit `json:"edits"`
}

type QueryPerformersResultType struct {
	Count      int          `json:"count"`
	Performers []*Performer `json:"performers"`
}

type QueryScenesResultType struct {
	Count  int      `json:"count"`
	Scenes []*Scene `json:"scenes"`
}

type QuerySpec struct {
	Page      *int               `json:"page"`
	PerPage   *int               `json:"per_page"`
	Sort      *string            `json:"sort"`
	Direction *SortDirectionEnum `json:"direction"`
}

type QueryStudiosResultType struct {
	Count   int       `json:"count"`
	Studios []*Studio `json:"studios"`
}

type QueryTagCategoriesResultType struct {
	Count         int            `json:"count"`
	TagCategories []*TagCategory `json:"tag_categories"`
}

type QueryTagsResultType struct {
	Count int    `json:"count"`
	Tags  []*Tag `json:"tags"`
}

type QueryUsersResultType struct {
	Count int     `json:"count"`
	Users []*User `json:"users"`
}

type ResetPasswordInput struct {
	Email string `json:"email"`
}

type RevokeInviteInput struct {
	UserID string `json:"user_id"`
	Amount int    `json:"amount"`
}

type RoleCriterionInput struct {
	Value    []RoleEnum        `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type SceneCreateInput struct {
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URL                      `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *string                     `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []string                    `json:"tag_ids"`
	ImageIds     []string                    `json:"image_ids"`
	Fingerprints []*FingerprintEditInput     `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
}

type SceneDestroyInput struct {
	ID string `json:"id"`
}

type SceneEditDetailsInput struct {
	Title      *string                     `json:"title"`
	Details    *string                     `json:"details"`
	Urls       []*URL                      `json:"urls"`
	Date       *string                     `json:"date"`
	StudioID   *string                     `json:"studio_id"`
	Performers []*PerformerAppearanceInput `json:"performers"`
	TagIds     []string                    `json:"tag_ids"`
	ImageIds   []string                    `json:"image_ids"`
	Duration   *int                        `json:"duration"`
	Director   *string                     `json:"director"`
}

type SceneEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details  *SceneEditDetailsInput `json:"details"`
	Duration *int                   `json:"duration"`
}

type SceneFilterType struct {
	// Filter to search title and details - assumes like query unless quoted
	Text *string `json:"text"`
	// Filter to search title - assumes like query unless quoted
	Title *string `json:"title"`
	// Filter to search urls - assumes like query unless quoted
	URL *string `json:"url"`
	// Filter by date
	Date *DateCriterionInput `json:"date"`
	// Filter to only include scenes with this studio
	Studios *MultiIDCriterionInput `json:"studios"`
	// Filter to only include scenes with this studio as primary or parent
	ParentStudio *string `json:"parentStudio"`
	// Filter to only include scenes with these tags
	Tags *MultiIDCriterionInput `json:"tags"`
	// Filter to only include scenes with these performers
	Performers *MultiIDCriterionInput `json:"performers"`
	// Filter to include scenes with performer appearing as alias
	Alias *StringCriterionInput `json:"alias"`
	// Filter to only include scenes with these fingerprints
	Fingerprints *MultiIDCriterionInput `json:"fingerprints"`
}

type SceneUpdateInput struct {
	ID           string                      `json:"id"`
	Title        *string                     `json:"title"`
	Details      *string                     `json:"details"`
	Urls         []*URL                      `json:"urls"`
	Date         *string                     `json:"date"`
	StudioID     *string                     `json:"studio_id"`
	Performers   []*PerformerAppearanceInput `json:"performers"`
	TagIds       []string                    `json:"tag_ids"`
	ImageIds     []string                    `json:"image_ids"`
	Fingerprints []*FingerprintEditInput     `json:"fingerprints"`
	Duration     *int                        `json:"duration"`
	Director     *string                     `json:"director"`
}

type StringCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type StudioCreateInput struct {
	Name     string   `json:"name"`
	Urls     []*URL   `json:"urls"`
	ParentID *string  `json:"parent_id"`
	ImageIds []string `json:"image_ids"`
}

type StudioDestroyInput struct {
	ID string `json:"id"`
}

type StudioEditDetailsInput struct {
	Name     *string  `json:"name"`
	Urls     []*URL   `json:"urls"`
	ParentID *string  `json:"parent_id"`
	ImageIds []string `json:"image_ids"`
}

type StudioEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *StudioEditDetailsInput `json:"details"`
}

type StudioFilterType struct {
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to search studio and parent studio name - assumes like query unless quoted
	Names *string `json:"names"`
	// Filter to search url - assumes like query unless quoted
	URL       *string           `json:"url"`
	Parent    *IDCriterionInput `json:"parent"`
	HasParent *bool             `json:"has_parent"`
}

type StudioUpdateInput struct {
	ID       string   `json:"id"`
	Name     *string  `json:"name"`
	Urls     []*URL   `json:"urls"`
	ParentID *string  `json:"parent_id"`
	ImageIds []string `json:"image_ids"`
}

type TagCategoryCreateInput struct {
	Name        string       `json:"name"`
	Group       TagGroupEnum `json:"group"`
	Description *string      `json:"description"`
}

type TagCategoryDestroyInput struct {
	ID string `json:"id"`
}

type TagCategoryUpdateInput struct {
	ID          string        `json:"id"`
	Name        *string       `json:"name"`
	Group       *TagGroupEnum `json:"group"`
	Description *string       `json:"description"`
}

type TagCreateInput struct {
	Name        string   `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
	CategoryID  *string  `json:"category_id"`
}

type TagDestroyInput struct {
	ID string `json:"id"`
}

type TagEditDetailsInput struct {
	Name        *string  `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
	CategoryID  *string  `json:"category_id"`
}

type TagEditInput struct {
	Edit *EditInput `json:"edit"`
	// Not required for destroy type
	Details *TagEditDetailsInput `json:"details"`
}

type TagFilterType struct {
	// Filter to search name, aliases and description - assumes like query unless quoted
	Text *string `json:"text"`
	// Searches name and aliases - assumes like query unless quoted
	Names *string `json:"names"`
	// Filter to search name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to category ID
	CategoryID *string `json:"category_id"`
}

type TagUpdateInput struct {
	ID          string   `json:"id"`
	Name        *string  `json:"name"`
	Description *string  `json:"description"`
	Aliases     []string `json:"aliases"`
	CategoryID  *string  `json:"category_id"`
}

type UserChangePasswordInput struct {
	// Password in plain text
	ExistingPassword *string `json:"existing_password"`
	NewPassword      string  `json:"new_password"`
	ResetKey         *string `json:"reset_key"`
}

type UserCreateInput struct {
	Name string `json:"name"`
	// Password in plain text
	Password    string     `json:"password"`
	Roles       []RoleEnum `json:"roles"`
	Email       string     `json:"email"`
	InvitedByID *string    `json:"invited_by_id"`
}

type UserDestroyInput struct {
	ID string `json:"id"`
}

type UserFilterType struct {
	// Filter to search user name - assumes like query unless quoted
	Name *string `json:"name"`
	// Filter to search email - assumes like query unless quoted
	Email *string `json:"email"`
	// Filter by roles
	Roles *RoleCriterionInput `json:"roles"`
	// Filter by api key
	APIKey *string `json:"apiKey"`
	// Filter by successful edits
	SuccessfulEdits *IntCriterionInput `json:"successful_edits"`
	// Filter by unsuccessful edits
	UnsuccessfulEdits *IntCriterionInput `json:"unsuccessful_edits"`
	// Filter by votes on successful edits
	SuccessfulVotes *IntCriterionInput `json:"successful_votes"`
	// Filter by votes on unsuccessful edits
	UnsuccessfulVotes *IntCriterionInput `json:"unsuccessful_votes"`
	// Filter by number of API calls
	APICalls *IntCriterionInput `json:"api_calls"`
	// Filter by user that invited
	InvitedBy *string `json:"invited_by"`
}

type UserUpdateInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name"`
	// Password in plain text
	Password *string    `json:"password"`
	Roles    []RoleEnum `json:"roles"`
	Email    *string    `json:"email"`
}

type Version struct {
	Hash      string `json:"hash"`
	BuildTime string `json:"build_time"`
	Version   string `json:"version"`
}

type VoteComment struct {
	User    *User         `json:"user"`
	Date    *string       `json:"date"`
	Comment *string       `json:"comment"`
	Type    *VoteTypeEnum `json:"type"`
}

type BreastTypeEnum string

const (
	BreastTypeEnumNatural BreastTypeEnum = "NATURAL"
	BreastTypeEnumFake    BreastTypeEnum = "FAKE"
	BreastTypeEnumNa      BreastTypeEnum = "NA"
)

var AllBreastTypeEnum = []BreastTypeEnum{
	BreastTypeEnumNatural,
	BreastTypeEnumFake,
	BreastTypeEnumNa,
}

func (e BreastTypeEnum) IsValid() bool {
	switch e {
	case BreastTypeEnumNatural, BreastTypeEnumFake, BreastTypeEnumNa:
		return true
	}
	return false
}

func (e BreastTypeEnum) String() string {
	return string(e)
}

func (e *BreastTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BreastTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BreastTypeEnum", str)
	}
	return nil
}

func (e BreastTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CriterionModifier string

const (
	// =
	CriterionModifierEquals CriterionModifier = "EQUALS"
	// !=
	CriterionModifierNotEquals CriterionModifier = "NOT_EQUALS"
	// >
	CriterionModifierGreaterThan CriterionModifier = "GREATER_THAN"
	// <
	CriterionModifierLessThan CriterionModifier = "LESS_THAN"
	// IS NULL
	CriterionModifierIsNull CriterionModifier = "IS_NULL"
	// IS NOT NULL
	CriterionModifierNotNull CriterionModifier = "NOT_NULL"
	// INCLUDES ALL
	CriterionModifierIncludesAll CriterionModifier = "INCLUDES_ALL"
	CriterionModifierIncludes    CriterionModifier = "INCLUDES"
	CriterionModifierExcludes    CriterionModifier = "EXCLUDES"
)

var AllCriterionModifier = []CriterionModifier{
	CriterionModifierEquals,
	CriterionModifierNotEquals,
	CriterionModifierGreaterThan,
	CriterionModifierLessThan,
	CriterionModifierIsNull,
	CriterionModifierNotNull,
	CriterionModifierIncludesAll,
	CriterionModifierIncludes,
	CriterionModifierExcludes,
}

func (e CriterionModifier) IsValid() bool {
	switch e {
	case CriterionModifierEquals, CriterionModifierNotEquals, CriterionModifierGreaterThan, CriterionModifierLessThan, CriterionModifierIsNull, CriterionModifierNotNull, CriterionModifierIncludesAll, CriterionModifierIncludes, CriterionModifierExcludes:
		return true
	}
	return false
}

func (e CriterionModifier) String() string {
	return string(e)
}

func (e *CriterionModifier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CriterionModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CriterionModifier", str)
	}
	return nil
}

func (e CriterionModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DateAccuracyEnum string

const (
	DateAccuracyEnumYear  DateAccuracyEnum = "YEAR"
	DateAccuracyEnumMonth DateAccuracyEnum = "MONTH"
	DateAccuracyEnumDay   DateAccuracyEnum = "DAY"
)

var AllDateAccuracyEnum = []DateAccuracyEnum{
	DateAccuracyEnumYear,
	DateAccuracyEnumMonth,
	DateAccuracyEnumDay,
}

func (e DateAccuracyEnum) IsValid() bool {
	switch e {
	case DateAccuracyEnumYear, DateAccuracyEnumMonth, DateAccuracyEnumDay:
		return true
	}
	return false
}

func (e DateAccuracyEnum) String() string {
	return string(e)
}

func (e *DateAccuracyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DateAccuracyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DateAccuracyEnum", str)
	}
	return nil
}

func (e DateAccuracyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityEnum string

const (
	EthnicityEnumCaucasian     EthnicityEnum = "CAUCASIAN"
	EthnicityEnumBlack         EthnicityEnum = "BLACK"
	EthnicityEnumAsian         EthnicityEnum = "ASIAN"
	EthnicityEnumIndian        EthnicityEnum = "INDIAN"
	EthnicityEnumLatin         EthnicityEnum = "LATIN"
	EthnicityEnumMiddleEastern EthnicityEnum = "MIDDLE_EASTERN"
	EthnicityEnumMixed         EthnicityEnum = "MIXED"
	EthnicityEnumOther         EthnicityEnum = "OTHER"
)

var AllEthnicityEnum = []EthnicityEnum{
	EthnicityEnumCaucasian,
	EthnicityEnumBlack,
	EthnicityEnumAsian,
	EthnicityEnumIndian,
	EthnicityEnumLatin,
	EthnicityEnumMiddleEastern,
	EthnicityEnumMixed,
	EthnicityEnumOther,
}

func (e EthnicityEnum) IsValid() bool {
	switch e {
	case EthnicityEnumCaucasian, EthnicityEnumBlack, EthnicityEnumAsian, EthnicityEnumIndian, EthnicityEnumLatin, EthnicityEnumMiddleEastern, EthnicityEnumMixed, EthnicityEnumOther:
		return true
	}
	return false
}

func (e EthnicityEnum) String() string {
	return string(e)
}

func (e *EthnicityEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityEnum", str)
	}
	return nil
}

func (e EthnicityEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EthnicityFilterEnum string

const (
	EthnicityFilterEnumUnknown       EthnicityFilterEnum = "UNKNOWN"
	EthnicityFilterEnumCaucasian     EthnicityFilterEnum = "CAUCASIAN"
	EthnicityFilterEnumBlack         EthnicityFilterEnum = "BLACK"
	EthnicityFilterEnumAsian         EthnicityFilterEnum = "ASIAN"
	EthnicityFilterEnumIndian        EthnicityFilterEnum = "INDIAN"
	EthnicityFilterEnumLatin         EthnicityFilterEnum = "LATIN"
	EthnicityFilterEnumMiddleEastern EthnicityFilterEnum = "MIDDLE_EASTERN"
	EthnicityFilterEnumMixed         EthnicityFilterEnum = "MIXED"
	EthnicityFilterEnumOther         EthnicityFilterEnum = "OTHER"
)

var AllEthnicityFilterEnum = []EthnicityFilterEnum{
	EthnicityFilterEnumUnknown,
	EthnicityFilterEnumCaucasian,
	EthnicityFilterEnumBlack,
	EthnicityFilterEnumAsian,
	EthnicityFilterEnumIndian,
	EthnicityFilterEnumLatin,
	EthnicityFilterEnumMiddleEastern,
	EthnicityFilterEnumMixed,
	EthnicityFilterEnumOther,
}

func (e EthnicityFilterEnum) IsValid() bool {
	switch e {
	case EthnicityFilterEnumUnknown, EthnicityFilterEnumCaucasian, EthnicityFilterEnumBlack, EthnicityFilterEnumAsian, EthnicityFilterEnumIndian, EthnicityFilterEnumLatin, EthnicityFilterEnumMiddleEastern, EthnicityFilterEnumMixed, EthnicityFilterEnumOther:
		return true
	}
	return false
}

func (e EthnicityFilterEnum) String() string {
	return string(e)
}

func (e *EthnicityFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EthnicityFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EthnicityFilterEnum", str)
	}
	return nil
}

func (e EthnicityFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EyeColorEnum string

const (
	EyeColorEnumBlue  EyeColorEnum = "BLUE"
	EyeColorEnumBrown EyeColorEnum = "BROWN"
	EyeColorEnumGrey  EyeColorEnum = "GREY"
	EyeColorEnumGreen EyeColorEnum = "GREEN"
	EyeColorEnumHazel EyeColorEnum = "HAZEL"
	EyeColorEnumRed   EyeColorEnum = "RED"
)

var AllEyeColorEnum = []EyeColorEnum{
	EyeColorEnumBlue,
	EyeColorEnumBrown,
	EyeColorEnumGrey,
	EyeColorEnumGreen,
	EyeColorEnumHazel,
	EyeColorEnumRed,
}

func (e EyeColorEnum) IsValid() bool {
	switch e {
	case EyeColorEnumBlue, EyeColorEnumBrown, EyeColorEnumGrey, EyeColorEnumGreen, EyeColorEnumHazel, EyeColorEnumRed:
		return true
	}
	return false
}

func (e EyeColorEnum) String() string {
	return string(e)
}

func (e *EyeColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EyeColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EyeColorEnum", str)
	}
	return nil
}

func (e EyeColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FingerprintAlgorithm string

const (
	FingerprintAlgorithmMd5    FingerprintAlgorithm = "MD5"
	FingerprintAlgorithmOshash FingerprintAlgorithm = "OSHASH"
	FingerprintAlgorithmPhash  FingerprintAlgorithm = "PHASH"
)

var AllFingerprintAlgorithm = []FingerprintAlgorithm{
	FingerprintAlgorithmMd5,
	FingerprintAlgorithmOshash,
	FingerprintAlgorithmPhash,
}

func (e FingerprintAlgorithm) IsValid() bool {
	switch e {
	case FingerprintAlgorithmMd5, FingerprintAlgorithmOshash, FingerprintAlgorithmPhash:
		return true
	}
	return false
}

func (e FingerprintAlgorithm) String() string {
	return string(e)
}

func (e *FingerprintAlgorithm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FingerprintAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FingerprintAlgorithm", str)
	}
	return nil
}

func (e FingerprintAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderEnum string

const (
	GenderEnumMale              GenderEnum = "MALE"
	GenderEnumFemale            GenderEnum = "FEMALE"
	GenderEnumTransgenderMale   GenderEnum = "TRANSGENDER_MALE"
	GenderEnumTransgenderFemale GenderEnum = "TRANSGENDER_FEMALE"
	GenderEnumIntersex          GenderEnum = "INTERSEX"
)

var AllGenderEnum = []GenderEnum{
	GenderEnumMale,
	GenderEnumFemale,
	GenderEnumTransgenderMale,
	GenderEnumTransgenderFemale,
	GenderEnumIntersex,
}

func (e GenderEnum) IsValid() bool {
	switch e {
	case GenderEnumMale, GenderEnumFemale, GenderEnumTransgenderMale, GenderEnumTransgenderFemale, GenderEnumIntersex:
		return true
	}
	return false
}

func (e GenderEnum) String() string {
	return string(e)
}

func (e *GenderEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderEnum", str)
	}
	return nil
}

func (e GenderEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GenderFilterEnum string

const (
	GenderFilterEnumUnknown           GenderFilterEnum = "UNKNOWN"
	GenderFilterEnumMale              GenderFilterEnum = "MALE"
	GenderFilterEnumFemale            GenderFilterEnum = "FEMALE"
	GenderFilterEnumTransgenderMale   GenderFilterEnum = "TRANSGENDER_MALE"
	GenderFilterEnumTransgenderFemale GenderFilterEnum = "TRANSGENDER_FEMALE"
	GenderFilterEnumIntersex          GenderFilterEnum = "INTERSEX"
)

var AllGenderFilterEnum = []GenderFilterEnum{
	GenderFilterEnumUnknown,
	GenderFilterEnumMale,
	GenderFilterEnumFemale,
	GenderFilterEnumTransgenderMale,
	GenderFilterEnumTransgenderFemale,
	GenderFilterEnumIntersex,
}

func (e GenderFilterEnum) IsValid() bool {
	switch e {
	case GenderFilterEnumUnknown, GenderFilterEnumMale, GenderFilterEnumFemale, GenderFilterEnumTransgenderMale, GenderFilterEnumTransgenderFemale, GenderFilterEnumIntersex:
		return true
	}
	return false
}

func (e GenderFilterEnum) String() string {
	return string(e)
}

func (e *GenderFilterEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderFilterEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderFilterEnum", str)
	}
	return nil
}

func (e GenderFilterEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HairColorEnum string

const (
	HairColorEnumBlonde   HairColorEnum = "BLONDE"
	HairColorEnumBrunette HairColorEnum = "BRUNETTE"
	HairColorEnumBlack    HairColorEnum = "BLACK"
	HairColorEnumRed      HairColorEnum = "RED"
	HairColorEnumAuburn   HairColorEnum = "AUBURN"
	HairColorEnumGrey     HairColorEnum = "GREY"
	HairColorEnumBald     HairColorEnum = "BALD"
	HairColorEnumVarious  HairColorEnum = "VARIOUS"
	HairColorEnumOther    HairColorEnum = "OTHER"
)

var AllHairColorEnum = []HairColorEnum{
	HairColorEnumBlonde,
	HairColorEnumBrunette,
	HairColorEnumBlack,
	HairColorEnumRed,
	HairColorEnumAuburn,
	HairColorEnumGrey,
	HairColorEnumBald,
	HairColorEnumVarious,
	HairColorEnumOther,
}

func (e HairColorEnum) IsValid() bool {
	switch e {
	case HairColorEnumBlonde, HairColorEnumBrunette, HairColorEnumBlack, HairColorEnumRed, HairColorEnumAuburn, HairColorEnumGrey, HairColorEnumBald, HairColorEnumVarious, HairColorEnumOther:
		return true
	}
	return false
}

func (e HairColorEnum) String() string {
	return string(e)
}

func (e *HairColorEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HairColorEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HairColorEnum", str)
	}
	return nil
}

func (e HairColorEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationEnum string

const (
	OperationEnumCreate  OperationEnum = "CREATE"
	OperationEnumModify  OperationEnum = "MODIFY"
	OperationEnumDestroy OperationEnum = "DESTROY"
	OperationEnumMerge   OperationEnum = "MERGE"
)

var AllOperationEnum = []OperationEnum{
	OperationEnumCreate,
	OperationEnumModify,
	OperationEnumDestroy,
	OperationEnumMerge,
}

func (e OperationEnum) IsValid() bool {
	switch e {
	case OperationEnumCreate, OperationEnumModify, OperationEnumDestroy, OperationEnumMerge:
		return true
	}
	return false
}

func (e OperationEnum) String() string {
	return string(e)
}

func (e *OperationEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationEnum", str)
	}
	return nil
}

func (e OperationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleEnum string

const (
	RoleEnumRead   RoleEnum = "READ"
	RoleEnumVote   RoleEnum = "VOTE"
	RoleEnumEdit   RoleEnum = "EDIT"
	RoleEnumModify RoleEnum = "MODIFY"
	RoleEnumAdmin  RoleEnum = "ADMIN"
	// May generate invites without tokens
	RoleEnumInvite RoleEnum = "INVITE"
	// May grant and rescind invite tokens and resind invite keys
	RoleEnumManageInvites RoleEnum = "MANAGE_INVITES"
)

var AllRoleEnum = []RoleEnum{
	RoleEnumRead,
	RoleEnumVote,
	RoleEnumEdit,
	RoleEnumModify,
	RoleEnumAdmin,
	RoleEnumInvite,
	RoleEnumManageInvites,
}

func (e RoleEnum) IsValid() bool {
	switch e {
	case RoleEnumRead, RoleEnumVote, RoleEnumEdit, RoleEnumModify, RoleEnumAdmin, RoleEnumInvite, RoleEnumManageInvites:
		return true
	}
	return false
}

func (e RoleEnum) String() string {
	return string(e)
}

func (e *RoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleEnum", str)
	}
	return nil
}

func (e RoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagGroupEnum string

const (
	TagGroupEnumPeople TagGroupEnum = "PEOPLE"
	TagGroupEnumScene  TagGroupEnum = "SCENE"
	TagGroupEnumAction TagGroupEnum = "ACTION"
)

var AllTagGroupEnum = []TagGroupEnum{
	TagGroupEnumPeople,
	TagGroupEnumScene,
	TagGroupEnumAction,
}

func (e TagGroupEnum) IsValid() bool {
	switch e {
	case TagGroupEnumPeople, TagGroupEnumScene, TagGroupEnumAction:
		return true
	}
	return false
}

func (e TagGroupEnum) String() string {
	return string(e)
}

func (e *TagGroupEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagGroupEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagGroupEnum", str)
	}
	return nil
}

func (e TagGroupEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TargetTypeEnum string

const (
	TargetTypeEnumScene     TargetTypeEnum = "SCENE"
	TargetTypeEnumStudio    TargetTypeEnum = "STUDIO"
	TargetTypeEnumPerformer TargetTypeEnum = "PERFORMER"
	TargetTypeEnumTag       TargetTypeEnum = "TAG"
)

var AllTargetTypeEnum = []TargetTypeEnum{
	TargetTypeEnumScene,
	TargetTypeEnumStudio,
	TargetTypeEnumPerformer,
	TargetTypeEnumTag,
}

func (e TargetTypeEnum) IsValid() bool {
	switch e {
	case TargetTypeEnumScene, TargetTypeEnumStudio, TargetTypeEnumPerformer, TargetTypeEnumTag:
		return true
	}
	return false
}

func (e TargetTypeEnum) String() string {
	return string(e)
}

func (e *TargetTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TargetTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TargetTypeEnum", str)
	}
	return nil
}

func (e TargetTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteStatusEnum string

const (
	VoteStatusEnumAccepted          VoteStatusEnum = "ACCEPTED"
	VoteStatusEnumRejected          VoteStatusEnum = "REJECTED"
	VoteStatusEnumPending           VoteStatusEnum = "PENDING"
	VoteStatusEnumImmediateAccepted VoteStatusEnum = "IMMEDIATE_ACCEPTED"
	VoteStatusEnumImmediateRejected VoteStatusEnum = "IMMEDIATE_REJECTED"
)

var AllVoteStatusEnum = []VoteStatusEnum{
	VoteStatusEnumAccepted,
	VoteStatusEnumRejected,
	VoteStatusEnumPending,
	VoteStatusEnumImmediateAccepted,
	VoteStatusEnumImmediateRejected,
}

func (e VoteStatusEnum) IsValid() bool {
	switch e {
	case VoteStatusEnumAccepted, VoteStatusEnumRejected, VoteStatusEnumPending, VoteStatusEnumImmediateAccepted, VoteStatusEnumImmediateRejected:
		return true
	}
	return false
}

func (e VoteStatusEnum) String() string {
	return string(e)
}

func (e *VoteStatusEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteStatusEnum", str)
	}
	return nil
}

func (e VoteStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VoteTypeEnum string

const (
	VoteTypeEnumComment VoteTypeEnum = "COMMENT"
	VoteTypeEnumAccept  VoteTypeEnum = "ACCEPT"
	VoteTypeEnumReject  VoteTypeEnum = "REJECT"
	// Immediately accepts the edit - bypassing the vote
	VoteTypeEnumImmediateAccept VoteTypeEnum = "IMMEDIATE_ACCEPT"
	// Immediately rejects the edit - bypassing the vote
	VoteTypeEnumImmediateReject VoteTypeEnum = "IMMEDIATE_REJECT"
)

var AllVoteTypeEnum = []VoteTypeEnum{
	VoteTypeEnumComment,
	VoteTypeEnumAccept,
	VoteTypeEnumReject,
	VoteTypeEnumImmediateAccept,
	VoteTypeEnumImmediateReject,
}

func (e VoteTypeEnum) IsValid() bool {
	switch e {
	case VoteTypeEnumComment, VoteTypeEnumAccept, VoteTypeEnumReject, VoteTypeEnumImmediateAccept, VoteTypeEnumImmediateReject:
		return true
	}
	return false
}

func (e VoteTypeEnum) String() string {
	return string(e)
}

func (e *VoteTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VoteTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VoteTypeEnum", str)
	}
	return nil
}

func (e VoteTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
