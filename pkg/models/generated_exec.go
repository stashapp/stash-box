// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/gofrs/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Draft() DraftResolver
	Edit() EditResolver
	EditComment() EditCommentResolver
	EditVote() EditVoteResolver
	Image() ImageResolver
	Mutation() MutationResolver
	Notification() NotificationResolver
	Performer() PerformerResolver
	PerformerDraft() PerformerDraftResolver
	PerformerEdit() PerformerEditResolver
	Query() QueryResolver
	QueryEditsResultType() QueryEditsResultTypeResolver
	QueryExistingPerformerResult() QueryExistingPerformerResultResolver
	QueryExistingSceneResult() QueryExistingSceneResultResolver
	QueryNotificationsResult() QueryNotificationsResultResolver
	QueryPerformersResultType() QueryPerformersResultTypeResolver
	QueryScenesResultType() QueryScenesResultTypeResolver
	Scene() SceneResolver
	SceneDraft() SceneDraftResolver
	SceneEdit() SceneEditResolver
	Site() SiteResolver
	Studio() StudioResolver
	StudioEdit() StudioEditResolver
	Tag() TagResolver
	TagCategory() TagCategoryResolver
	TagEdit() TagEditResolver
	URL() URLResolver
	User() UserResolver
}

type DirectiveRoot struct {
	HasRole     func(ctx context.Context, obj interface{}, next graphql.Resolver, role RoleEnum) (res interface{}, err error)
	IsUserOwner func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	BodyModification struct {
		Description func(childComplexity int) int
		Location    func(childComplexity int) int
	}

	CommentCommentedEdit struct {
		Comment func(childComplexity int) int
	}

	CommentOwnEdit struct {
		Comment func(childComplexity int) int
	}

	CommentVotedEdit struct {
		Comment func(childComplexity int) int
	}

	DownvoteOwnEdit struct {
		Edit func(childComplexity int) int
	}

	Draft struct {
		Created func(childComplexity int) int
		Data    func(childComplexity int) int
		Expires func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	DraftEntity struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	DraftFingerprint struct {
		Algorithm func(childComplexity int) int
		Duration  func(childComplexity int) int
		Hash      func(childComplexity int) int
	}

	DraftSubmissionStatus struct {
		ID func(childComplexity int) int
	}

	Edit struct {
		Applied      func(childComplexity int) int
		Bot          func(childComplexity int) int
		Closed       func(childComplexity int) int
		Comments     func(childComplexity int) int
		Created      func(childComplexity int) int
		Destructive  func(childComplexity int) int
		Details      func(childComplexity int) int
		Expires      func(childComplexity int) int
		ID           func(childComplexity int) int
		MergeSources func(childComplexity int) int
		OldDetails   func(childComplexity int) int
		Operation    func(childComplexity int) int
		Options      func(childComplexity int) int
		Status       func(childComplexity int) int
		Target       func(childComplexity int) int
		TargetType   func(childComplexity int) int
		Updatable    func(childComplexity int) int
		UpdateCount  func(childComplexity int) int
		Updated      func(childComplexity int) int
		User         func(childComplexity int) int
		VoteCount    func(childComplexity int) int
		Votes        func(childComplexity int) int
	}

	EditComment struct {
		Comment func(childComplexity int) int
		Date    func(childComplexity int) int
		Edit    func(childComplexity int) int
		ID      func(childComplexity int) int
		User    func(childComplexity int) int
	}

	EditVote struct {
		Date func(childComplexity int) int
		User func(childComplexity int) int
		Vote func(childComplexity int) int
	}

	FailedOwnEdit struct {
		Edit func(childComplexity int) int
	}

	FavoritePerformerEdit struct {
		Edit func(childComplexity int) int
	}

	FavoritePerformerScene struct {
		Scene func(childComplexity int) int
	}

	FavoriteStudioEdit struct {
		Edit func(childComplexity int) int
	}

	FavoriteStudioScene struct {
		Scene func(childComplexity int) int
	}

	Fingerprint struct {
		Algorithm     func(childComplexity int) int
		Created       func(childComplexity int) int
		Duration      func(childComplexity int) int
		Hash          func(childComplexity int) int
		Reports       func(childComplexity int) int
		Submissions   func(childComplexity int) int
		Updated       func(childComplexity int) int
		UserReported  func(childComplexity int) int
		UserSubmitted func(childComplexity int) int
	}

	FuzzyDate struct {
		Accuracy func(childComplexity int) int
		Date     func(childComplexity int) int
	}

	Image struct {
		Height func(childComplexity int) int
		ID     func(childComplexity int) int
		URL    func(childComplexity int) int
		Width  func(childComplexity int) int
	}

	InviteKey struct {
		Expires func(childComplexity int) int
		ID      func(childComplexity int) int
		Uses    func(childComplexity int) int
	}

	Measurements struct {
		BandSize func(childComplexity int) int
		CupSize  func(childComplexity int) int
		Hip      func(childComplexity int) int
		Waist    func(childComplexity int) int
	}

	Mutation struct {
		ActivateNewUser                 func(childComplexity int, input ActivateNewUserInput) int
		ApplyEdit                       func(childComplexity int, input ApplyEditInput) int
		CancelEdit                      func(childComplexity int, input CancelEditInput) int
		ChangePassword                  func(childComplexity int, input UserChangePasswordInput) int
		ConfirmChangeEmail              func(childComplexity int, token uuid.UUID) int
		DestroyDraft                    func(childComplexity int, id uuid.UUID) int
		EditComment                     func(childComplexity int, input EditCommentInput) int
		EditVote                        func(childComplexity int, input EditVoteInput) int
		FavoritePerformer               func(childComplexity int, id uuid.UUID, favorite bool) int
		FavoriteStudio                  func(childComplexity int, id uuid.UUID, favorite bool) int
		GenerateInviteCode              func(childComplexity int) int
		GenerateInviteCodes             func(childComplexity int, input *GenerateInviteCodeInput) int
		GrantInvite                     func(childComplexity int, input GrantInviteInput) int
		ImageCreate                     func(childComplexity int, input ImageCreateInput) int
		ImageDestroy                    func(childComplexity int, input ImageDestroyInput) int
		MarkNotificationsRead           func(childComplexity int) int
		NewUser                         func(childComplexity int, input NewUserInput) int
		PerformerCreate                 func(childComplexity int, input PerformerCreateInput) int
		PerformerDestroy                func(childComplexity int, input PerformerDestroyInput) int
		PerformerEdit                   func(childComplexity int, input PerformerEditInput) int
		PerformerEditUpdate             func(childComplexity int, id uuid.UUID, input PerformerEditInput) int
		PerformerUpdate                 func(childComplexity int, input PerformerUpdateInput) int
		RegenerateAPIKey                func(childComplexity int, userID *uuid.UUID) int
		RequestChangeEmail              func(childComplexity int) int
		RescindInviteCode               func(childComplexity int, code uuid.UUID) int
		ResetPassword                   func(childComplexity int, input ResetPasswordInput) int
		RevokeInvite                    func(childComplexity int, input RevokeInviteInput) int
		SceneCreate                     func(childComplexity int, input SceneCreateInput) int
		SceneDestroy                    func(childComplexity int, input SceneDestroyInput) int
		SceneEdit                       func(childComplexity int, input SceneEditInput) int
		SceneEditUpdate                 func(childComplexity int, id uuid.UUID, input SceneEditInput) int
		SceneUpdate                     func(childComplexity int, input SceneUpdateInput) int
		SiteCreate                      func(childComplexity int, input SiteCreateInput) int
		SiteDestroy                     func(childComplexity int, input SiteDestroyInput) int
		SiteUpdate                      func(childComplexity int, input SiteUpdateInput) int
		StudioCreate                    func(childComplexity int, input StudioCreateInput) int
		StudioDestroy                   func(childComplexity int, input StudioDestroyInput) int
		StudioEdit                      func(childComplexity int, input StudioEditInput) int
		StudioEditUpdate                func(childComplexity int, id uuid.UUID, input StudioEditInput) int
		StudioUpdate                    func(childComplexity int, input StudioUpdateInput) int
		SubmitFingerprint               func(childComplexity int, input FingerprintSubmission) int
		SubmitPerformerDraft            func(childComplexity int, input PerformerDraftInput) int
		SubmitSceneDraft                func(childComplexity int, input SceneDraftInput) int
		TagCategoryCreate               func(childComplexity int, input TagCategoryCreateInput) int
		TagCategoryDestroy              func(childComplexity int, input TagCategoryDestroyInput) int
		TagCategoryUpdate               func(childComplexity int, input TagCategoryUpdateInput) int
		TagCreate                       func(childComplexity int, input TagCreateInput) int
		TagDestroy                      func(childComplexity int, input TagDestroyInput) int
		TagEdit                         func(childComplexity int, input TagEditInput) int
		TagEditUpdate                   func(childComplexity int, id uuid.UUID, input TagEditInput) int
		TagUpdate                       func(childComplexity int, input TagUpdateInput) int
		UpdateNotificationSubscriptions func(childComplexity int, subscriptions []NotificationEnum) int
		UserCreate                      func(childComplexity int, input UserCreateInput) int
		UserDestroy                     func(childComplexity int, input UserDestroyInput) int
		UserUpdate                      func(childComplexity int, input UserUpdateInput) int
		ValidateChangeEmail             func(childComplexity int, token uuid.UUID, email string) int
	}

	Notification struct {
		Created func(childComplexity int) int
		Data    func(childComplexity int) int
		Read    func(childComplexity int) int
	}

	Performer struct {
		Age             func(childComplexity int) int
		Aliases         func(childComplexity int) int
		BandSize        func(childComplexity int) int
		BirthDate       func(childComplexity int) int
		Birthdate       func(childComplexity int) int
		BreastType      func(childComplexity int) int
		CareerEndYear   func(childComplexity int) int
		CareerStartYear func(childComplexity int) int
		Country         func(childComplexity int) int
		Created         func(childComplexity int) int
		CupSize         func(childComplexity int) int
		DeathDate       func(childComplexity int) int
		Deleted         func(childComplexity int) int
		Disambiguation  func(childComplexity int) int
		Edits           func(childComplexity int) int
		Ethnicity       func(childComplexity int) int
		EyeColor        func(childComplexity int) int
		Gender          func(childComplexity int) int
		HairColor       func(childComplexity int) int
		Height          func(childComplexity int) int
		HipSize         func(childComplexity int) int
		ID              func(childComplexity int) int
		Images          func(childComplexity int) int
		IsFavorite      func(childComplexity int) int
		Measurements    func(childComplexity int) int
		MergedIds       func(childComplexity int) int
		MergedIntoID    func(childComplexity int) int
		Name            func(childComplexity int) int
		Piercings       func(childComplexity int) int
		SceneCount      func(childComplexity int) int
		Scenes          func(childComplexity int, input *PerformerScenesInput) int
		Studios         func(childComplexity int) int
		Tattoos         func(childComplexity int) int
		Updated         func(childComplexity int) int
		Urls            func(childComplexity int) int
		WaistSize       func(childComplexity int) int
	}

	PerformerAppearance struct {
		As        func(childComplexity int) int
		Performer func(childComplexity int) int
	}

	PerformerDraft struct {
		Aliases         func(childComplexity int) int
		Birthdate       func(childComplexity int) int
		BreastType      func(childComplexity int) int
		CareerEndYear   func(childComplexity int) int
		CareerStartYear func(childComplexity int) int
		Country         func(childComplexity int) int
		Deathdate       func(childComplexity int) int
		Disambiguation  func(childComplexity int) int
		Ethnicity       func(childComplexity int) int
		EyeColor        func(childComplexity int) int
		Gender          func(childComplexity int) int
		HairColor       func(childComplexity int) int
		Height          func(childComplexity int) int
		ID              func(childComplexity int) int
		Image           func(childComplexity int) int
		Measurements    func(childComplexity int) int
		Name            func(childComplexity int) int
		Piercings       func(childComplexity int) int
		Tattoos         func(childComplexity int) int
		Urls            func(childComplexity int) int
	}

	PerformerEdit struct {
		AddedAliases     func(childComplexity int) int
		AddedImages      func(childComplexity int) int
		AddedPiercings   func(childComplexity int) int
		AddedTattoos     func(childComplexity int) int
		AddedUrls        func(childComplexity int) int
		Aliases          func(childComplexity int) int
		BandSize         func(childComplexity int) int
		Birthdate        func(childComplexity int) int
		BreastType       func(childComplexity int) int
		CareerEndYear    func(childComplexity int) int
		CareerStartYear  func(childComplexity int) int
		Country          func(childComplexity int) int
		CupSize          func(childComplexity int) int
		Deathdate        func(childComplexity int) int
		Disambiguation   func(childComplexity int) int
		DraftID          func(childComplexity int) int
		Ethnicity        func(childComplexity int) int
		EyeColor         func(childComplexity int) int
		Gender           func(childComplexity int) int
		HairColor        func(childComplexity int) int
		Height           func(childComplexity int) int
		HipSize          func(childComplexity int) int
		Images           func(childComplexity int) int
		Name             func(childComplexity int) int
		Piercings        func(childComplexity int) int
		RemovedAliases   func(childComplexity int) int
		RemovedImages    func(childComplexity int) int
		RemovedPiercings func(childComplexity int) int
		RemovedTattoos   func(childComplexity int) int
		RemovedUrls      func(childComplexity int) int
		Tattoos          func(childComplexity int) int
		Urls             func(childComplexity int) int
		WaistSize        func(childComplexity int) int
	}

	PerformerEditOptions struct {
		SetMergeAliases  func(childComplexity int) int
		SetModifyAliases func(childComplexity int) int
	}

	PerformerStudio struct {
		SceneCount func(childComplexity int) int
		Studio     func(childComplexity int) int
	}

	Query struct {
		FindDraft                     func(childComplexity int, id uuid.UUID) int
		FindDrafts                    func(childComplexity int) int
		FindEdit                      func(childComplexity int, id uuid.UUID) int
		FindPerformer                 func(childComplexity int, id uuid.UUID) int
		FindScene                     func(childComplexity int, id uuid.UUID) int
		FindSceneByFingerprint        func(childComplexity int, fingerprint FingerprintQueryInput) int
		FindScenesByFingerprints      func(childComplexity int, fingerprints []string) int
		FindScenesByFullFingerprints  func(childComplexity int, fingerprints []*FingerprintQueryInput) int
		FindScenesBySceneFingerprints func(childComplexity int, fingerprints [][]*FingerprintQueryInput) int
		FindSite                      func(childComplexity int, id uuid.UUID) int
		FindStudio                    func(childComplexity int, id *uuid.UUID, name *string) int
		FindTag                       func(childComplexity int, id *uuid.UUID, name *string) int
		FindTagCategory               func(childComplexity int, id uuid.UUID) int
		FindTagOrAlias                func(childComplexity int, name string) int
		FindUser                      func(childComplexity int, id *uuid.UUID, username *string) int
		GetConfig                     func(childComplexity int) int
		GetUnreadNotificationCount    func(childComplexity int) int
		Me                            func(childComplexity int) int
		QueryEdits                    func(childComplexity int, input EditQueryInput) int
		QueryExistingPerformer        func(childComplexity int, input QueryExistingPerformerInput) int
		QueryExistingScene            func(childComplexity int, input QueryExistingSceneInput) int
		QueryNotifications            func(childComplexity int, input QueryNotificationsInput) int
		QueryPerformers               func(childComplexity int, input PerformerQueryInput) int
		QueryScenes                   func(childComplexity int, input SceneQueryInput) int
		QuerySites                    func(childComplexity int) int
		QueryStudios                  func(childComplexity int, input StudioQueryInput) int
		QueryTagCategories            func(childComplexity int) int
		QueryTags                     func(childComplexity int, input TagQueryInput) int
		QueryUsers                    func(childComplexity int, input UserQueryInput) int
		SearchPerformer               func(childComplexity int, term string, limit *int) int
		SearchScene                   func(childComplexity int, term string, limit *int) int
		SearchStudio                  func(childComplexity int, term string, limit *int) int
		SearchTag                     func(childComplexity int, term string, limit *int) int
		Version                       func(childComplexity int) int
	}

	QueryEditsResultType struct {
		Count func(childComplexity int) int
		Edits func(childComplexity int) int
	}

	QueryExistingPerformerResult struct {
		Edits      func(childComplexity int) int
		Performers func(childComplexity int) int
	}

	QueryExistingSceneResult struct {
		Edits  func(childComplexity int) int
		Scenes func(childComplexity int) int
	}

	QueryNotificationsResult struct {
		Count         func(childComplexity int) int
		Notifications func(childComplexity int) int
	}

	QueryPerformersResultType struct {
		Count      func(childComplexity int) int
		Performers func(childComplexity int) int
	}

	QueryScenesResultType struct {
		Count  func(childComplexity int) int
		Scenes func(childComplexity int) int
	}

	QuerySitesResultType struct {
		Count func(childComplexity int) int
		Sites func(childComplexity int) int
	}

	QueryStudiosResultType struct {
		Count   func(childComplexity int) int
		Studios func(childComplexity int) int
	}

	QueryTagCategoriesResultType struct {
		Count         func(childComplexity int) int
		TagCategories func(childComplexity int) int
	}

	QueryTagsResultType struct {
		Count func(childComplexity int) int
		Tags  func(childComplexity int) int
	}

	QueryUsersResultType struct {
		Count func(childComplexity int) int
		Users func(childComplexity int) int
	}

	Scene struct {
		Code           func(childComplexity int) int
		Created        func(childComplexity int) int
		Date           func(childComplexity int) int
		Deleted        func(childComplexity int) int
		Details        func(childComplexity int) int
		Director       func(childComplexity int) int
		Duration       func(childComplexity int) int
		Edits          func(childComplexity int) int
		Fingerprints   func(childComplexity int, isSubmitted *bool) int
		ID             func(childComplexity int) int
		Images         func(childComplexity int) int
		Performers     func(childComplexity int) int
		ProductionDate func(childComplexity int) int
		ReleaseDate    func(childComplexity int) int
		Studio         func(childComplexity int) int
		Tags           func(childComplexity int) int
		Title          func(childComplexity int) int
		Updated        func(childComplexity int) int
		Urls           func(childComplexity int) int
	}

	SceneDraft struct {
		Code           func(childComplexity int) int
		Date           func(childComplexity int) int
		Details        func(childComplexity int) int
		Director       func(childComplexity int) int
		Fingerprints   func(childComplexity int) int
		ID             func(childComplexity int) int
		Image          func(childComplexity int) int
		Performers     func(childComplexity int) int
		ProductionDate func(childComplexity int) int
		Studio         func(childComplexity int) int
		Tags           func(childComplexity int) int
		Title          func(childComplexity int) int
		URLs           func(childComplexity int) int
	}

	SceneEdit struct {
		AddedFingerprints   func(childComplexity int) int
		AddedImages         func(childComplexity int) int
		AddedPerformers     func(childComplexity int) int
		AddedTags           func(childComplexity int) int
		AddedUrls           func(childComplexity int) int
		Code                func(childComplexity int) int
		Date                func(childComplexity int) int
		Details             func(childComplexity int) int
		Director            func(childComplexity int) int
		DraftID             func(childComplexity int) int
		Duration            func(childComplexity int) int
		Fingerprints        func(childComplexity int) int
		Images              func(childComplexity int) int
		Performers          func(childComplexity int) int
		ProductionDate      func(childComplexity int) int
		RemovedFingerprints func(childComplexity int) int
		RemovedImages       func(childComplexity int) int
		RemovedPerformers   func(childComplexity int) int
		RemovedTags         func(childComplexity int) int
		RemovedUrls         func(childComplexity int) int
		Studio              func(childComplexity int) int
		Tags                func(childComplexity int) int
		Title               func(childComplexity int) int
		Urls                func(childComplexity int) int
	}

	Site struct {
		Created     func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Icon        func(childComplexity int) int
		Name        func(childComplexity int) int
		Regex       func(childComplexity int) int
		URL         func(childComplexity int) int
		Updated     func(childComplexity int) int
		ValidTypes  func(childComplexity int) int
	}

	StashBoxConfig struct {
		EditUpdateLimit            func(childComplexity int) int
		GuidelinesURL              func(childComplexity int) int
		HostURL                    func(childComplexity int) int
		MinDestructiveVotingPeriod func(childComplexity int) int
		RequireActivation          func(childComplexity int) int
		RequireInvite              func(childComplexity int) int
		RequireSceneDraft          func(childComplexity int) int
		VoteApplicationThreshold   func(childComplexity int) int
		VoteCronInterval           func(childComplexity int) int
		VotePromotionThreshold     func(childComplexity int) int
		VotingPeriod               func(childComplexity int) int
	}

	Studio struct {
		Aliases      func(childComplexity int) int
		ChildStudios func(childComplexity int) int
		Created      func(childComplexity int) int
		Deleted      func(childComplexity int) int
		ID           func(childComplexity int) int
		Images       func(childComplexity int) int
		IsFavorite   func(childComplexity int) int
		Name         func(childComplexity int) int
		Parent       func(childComplexity int) int
		Performers   func(childComplexity int, input PerformerQueryInput) int
		Updated      func(childComplexity int) int
		Urls         func(childComplexity int) int
	}

	StudioEdit struct {
		AddedAliases   func(childComplexity int) int
		AddedImages    func(childComplexity int) int
		AddedUrls      func(childComplexity int) int
		Images         func(childComplexity int) int
		Name           func(childComplexity int) int
		Parent         func(childComplexity int) int
		RemovedAliases func(childComplexity int) int
		RemovedImages  func(childComplexity int) int
		RemovedUrls    func(childComplexity int) int
		Urls           func(childComplexity int) int
	}

	Tag struct {
		Aliases     func(childComplexity int) int
		Category    func(childComplexity int) int
		Created     func(childComplexity int) int
		Deleted     func(childComplexity int) int
		Description func(childComplexity int) int
		Edits       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Updated     func(childComplexity int) int
	}

	TagCategory struct {
		Description func(childComplexity int) int
		Group       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	TagEdit struct {
		AddedAliases   func(childComplexity int) int
		Aliases        func(childComplexity int) int
		Category       func(childComplexity int) int
		Description    func(childComplexity int) int
		Name           func(childComplexity int) int
		RemovedAliases func(childComplexity int) int
	}

	URL struct {
		Site func(childComplexity int) int
		Type func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	UpdatedEdit struct {
		Edit func(childComplexity int) int
	}

	User struct {
		APICalls                  func(childComplexity int) int
		APIKey                    func(childComplexity int) int
		ActiveInviteCodes         func(childComplexity int) int
		EditCount                 func(childComplexity int) int
		Email                     func(childComplexity int) int
		ID                        func(childComplexity int) int
		InviteCodes               func(childComplexity int) int
		InviteTokens              func(childComplexity int) int
		InvitedBy                 func(childComplexity int) int
		Name                      func(childComplexity int) int
		NotificationSubscriptions func(childComplexity int) int
		Roles                     func(childComplexity int) int
		VoteCount                 func(childComplexity int) int
	}

	UserEditCount struct {
		Accepted          func(childComplexity int) int
		Canceled          func(childComplexity int) int
		Failed            func(childComplexity int) int
		ImmediateAccepted func(childComplexity int) int
		ImmediateRejected func(childComplexity int) int
		Pending           func(childComplexity int) int
		Rejected          func(childComplexity int) int
	}

	UserVoteCount struct {
		Abstain         func(childComplexity int) int
		Accept          func(childComplexity int) int
		ImmediateAccept func(childComplexity int) int
		ImmediateReject func(childComplexity int) int
		Reject          func(childComplexity int) int
	}

	Version struct {
		BuildTime func(childComplexity int) int
		BuildType func(childComplexity int) int
		Hash      func(childComplexity int) int
		Version   func(childComplexity int) int
	}
}

type DraftResolver interface {
	Created(ctx context.Context, obj *Draft) (*time.Time, error)
	Expires(ctx context.Context, obj *Draft) (*time.Time, error)
	Data(ctx context.Context, obj *Draft) (DraftData, error)
}
type EditResolver interface {
	User(ctx context.Context, obj *Edit) (*User, error)
	Target(ctx context.Context, obj *Edit) (EditTarget, error)
	TargetType(ctx context.Context, obj *Edit) (TargetTypeEnum, error)
	MergeSources(ctx context.Context, obj *Edit) ([]EditTarget, error)
	Operation(ctx context.Context, obj *Edit) (OperationEnum, error)

	Details(ctx context.Context, obj *Edit) (EditDetails, error)
	OldDetails(ctx context.Context, obj *Edit) (EditDetails, error)
	Options(ctx context.Context, obj *Edit) (*PerformerEditOptions, error)
	Comments(ctx context.Context, obj *Edit) ([]*EditComment, error)
	Votes(ctx context.Context, obj *Edit) ([]*EditVote, error)

	Destructive(ctx context.Context, obj *Edit) (bool, error)
	Status(ctx context.Context, obj *Edit) (VoteStatusEnum, error)

	Updatable(ctx context.Context, obj *Edit) (bool, error)
	Created(ctx context.Context, obj *Edit) (*time.Time, error)
	Updated(ctx context.Context, obj *Edit) (*time.Time, error)
	Closed(ctx context.Context, obj *Edit) (*time.Time, error)
	Expires(ctx context.Context, obj *Edit) (*time.Time, error)
}
type EditCommentResolver interface {
	User(ctx context.Context, obj *EditComment) (*User, error)
	Date(ctx context.Context, obj *EditComment) (*time.Time, error)
	Comment(ctx context.Context, obj *EditComment) (string, error)
	Edit(ctx context.Context, obj *EditComment) (*Edit, error)
}
type EditVoteResolver interface {
	User(ctx context.Context, obj *EditVote) (*User, error)
	Date(ctx context.Context, obj *EditVote) (*time.Time, error)
	Vote(ctx context.Context, obj *EditVote) (VoteTypeEnum, error)
}
type ImageResolver interface {
	URL(ctx context.Context, obj *Image) (string, error)
}
type MutationResolver interface {
	SceneCreate(ctx context.Context, input SceneCreateInput) (*Scene, error)
	SceneUpdate(ctx context.Context, input SceneUpdateInput) (*Scene, error)
	SceneDestroy(ctx context.Context, input SceneDestroyInput) (bool, error)
	PerformerCreate(ctx context.Context, input PerformerCreateInput) (*Performer, error)
	PerformerUpdate(ctx context.Context, input PerformerUpdateInput) (*Performer, error)
	PerformerDestroy(ctx context.Context, input PerformerDestroyInput) (bool, error)
	StudioCreate(ctx context.Context, input StudioCreateInput) (*Studio, error)
	StudioUpdate(ctx context.Context, input StudioUpdateInput) (*Studio, error)
	StudioDestroy(ctx context.Context, input StudioDestroyInput) (bool, error)
	TagCreate(ctx context.Context, input TagCreateInput) (*Tag, error)
	TagUpdate(ctx context.Context, input TagUpdateInput) (*Tag, error)
	TagDestroy(ctx context.Context, input TagDestroyInput) (bool, error)
	UserCreate(ctx context.Context, input UserCreateInput) (*User, error)
	UserUpdate(ctx context.Context, input UserUpdateInput) (*User, error)
	UserDestroy(ctx context.Context, input UserDestroyInput) (bool, error)
	ImageCreate(ctx context.Context, input ImageCreateInput) (*Image, error)
	ImageDestroy(ctx context.Context, input ImageDestroyInput) (bool, error)
	NewUser(ctx context.Context, input NewUserInput) (*uuid.UUID, error)
	ActivateNewUser(ctx context.Context, input ActivateNewUserInput) (*User, error)
	GenerateInviteCode(ctx context.Context) (*uuid.UUID, error)
	GenerateInviteCodes(ctx context.Context, input *GenerateInviteCodeInput) ([]uuid.UUID, error)
	RescindInviteCode(ctx context.Context, code uuid.UUID) (bool, error)
	GrantInvite(ctx context.Context, input GrantInviteInput) (int, error)
	RevokeInvite(ctx context.Context, input RevokeInviteInput) (int, error)
	TagCategoryCreate(ctx context.Context, input TagCategoryCreateInput) (*TagCategory, error)
	TagCategoryUpdate(ctx context.Context, input TagCategoryUpdateInput) (*TagCategory, error)
	TagCategoryDestroy(ctx context.Context, input TagCategoryDestroyInput) (bool, error)
	SiteCreate(ctx context.Context, input SiteCreateInput) (*Site, error)
	SiteUpdate(ctx context.Context, input SiteUpdateInput) (*Site, error)
	SiteDestroy(ctx context.Context, input SiteDestroyInput) (bool, error)
	RegenerateAPIKey(ctx context.Context, userID *uuid.UUID) (string, error)
	ResetPassword(ctx context.Context, input ResetPasswordInput) (bool, error)
	ChangePassword(ctx context.Context, input UserChangePasswordInput) (bool, error)
	RequestChangeEmail(ctx context.Context) (UserChangeEmailStatus, error)
	ValidateChangeEmail(ctx context.Context, token uuid.UUID, email string) (UserChangeEmailStatus, error)
	ConfirmChangeEmail(ctx context.Context, token uuid.UUID) (UserChangeEmailStatus, error)
	SceneEdit(ctx context.Context, input SceneEditInput) (*Edit, error)
	PerformerEdit(ctx context.Context, input PerformerEditInput) (*Edit, error)
	StudioEdit(ctx context.Context, input StudioEditInput) (*Edit, error)
	TagEdit(ctx context.Context, input TagEditInput) (*Edit, error)
	SceneEditUpdate(ctx context.Context, id uuid.UUID, input SceneEditInput) (*Edit, error)
	PerformerEditUpdate(ctx context.Context, id uuid.UUID, input PerformerEditInput) (*Edit, error)
	StudioEditUpdate(ctx context.Context, id uuid.UUID, input StudioEditInput) (*Edit, error)
	TagEditUpdate(ctx context.Context, id uuid.UUID, input TagEditInput) (*Edit, error)
	EditVote(ctx context.Context, input EditVoteInput) (*Edit, error)
	EditComment(ctx context.Context, input EditCommentInput) (*Edit, error)
	ApplyEdit(ctx context.Context, input ApplyEditInput) (*Edit, error)
	CancelEdit(ctx context.Context, input CancelEditInput) (*Edit, error)
	SubmitFingerprint(ctx context.Context, input FingerprintSubmission) (bool, error)
	SubmitSceneDraft(ctx context.Context, input SceneDraftInput) (*DraftSubmissionStatus, error)
	SubmitPerformerDraft(ctx context.Context, input PerformerDraftInput) (*DraftSubmissionStatus, error)
	DestroyDraft(ctx context.Context, id uuid.UUID) (bool, error)
	FavoritePerformer(ctx context.Context, id uuid.UUID, favorite bool) (bool, error)
	FavoriteStudio(ctx context.Context, id uuid.UUID, favorite bool) (bool, error)
	MarkNotificationsRead(ctx context.Context) (bool, error)
	UpdateNotificationSubscriptions(ctx context.Context, subscriptions []NotificationEnum) (bool, error)
}
type NotificationResolver interface {
	Created(ctx context.Context, obj *Notification) (*time.Time, error)
	Read(ctx context.Context, obj *Notification) (bool, error)
	Data(ctx context.Context, obj *Notification) (NotificationData, error)
}
type PerformerResolver interface {
	Disambiguation(ctx context.Context, obj *Performer) (*string, error)
	Aliases(ctx context.Context, obj *Performer) ([]string, error)
	Gender(ctx context.Context, obj *Performer) (*GenderEnum, error)
	Urls(ctx context.Context, obj *Performer) ([]*URL, error)
	Birthdate(ctx context.Context, obj *Performer) (*FuzzyDate, error)
	BirthDate(ctx context.Context, obj *Performer) (*string, error)
	DeathDate(ctx context.Context, obj *Performer) (*string, error)
	Age(ctx context.Context, obj *Performer) (*int, error)
	Ethnicity(ctx context.Context, obj *Performer) (*EthnicityEnum, error)
	Country(ctx context.Context, obj *Performer) (*string, error)
	EyeColor(ctx context.Context, obj *Performer) (*EyeColorEnum, error)
	HairColor(ctx context.Context, obj *Performer) (*HairColorEnum, error)
	Height(ctx context.Context, obj *Performer) (*int, error)
	Measurements(ctx context.Context, obj *Performer) (*Measurements, error)
	CupSize(ctx context.Context, obj *Performer) (*string, error)
	BandSize(ctx context.Context, obj *Performer) (*int, error)
	WaistSize(ctx context.Context, obj *Performer) (*int, error)
	HipSize(ctx context.Context, obj *Performer) (*int, error)
	BreastType(ctx context.Context, obj *Performer) (*BreastTypeEnum, error)
	CareerStartYear(ctx context.Context, obj *Performer) (*int, error)
	CareerEndYear(ctx context.Context, obj *Performer) (*int, error)
	Tattoos(ctx context.Context, obj *Performer) ([]*BodyModification, error)
	Piercings(ctx context.Context, obj *Performer) ([]*BodyModification, error)
	Images(ctx context.Context, obj *Performer) ([]*Image, error)

	Edits(ctx context.Context, obj *Performer) ([]*Edit, error)
	SceneCount(ctx context.Context, obj *Performer) (int, error)
	Scenes(ctx context.Context, obj *Performer, input *PerformerScenesInput) ([]*Scene, error)
	MergedIds(ctx context.Context, obj *Performer) ([]uuid.UUID, error)
	MergedIntoID(ctx context.Context, obj *Performer) (*uuid.UUID, error)
	Studios(ctx context.Context, obj *Performer) ([]*PerformerStudio, error)
	IsFavorite(ctx context.Context, obj *Performer) (bool, error)
	Created(ctx context.Context, obj *Performer) (*time.Time, error)
	Updated(ctx context.Context, obj *Performer) (*time.Time, error)
}
type PerformerDraftResolver interface {
	Image(ctx context.Context, obj *PerformerDraft) (*Image, error)
}
type PerformerEditResolver interface {
	Gender(ctx context.Context, obj *PerformerEdit) (*GenderEnum, error)

	Ethnicity(ctx context.Context, obj *PerformerEdit) (*EthnicityEnum, error)

	EyeColor(ctx context.Context, obj *PerformerEdit) (*EyeColorEnum, error)
	HairColor(ctx context.Context, obj *PerformerEdit) (*HairColorEnum, error)

	BreastType(ctx context.Context, obj *PerformerEdit) (*BreastTypeEnum, error)

	AddedImages(ctx context.Context, obj *PerformerEdit) ([]*Image, error)
	RemovedImages(ctx context.Context, obj *PerformerEdit) ([]*Image, error)

	Aliases(ctx context.Context, obj *PerformerEdit) ([]string, error)
	Urls(ctx context.Context, obj *PerformerEdit) ([]*URL, error)
	Images(ctx context.Context, obj *PerformerEdit) ([]*Image, error)
	Tattoos(ctx context.Context, obj *PerformerEdit) ([]*BodyModification, error)
	Piercings(ctx context.Context, obj *PerformerEdit) ([]*BodyModification, error)
}
type QueryResolver interface {
	FindPerformer(ctx context.Context, id uuid.UUID) (*Performer, error)
	QueryPerformers(ctx context.Context, input PerformerQueryInput) (*PerformerQuery, error)
	FindStudio(ctx context.Context, id *uuid.UUID, name *string) (*Studio, error)
	QueryStudios(ctx context.Context, input StudioQueryInput) (*QueryStudiosResultType, error)
	FindTag(ctx context.Context, id *uuid.UUID, name *string) (*Tag, error)
	FindTagOrAlias(ctx context.Context, name string) (*Tag, error)
	QueryTags(ctx context.Context, input TagQueryInput) (*QueryTagsResultType, error)
	FindTagCategory(ctx context.Context, id uuid.UUID) (*TagCategory, error)
	QueryTagCategories(ctx context.Context) (*QueryTagCategoriesResultType, error)
	FindScene(ctx context.Context, id uuid.UUID) (*Scene, error)
	FindSceneByFingerprint(ctx context.Context, fingerprint FingerprintQueryInput) ([]*Scene, error)
	FindScenesByFingerprints(ctx context.Context, fingerprints []string) ([]*Scene, error)
	FindScenesByFullFingerprints(ctx context.Context, fingerprints []*FingerprintQueryInput) ([]*Scene, error)
	FindScenesBySceneFingerprints(ctx context.Context, fingerprints [][]*FingerprintQueryInput) ([][]*Scene, error)
	QueryScenes(ctx context.Context, input SceneQueryInput) (*SceneQuery, error)
	FindSite(ctx context.Context, id uuid.UUID) (*Site, error)
	QuerySites(ctx context.Context) (*QuerySitesResultType, error)
	FindEdit(ctx context.Context, id uuid.UUID) (*Edit, error)
	QueryEdits(ctx context.Context, input EditQueryInput) (*EditQuery, error)
	FindUser(ctx context.Context, id *uuid.UUID, username *string) (*User, error)
	QueryUsers(ctx context.Context, input UserQueryInput) (*QueryUsersResultType, error)
	Me(ctx context.Context) (*User, error)
	SearchPerformer(ctx context.Context, term string, limit *int) ([]*Performer, error)
	SearchScene(ctx context.Context, term string, limit *int) ([]*Scene, error)
	SearchTag(ctx context.Context, term string, limit *int) ([]*Tag, error)
	SearchStudio(ctx context.Context, term string, limit *int) ([]*Studio, error)
	FindDraft(ctx context.Context, id uuid.UUID) (*Draft, error)
	FindDrafts(ctx context.Context) ([]*Draft, error)
	QueryExistingScene(ctx context.Context, input QueryExistingSceneInput) (*QueryExistingSceneResult, error)
	QueryExistingPerformer(ctx context.Context, input QueryExistingPerformerInput) (*QueryExistingPerformerResult, error)
	Version(ctx context.Context) (*Version, error)
	GetConfig(ctx context.Context) (*StashBoxConfig, error)
	QueryNotifications(ctx context.Context, input QueryNotificationsInput) (*QueryNotificationsResult, error)
	GetUnreadNotificationCount(ctx context.Context) (int, error)
}
type QueryEditsResultTypeResolver interface {
	Count(ctx context.Context, obj *EditQuery) (int, error)
	Edits(ctx context.Context, obj *EditQuery) ([]*Edit, error)
}
type QueryExistingPerformerResultResolver interface {
	Edits(ctx context.Context, obj *QueryExistingPerformerResult) ([]*Edit, error)
	Performers(ctx context.Context, obj *QueryExistingPerformerResult) ([]*Performer, error)
}
type QueryExistingSceneResultResolver interface {
	Edits(ctx context.Context, obj *QueryExistingSceneResult) ([]*Edit, error)
	Scenes(ctx context.Context, obj *QueryExistingSceneResult) ([]*Scene, error)
}
type QueryNotificationsResultResolver interface {
	Count(ctx context.Context, obj *QueryNotificationsResult) (int, error)
	Notifications(ctx context.Context, obj *QueryNotificationsResult) ([]*Notification, error)
}
type QueryPerformersResultTypeResolver interface {
	Count(ctx context.Context, obj *PerformerQuery) (int, error)
	Performers(ctx context.Context, obj *PerformerQuery) ([]*Performer, error)
}
type QueryScenesResultTypeResolver interface {
	Count(ctx context.Context, obj *SceneQuery) (int, error)
	Scenes(ctx context.Context, obj *SceneQuery) ([]*Scene, error)
}
type SceneResolver interface {
	Title(ctx context.Context, obj *Scene) (*string, error)
	Details(ctx context.Context, obj *Scene) (*string, error)
	Date(ctx context.Context, obj *Scene) (*string, error)
	ReleaseDate(ctx context.Context, obj *Scene) (*string, error)
	ProductionDate(ctx context.Context, obj *Scene) (*string, error)
	Urls(ctx context.Context, obj *Scene) ([]*URL, error)
	Studio(ctx context.Context, obj *Scene) (*Studio, error)
	Tags(ctx context.Context, obj *Scene) ([]*Tag, error)
	Images(ctx context.Context, obj *Scene) ([]*Image, error)
	Performers(ctx context.Context, obj *Scene) ([]*PerformerAppearance, error)
	Fingerprints(ctx context.Context, obj *Scene, isSubmitted *bool) ([]*Fingerprint, error)
	Duration(ctx context.Context, obj *Scene) (*int, error)
	Director(ctx context.Context, obj *Scene) (*string, error)
	Code(ctx context.Context, obj *Scene) (*string, error)

	Edits(ctx context.Context, obj *Scene) ([]*Edit, error)
	Created(ctx context.Context, obj *Scene) (*time.Time, error)
	Updated(ctx context.Context, obj *Scene) (*time.Time, error)
}
type SceneDraftResolver interface {
	Studio(ctx context.Context, obj *SceneDraft) (SceneDraftStudio, error)
	Performers(ctx context.Context, obj *SceneDraft) ([]SceneDraftPerformer, error)
	Tags(ctx context.Context, obj *SceneDraft) ([]SceneDraftTag, error)
	Image(ctx context.Context, obj *SceneDraft) (*Image, error)
}
type SceneEditResolver interface {
	Studio(ctx context.Context, obj *SceneEdit) (*Studio, error)
	AddedPerformers(ctx context.Context, obj *SceneEdit) ([]*PerformerAppearance, error)
	RemovedPerformers(ctx context.Context, obj *SceneEdit) ([]*PerformerAppearance, error)
	AddedTags(ctx context.Context, obj *SceneEdit) ([]*Tag, error)
	RemovedTags(ctx context.Context, obj *SceneEdit) ([]*Tag, error)
	AddedImages(ctx context.Context, obj *SceneEdit) ([]*Image, error)
	RemovedImages(ctx context.Context, obj *SceneEdit) ([]*Image, error)
	AddedFingerprints(ctx context.Context, obj *SceneEdit) ([]*Fingerprint, error)
	RemovedFingerprints(ctx context.Context, obj *SceneEdit) ([]*Fingerprint, error)

	Urls(ctx context.Context, obj *SceneEdit) ([]*URL, error)
	Performers(ctx context.Context, obj *SceneEdit) ([]*PerformerAppearance, error)
	Tags(ctx context.Context, obj *SceneEdit) ([]*Tag, error)
	Images(ctx context.Context, obj *SceneEdit) ([]*Image, error)
	Fingerprints(ctx context.Context, obj *SceneEdit) ([]*Fingerprint, error)
}
type SiteResolver interface {
	Description(ctx context.Context, obj *Site) (*string, error)
	URL(ctx context.Context, obj *Site) (*string, error)
	Regex(ctx context.Context, obj *Site) (*string, error)
	ValidTypes(ctx context.Context, obj *Site) ([]ValidSiteTypeEnum, error)
	Icon(ctx context.Context, obj *Site) (string, error)
	Created(ctx context.Context, obj *Site) (*time.Time, error)
	Updated(ctx context.Context, obj *Site) (*time.Time, error)
}
type StudioResolver interface {
	Aliases(ctx context.Context, obj *Studio) ([]string, error)
	Urls(ctx context.Context, obj *Studio) ([]*URL, error)
	Parent(ctx context.Context, obj *Studio) (*Studio, error)
	ChildStudios(ctx context.Context, obj *Studio) ([]*Studio, error)
	Images(ctx context.Context, obj *Studio) ([]*Image, error)

	IsFavorite(ctx context.Context, obj *Studio) (bool, error)
	Created(ctx context.Context, obj *Studio) (*time.Time, error)
	Updated(ctx context.Context, obj *Studio) (*time.Time, error)
	Performers(ctx context.Context, obj *Studio, input PerformerQueryInput) (*PerformerQuery, error)
}
type StudioEditResolver interface {
	Parent(ctx context.Context, obj *StudioEdit) (*Studio, error)
	AddedImages(ctx context.Context, obj *StudioEdit) ([]*Image, error)
	RemovedImages(ctx context.Context, obj *StudioEdit) ([]*Image, error)

	Images(ctx context.Context, obj *StudioEdit) ([]*Image, error)
	Urls(ctx context.Context, obj *StudioEdit) ([]*URL, error)
}
type TagResolver interface {
	Description(ctx context.Context, obj *Tag) (*string, error)
	Aliases(ctx context.Context, obj *Tag) ([]string, error)

	Edits(ctx context.Context, obj *Tag) ([]*Edit, error)
	Category(ctx context.Context, obj *Tag) (*TagCategory, error)
	Created(ctx context.Context, obj *Tag) (*time.Time, error)
	Updated(ctx context.Context, obj *Tag) (*time.Time, error)
}
type TagCategoryResolver interface {
	Group(ctx context.Context, obj *TagCategory) (TagGroupEnum, error)
	Description(ctx context.Context, obj *TagCategory) (*string, error)
}
type TagEditResolver interface {
	Category(ctx context.Context, obj *TagEdit) (*TagCategory, error)
	Aliases(ctx context.Context, obj *TagEdit) ([]string, error)
}
type URLResolver interface {
	Type(ctx context.Context, obj *URL) (string, error)
	Site(ctx context.Context, obj *URL) (*Site, error)
}
type UserResolver interface {
	Roles(ctx context.Context, obj *User) ([]RoleEnum, error)

	NotificationSubscriptions(ctx context.Context, obj *User) ([]NotificationEnum, error)
	VoteCount(ctx context.Context, obj *User) (*UserVoteCount, error)
	EditCount(ctx context.Context, obj *User) (*UserEditCount, error)

	InvitedBy(ctx context.Context, obj *User) (*User, error)

	ActiveInviteCodes(ctx context.Context, obj *User) ([]string, error)
	InviteCodes(ctx context.Context, obj *User) ([]*InviteKey, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BodyModification.description":
		if e.complexity.BodyModification.Description == nil {
			break
		}

		return e.complexity.BodyModification.Description(childComplexity), true

	case "BodyModification.location":
		if e.complexity.BodyModification.Location == nil {
			break
		}

		return e.complexity.BodyModification.Location(childComplexity), true

	case "CommentCommentedEdit.comment":
		if e.complexity.CommentCommentedEdit.Comment == nil {
			break
		}

		return e.complexity.CommentCommentedEdit.Comment(childComplexity), true

	case "CommentOwnEdit.comment":
		if e.complexity.CommentOwnEdit.Comment == nil {
			break
		}

		return e.complexity.CommentOwnEdit.Comment(childComplexity), true

	case "CommentVotedEdit.comment":
		if e.complexity.CommentVotedEdit.Comment == nil {
			break
		}

		return e.complexity.CommentVotedEdit.Comment(childComplexity), true

	case "DownvoteOwnEdit.edit":
		if e.complexity.DownvoteOwnEdit.Edit == nil {
			break
		}

		return e.complexity.DownvoteOwnEdit.Edit(childComplexity), true

	case "Draft.created":
		if e.complexity.Draft.Created == nil {
			break
		}

		return e.complexity.Draft.Created(childComplexity), true

	case "Draft.data":
		if e.complexity.Draft.Data == nil {
			break
		}

		return e.complexity.Draft.Data(childComplexity), true

	case "Draft.expires":
		if e.complexity.Draft.Expires == nil {
			break
		}

		return e.complexity.Draft.Expires(childComplexity), true

	case "Draft.id":
		if e.complexity.Draft.ID == nil {
			break
		}

		return e.complexity.Draft.ID(childComplexity), true

	case "DraftEntity.id":
		if e.complexity.DraftEntity.ID == nil {
			break
		}

		return e.complexity.DraftEntity.ID(childComplexity), true

	case "DraftEntity.name":
		if e.complexity.DraftEntity.Name == nil {
			break
		}

		return e.complexity.DraftEntity.Name(childComplexity), true

	case "DraftFingerprint.algorithm":
		if e.complexity.DraftFingerprint.Algorithm == nil {
			break
		}

		return e.complexity.DraftFingerprint.Algorithm(childComplexity), true

	case "DraftFingerprint.duration":
		if e.complexity.DraftFingerprint.Duration == nil {
			break
		}

		return e.complexity.DraftFingerprint.Duration(childComplexity), true

	case "DraftFingerprint.hash":
		if e.complexity.DraftFingerprint.Hash == nil {
			break
		}

		return e.complexity.DraftFingerprint.Hash(childComplexity), true

	case "DraftSubmissionStatus.id":
		if e.complexity.DraftSubmissionStatus.ID == nil {
			break
		}

		return e.complexity.DraftSubmissionStatus.ID(childComplexity), true

	case "Edit.applied":
		if e.complexity.Edit.Applied == nil {
			break
		}

		return e.complexity.Edit.Applied(childComplexity), true

	case "Edit.bot":
		if e.complexity.Edit.Bot == nil {
			break
		}

		return e.complexity.Edit.Bot(childComplexity), true

	case "Edit.closed":
		if e.complexity.Edit.Closed == nil {
			break
		}

		return e.complexity.Edit.Closed(childComplexity), true

	case "Edit.comments":
		if e.complexity.Edit.Comments == nil {
			break
		}

		return e.complexity.Edit.Comments(childComplexity), true

	case "Edit.created":
		if e.complexity.Edit.Created == nil {
			break
		}

		return e.complexity.Edit.Created(childComplexity), true

	case "Edit.destructive":
		if e.complexity.Edit.Destructive == nil {
			break
		}

		return e.complexity.Edit.Destructive(childComplexity), true

	case "Edit.details":
		if e.complexity.Edit.Details == nil {
			break
		}

		return e.complexity.Edit.Details(childComplexity), true

	case "Edit.expires":
		if e.complexity.Edit.Expires == nil {
			break
		}

		return e.complexity.Edit.Expires(childComplexity), true

	case "Edit.id":
		if e.complexity.Edit.ID == nil {
			break
		}

		return e.complexity.Edit.ID(childComplexity), true

	case "Edit.merge_sources":
		if e.complexity.Edit.MergeSources == nil {
			break
		}

		return e.complexity.Edit.MergeSources(childComplexity), true

	case "Edit.old_details":
		if e.complexity.Edit.OldDetails == nil {
			break
		}

		return e.complexity.Edit.OldDetails(childComplexity), true

	case "Edit.operation":
		if e.complexity.Edit.Operation == nil {
			break
		}

		return e.complexity.Edit.Operation(childComplexity), true

	case "Edit.options":
		if e.complexity.Edit.Options == nil {
			break
		}

		return e.complexity.Edit.Options(childComplexity), true

	case "Edit.status":
		if e.complexity.Edit.Status == nil {
			break
		}

		return e.complexity.Edit.Status(childComplexity), true

	case "Edit.target":
		if e.complexity.Edit.Target == nil {
			break
		}

		return e.complexity.Edit.Target(childComplexity), true

	case "Edit.target_type":
		if e.complexity.Edit.TargetType == nil {
			break
		}

		return e.complexity.Edit.TargetType(childComplexity), true

	case "Edit.updatable":
		if e.complexity.Edit.Updatable == nil {
			break
		}

		return e.complexity.Edit.Updatable(childComplexity), true

	case "Edit.update_count":
		if e.complexity.Edit.UpdateCount == nil {
			break
		}

		return e.complexity.Edit.UpdateCount(childComplexity), true

	case "Edit.updated":
		if e.complexity.Edit.Updated == nil {
			break
		}

		return e.complexity.Edit.Updated(childComplexity), true

	case "Edit.user":
		if e.complexity.Edit.User == nil {
			break
		}

		return e.complexity.Edit.User(childComplexity), true

	case "Edit.vote_count":
		if e.complexity.Edit.VoteCount == nil {
			break
		}

		return e.complexity.Edit.VoteCount(childComplexity), true

	case "Edit.votes":
		if e.complexity.Edit.Votes == nil {
			break
		}

		return e.complexity.Edit.Votes(childComplexity), true

	case "EditComment.comment":
		if e.complexity.EditComment.Comment == nil {
			break
		}

		return e.complexity.EditComment.Comment(childComplexity), true

	case "EditComment.date":
		if e.complexity.EditComment.Date == nil {
			break
		}

		return e.complexity.EditComment.Date(childComplexity), true

	case "EditComment.edit":
		if e.complexity.EditComment.Edit == nil {
			break
		}

		return e.complexity.EditComment.Edit(childComplexity), true

	case "EditComment.id":
		if e.complexity.EditComment.ID == nil {
			break
		}

		return e.complexity.EditComment.ID(childComplexity), true

	case "EditComment.user":
		if e.complexity.EditComment.User == nil {
			break
		}

		return e.complexity.EditComment.User(childComplexity), true

	case "EditVote.date":
		if e.complexity.EditVote.Date == nil {
			break
		}

		return e.complexity.EditVote.Date(childComplexity), true

	case "EditVote.user":
		if e.complexity.EditVote.User == nil {
			break
		}

		return e.complexity.EditVote.User(childComplexity), true

	case "EditVote.vote":
		if e.complexity.EditVote.Vote == nil {
			break
		}

		return e.complexity.EditVote.Vote(childComplexity), true

	case "FailedOwnEdit.edit":
		if e.complexity.FailedOwnEdit.Edit == nil {
			break
		}

		return e.complexity.FailedOwnEdit.Edit(childComplexity), true

	case "FavoritePerformerEdit.edit":
		if e.complexity.FavoritePerformerEdit.Edit == nil {
			break
		}

		return e.complexity.FavoritePerformerEdit.Edit(childComplexity), true

	case "FavoritePerformerScene.scene":
		if e.complexity.FavoritePerformerScene.Scene == nil {
			break
		}

		return e.complexity.FavoritePerformerScene.Scene(childComplexity), true

	case "FavoriteStudioEdit.edit":
		if e.complexity.FavoriteStudioEdit.Edit == nil {
			break
		}

		return e.complexity.FavoriteStudioEdit.Edit(childComplexity), true

	case "FavoriteStudioScene.scene":
		if e.complexity.FavoriteStudioScene.Scene == nil {
			break
		}

		return e.complexity.FavoriteStudioScene.Scene(childComplexity), true

	case "Fingerprint.algorithm":
		if e.complexity.Fingerprint.Algorithm == nil {
			break
		}

		return e.complexity.Fingerprint.Algorithm(childComplexity), true

	case "Fingerprint.created":
		if e.complexity.Fingerprint.Created == nil {
			break
		}

		return e.complexity.Fingerprint.Created(childComplexity), true

	case "Fingerprint.duration":
		if e.complexity.Fingerprint.Duration == nil {
			break
		}

		return e.complexity.Fingerprint.Duration(childComplexity), true

	case "Fingerprint.hash":
		if e.complexity.Fingerprint.Hash == nil {
			break
		}

		return e.complexity.Fingerprint.Hash(childComplexity), true

	case "Fingerprint.reports":
		if e.complexity.Fingerprint.Reports == nil {
			break
		}

		return e.complexity.Fingerprint.Reports(childComplexity), true

	case "Fingerprint.submissions":
		if e.complexity.Fingerprint.Submissions == nil {
			break
		}

		return e.complexity.Fingerprint.Submissions(childComplexity), true

	case "Fingerprint.updated":
		if e.complexity.Fingerprint.Updated == nil {
			break
		}

		return e.complexity.Fingerprint.Updated(childComplexity), true

	case "Fingerprint.user_reported":
		if e.complexity.Fingerprint.UserReported == nil {
			break
		}

		return e.complexity.Fingerprint.UserReported(childComplexity), true

	case "Fingerprint.user_submitted":
		if e.complexity.Fingerprint.UserSubmitted == nil {
			break
		}

		return e.complexity.Fingerprint.UserSubmitted(childComplexity), true

	case "FuzzyDate.accuracy":
		if e.complexity.FuzzyDate.Accuracy == nil {
			break
		}

		return e.complexity.FuzzyDate.Accuracy(childComplexity), true

	case "FuzzyDate.date":
		if e.complexity.FuzzyDate.Date == nil {
			break
		}

		return e.complexity.FuzzyDate.Date(childComplexity), true

	case "Image.height":
		if e.complexity.Image.Height == nil {
			break
		}

		return e.complexity.Image.Height(childComplexity), true

	case "Image.id":
		if e.complexity.Image.ID == nil {
			break
		}

		return e.complexity.Image.ID(childComplexity), true

	case "Image.url":
		if e.complexity.Image.URL == nil {
			break
		}

		return e.complexity.Image.URL(childComplexity), true

	case "Image.width":
		if e.complexity.Image.Width == nil {
			break
		}

		return e.complexity.Image.Width(childComplexity), true

	case "InviteKey.expires":
		if e.complexity.InviteKey.Expires == nil {
			break
		}

		return e.complexity.InviteKey.Expires(childComplexity), true

	case "InviteKey.id":
		if e.complexity.InviteKey.ID == nil {
			break
		}

		return e.complexity.InviteKey.ID(childComplexity), true

	case "InviteKey.uses":
		if e.complexity.InviteKey.Uses == nil {
			break
		}

		return e.complexity.InviteKey.Uses(childComplexity), true

	case "Measurements.band_size":
		if e.complexity.Measurements.BandSize == nil {
			break
		}

		return e.complexity.Measurements.BandSize(childComplexity), true

	case "Measurements.cup_size":
		if e.complexity.Measurements.CupSize == nil {
			break
		}

		return e.complexity.Measurements.CupSize(childComplexity), true

	case "Measurements.hip":
		if e.complexity.Measurements.Hip == nil {
			break
		}

		return e.complexity.Measurements.Hip(childComplexity), true

	case "Measurements.waist":
		if e.complexity.Measurements.Waist == nil {
			break
		}

		return e.complexity.Measurements.Waist(childComplexity), true

	case "Mutation.activateNewUser":
		if e.complexity.Mutation.ActivateNewUser == nil {
			break
		}

		args, err := ec.field_Mutation_activateNewUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ActivateNewUser(childComplexity, args["input"].(ActivateNewUserInput)), true

	case "Mutation.applyEdit":
		if e.complexity.Mutation.ApplyEdit == nil {
			break
		}

		args, err := ec.field_Mutation_applyEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApplyEdit(childComplexity, args["input"].(ApplyEditInput)), true

	case "Mutation.cancelEdit":
		if e.complexity.Mutation.CancelEdit == nil {
			break
		}

		args, err := ec.field_Mutation_cancelEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelEdit(childComplexity, args["input"].(CancelEditInput)), true

	case "Mutation.changePassword":
		if e.complexity.Mutation.ChangePassword == nil {
			break
		}

		args, err := ec.field_Mutation_changePassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangePassword(childComplexity, args["input"].(UserChangePasswordInput)), true

	case "Mutation.confirmChangeEmail":
		if e.complexity.Mutation.ConfirmChangeEmail == nil {
			break
		}

		args, err := ec.field_Mutation_confirmChangeEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmChangeEmail(childComplexity, args["token"].(uuid.UUID)), true

	case "Mutation.destroyDraft":
		if e.complexity.Mutation.DestroyDraft == nil {
			break
		}

		args, err := ec.field_Mutation_destroyDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DestroyDraft(childComplexity, args["id"].(uuid.UUID)), true

	case "Mutation.editComment":
		if e.complexity.Mutation.EditComment == nil {
			break
		}

		args, err := ec.field_Mutation_editComment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditComment(childComplexity, args["input"].(EditCommentInput)), true

	case "Mutation.editVote":
		if e.complexity.Mutation.EditVote == nil {
			break
		}

		args, err := ec.field_Mutation_editVote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditVote(childComplexity, args["input"].(EditVoteInput)), true

	case "Mutation.favoritePerformer":
		if e.complexity.Mutation.FavoritePerformer == nil {
			break
		}

		args, err := ec.field_Mutation_favoritePerformer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FavoritePerformer(childComplexity, args["id"].(uuid.UUID), args["favorite"].(bool)), true

	case "Mutation.favoriteStudio":
		if e.complexity.Mutation.FavoriteStudio == nil {
			break
		}

		args, err := ec.field_Mutation_favoriteStudio_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FavoriteStudio(childComplexity, args["id"].(uuid.UUID), args["favorite"].(bool)), true

	case "Mutation.generateInviteCode":
		if e.complexity.Mutation.GenerateInviteCode == nil {
			break
		}

		return e.complexity.Mutation.GenerateInviteCode(childComplexity), true

	case "Mutation.generateInviteCodes":
		if e.complexity.Mutation.GenerateInviteCodes == nil {
			break
		}

		args, err := ec.field_Mutation_generateInviteCodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GenerateInviteCodes(childComplexity, args["input"].(*GenerateInviteCodeInput)), true

	case "Mutation.grantInvite":
		if e.complexity.Mutation.GrantInvite == nil {
			break
		}

		args, err := ec.field_Mutation_grantInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GrantInvite(childComplexity, args["input"].(GrantInviteInput)), true

	case "Mutation.imageCreate":
		if e.complexity.Mutation.ImageCreate == nil {
			break
		}

		args, err := ec.field_Mutation_imageCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImageCreate(childComplexity, args["input"].(ImageCreateInput)), true

	case "Mutation.imageDestroy":
		if e.complexity.Mutation.ImageDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_imageDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ImageDestroy(childComplexity, args["input"].(ImageDestroyInput)), true

	case "Mutation.markNotificationsRead":
		if e.complexity.Mutation.MarkNotificationsRead == nil {
			break
		}

		return e.complexity.Mutation.MarkNotificationsRead(childComplexity), true

	case "Mutation.newUser":
		if e.complexity.Mutation.NewUser == nil {
			break
		}

		args, err := ec.field_Mutation_newUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewUser(childComplexity, args["input"].(NewUserInput)), true

	case "Mutation.performerCreate":
		if e.complexity.Mutation.PerformerCreate == nil {
			break
		}

		args, err := ec.field_Mutation_performerCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerCreate(childComplexity, args["input"].(PerformerCreateInput)), true

	case "Mutation.performerDestroy":
		if e.complexity.Mutation.PerformerDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_performerDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerDestroy(childComplexity, args["input"].(PerformerDestroyInput)), true

	case "Mutation.performerEdit":
		if e.complexity.Mutation.PerformerEdit == nil {
			break
		}

		args, err := ec.field_Mutation_performerEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerEdit(childComplexity, args["input"].(PerformerEditInput)), true

	case "Mutation.performerEditUpdate":
		if e.complexity.Mutation.PerformerEditUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_performerEditUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerEditUpdate(childComplexity, args["id"].(uuid.UUID), args["input"].(PerformerEditInput)), true

	case "Mutation.performerUpdate":
		if e.complexity.Mutation.PerformerUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_performerUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PerformerUpdate(childComplexity, args["input"].(PerformerUpdateInput)), true

	case "Mutation.regenerateAPIKey":
		if e.complexity.Mutation.RegenerateAPIKey == nil {
			break
		}

		args, err := ec.field_Mutation_regenerateAPIKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegenerateAPIKey(childComplexity, args["userID"].(*uuid.UUID)), true

	case "Mutation.requestChangeEmail":
		if e.complexity.Mutation.RequestChangeEmail == nil {
			break
		}

		return e.complexity.Mutation.RequestChangeEmail(childComplexity), true

	case "Mutation.rescindInviteCode":
		if e.complexity.Mutation.RescindInviteCode == nil {
			break
		}

		args, err := ec.field_Mutation_rescindInviteCode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RescindInviteCode(childComplexity, args["code"].(uuid.UUID)), true

	case "Mutation.resetPassword":
		if e.complexity.Mutation.ResetPassword == nil {
			break
		}

		args, err := ec.field_Mutation_resetPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResetPassword(childComplexity, args["input"].(ResetPasswordInput)), true

	case "Mutation.revokeInvite":
		if e.complexity.Mutation.RevokeInvite == nil {
			break
		}

		args, err := ec.field_Mutation_revokeInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeInvite(childComplexity, args["input"].(RevokeInviteInput)), true

	case "Mutation.sceneCreate":
		if e.complexity.Mutation.SceneCreate == nil {
			break
		}

		args, err := ec.field_Mutation_sceneCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneCreate(childComplexity, args["input"].(SceneCreateInput)), true

	case "Mutation.sceneDestroy":
		if e.complexity.Mutation.SceneDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_sceneDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneDestroy(childComplexity, args["input"].(SceneDestroyInput)), true

	case "Mutation.sceneEdit":
		if e.complexity.Mutation.SceneEdit == nil {
			break
		}

		args, err := ec.field_Mutation_sceneEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneEdit(childComplexity, args["input"].(SceneEditInput)), true

	case "Mutation.sceneEditUpdate":
		if e.complexity.Mutation.SceneEditUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_sceneEditUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneEditUpdate(childComplexity, args["id"].(uuid.UUID), args["input"].(SceneEditInput)), true

	case "Mutation.sceneUpdate":
		if e.complexity.Mutation.SceneUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_sceneUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SceneUpdate(childComplexity, args["input"].(SceneUpdateInput)), true

	case "Mutation.siteCreate":
		if e.complexity.Mutation.SiteCreate == nil {
			break
		}

		args, err := ec.field_Mutation_siteCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SiteCreate(childComplexity, args["input"].(SiteCreateInput)), true

	case "Mutation.siteDestroy":
		if e.complexity.Mutation.SiteDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_siteDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SiteDestroy(childComplexity, args["input"].(SiteDestroyInput)), true

	case "Mutation.siteUpdate":
		if e.complexity.Mutation.SiteUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_siteUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SiteUpdate(childComplexity, args["input"].(SiteUpdateInput)), true

	case "Mutation.studioCreate":
		if e.complexity.Mutation.StudioCreate == nil {
			break
		}

		args, err := ec.field_Mutation_studioCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioCreate(childComplexity, args["input"].(StudioCreateInput)), true

	case "Mutation.studioDestroy":
		if e.complexity.Mutation.StudioDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_studioDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioDestroy(childComplexity, args["input"].(StudioDestroyInput)), true

	case "Mutation.studioEdit":
		if e.complexity.Mutation.StudioEdit == nil {
			break
		}

		args, err := ec.field_Mutation_studioEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioEdit(childComplexity, args["input"].(StudioEditInput)), true

	case "Mutation.studioEditUpdate":
		if e.complexity.Mutation.StudioEditUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_studioEditUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioEditUpdate(childComplexity, args["id"].(uuid.UUID), args["input"].(StudioEditInput)), true

	case "Mutation.studioUpdate":
		if e.complexity.Mutation.StudioUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_studioUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StudioUpdate(childComplexity, args["input"].(StudioUpdateInput)), true

	case "Mutation.submitFingerprint":
		if e.complexity.Mutation.SubmitFingerprint == nil {
			break
		}

		args, err := ec.field_Mutation_submitFingerprint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SubmitFingerprint(childComplexity, args["input"].(FingerprintSubmission)), true

	case "Mutation.submitPerformerDraft":
		if e.complexity.Mutation.SubmitPerformerDraft == nil {
			break
		}

		args, err := ec.field_Mutation_submitPerformerDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SubmitPerformerDraft(childComplexity, args["input"].(PerformerDraftInput)), true

	case "Mutation.submitSceneDraft":
		if e.complexity.Mutation.SubmitSceneDraft == nil {
			break
		}

		args, err := ec.field_Mutation_submitSceneDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SubmitSceneDraft(childComplexity, args["input"].(SceneDraftInput)), true

	case "Mutation.tagCategoryCreate":
		if e.complexity.Mutation.TagCategoryCreate == nil {
			break
		}

		args, err := ec.field_Mutation_tagCategoryCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagCategoryCreate(childComplexity, args["input"].(TagCategoryCreateInput)), true

	case "Mutation.tagCategoryDestroy":
		if e.complexity.Mutation.TagCategoryDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_tagCategoryDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagCategoryDestroy(childComplexity, args["input"].(TagCategoryDestroyInput)), true

	case "Mutation.tagCategoryUpdate":
		if e.complexity.Mutation.TagCategoryUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_tagCategoryUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagCategoryUpdate(childComplexity, args["input"].(TagCategoryUpdateInput)), true

	case "Mutation.tagCreate":
		if e.complexity.Mutation.TagCreate == nil {
			break
		}

		args, err := ec.field_Mutation_tagCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagCreate(childComplexity, args["input"].(TagCreateInput)), true

	case "Mutation.tagDestroy":
		if e.complexity.Mutation.TagDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_tagDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagDestroy(childComplexity, args["input"].(TagDestroyInput)), true

	case "Mutation.tagEdit":
		if e.complexity.Mutation.TagEdit == nil {
			break
		}

		args, err := ec.field_Mutation_tagEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagEdit(childComplexity, args["input"].(TagEditInput)), true

	case "Mutation.tagEditUpdate":
		if e.complexity.Mutation.TagEditUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_tagEditUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagEditUpdate(childComplexity, args["id"].(uuid.UUID), args["input"].(TagEditInput)), true

	case "Mutation.tagUpdate":
		if e.complexity.Mutation.TagUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_tagUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagUpdate(childComplexity, args["input"].(TagUpdateInput)), true

	case "Mutation.updateNotificationSubscriptions":
		if e.complexity.Mutation.UpdateNotificationSubscriptions == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotificationSubscriptions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotificationSubscriptions(childComplexity, args["subscriptions"].([]NotificationEnum)), true

	case "Mutation.userCreate":
		if e.complexity.Mutation.UserCreate == nil {
			break
		}

		args, err := ec.field_Mutation_userCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserCreate(childComplexity, args["input"].(UserCreateInput)), true

	case "Mutation.userDestroy":
		if e.complexity.Mutation.UserDestroy == nil {
			break
		}

		args, err := ec.field_Mutation_userDestroy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserDestroy(childComplexity, args["input"].(UserDestroyInput)), true

	case "Mutation.userUpdate":
		if e.complexity.Mutation.UserUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_userUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserUpdate(childComplexity, args["input"].(UserUpdateInput)), true

	case "Mutation.validateChangeEmail":
		if e.complexity.Mutation.ValidateChangeEmail == nil {
			break
		}

		args, err := ec.field_Mutation_validateChangeEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ValidateChangeEmail(childComplexity, args["token"].(uuid.UUID), args["email"].(string)), true

	case "Notification.created":
		if e.complexity.Notification.Created == nil {
			break
		}

		return e.complexity.Notification.Created(childComplexity), true

	case "Notification.data":
		if e.complexity.Notification.Data == nil {
			break
		}

		return e.complexity.Notification.Data(childComplexity), true

	case "Notification.read":
		if e.complexity.Notification.Read == nil {
			break
		}

		return e.complexity.Notification.Read(childComplexity), true

	case "Performer.age":
		if e.complexity.Performer.Age == nil {
			break
		}

		return e.complexity.Performer.Age(childComplexity), true

	case "Performer.aliases":
		if e.complexity.Performer.Aliases == nil {
			break
		}

		return e.complexity.Performer.Aliases(childComplexity), true

	case "Performer.band_size":
		if e.complexity.Performer.BandSize == nil {
			break
		}

		return e.complexity.Performer.BandSize(childComplexity), true

	case "Performer.birth_date":
		if e.complexity.Performer.BirthDate == nil {
			break
		}

		return e.complexity.Performer.BirthDate(childComplexity), true

	case "Performer.birthdate":
		if e.complexity.Performer.Birthdate == nil {
			break
		}

		return e.complexity.Performer.Birthdate(childComplexity), true

	case "Performer.breast_type":
		if e.complexity.Performer.BreastType == nil {
			break
		}

		return e.complexity.Performer.BreastType(childComplexity), true

	case "Performer.career_end_year":
		if e.complexity.Performer.CareerEndYear == nil {
			break
		}

		return e.complexity.Performer.CareerEndYear(childComplexity), true

	case "Performer.career_start_year":
		if e.complexity.Performer.CareerStartYear == nil {
			break
		}

		return e.complexity.Performer.CareerStartYear(childComplexity), true

	case "Performer.country":
		if e.complexity.Performer.Country == nil {
			break
		}

		return e.complexity.Performer.Country(childComplexity), true

	case "Performer.created":
		if e.complexity.Performer.Created == nil {
			break
		}

		return e.complexity.Performer.Created(childComplexity), true

	case "Performer.cup_size":
		if e.complexity.Performer.CupSize == nil {
			break
		}

		return e.complexity.Performer.CupSize(childComplexity), true

	case "Performer.death_date":
		if e.complexity.Performer.DeathDate == nil {
			break
		}

		return e.complexity.Performer.DeathDate(childComplexity), true

	case "Performer.deleted":
		if e.complexity.Performer.Deleted == nil {
			break
		}

		return e.complexity.Performer.Deleted(childComplexity), true

	case "Performer.disambiguation":
		if e.complexity.Performer.Disambiguation == nil {
			break
		}

		return e.complexity.Performer.Disambiguation(childComplexity), true

	case "Performer.edits":
		if e.complexity.Performer.Edits == nil {
			break
		}

		return e.complexity.Performer.Edits(childComplexity), true

	case "Performer.ethnicity":
		if e.complexity.Performer.Ethnicity == nil {
			break
		}

		return e.complexity.Performer.Ethnicity(childComplexity), true

	case "Performer.eye_color":
		if e.complexity.Performer.EyeColor == nil {
			break
		}

		return e.complexity.Performer.EyeColor(childComplexity), true

	case "Performer.gender":
		if e.complexity.Performer.Gender == nil {
			break
		}

		return e.complexity.Performer.Gender(childComplexity), true

	case "Performer.hair_color":
		if e.complexity.Performer.HairColor == nil {
			break
		}

		return e.complexity.Performer.HairColor(childComplexity), true

	case "Performer.height":
		if e.complexity.Performer.Height == nil {
			break
		}

		return e.complexity.Performer.Height(childComplexity), true

	case "Performer.hip_size":
		if e.complexity.Performer.HipSize == nil {
			break
		}

		return e.complexity.Performer.HipSize(childComplexity), true

	case "Performer.id":
		if e.complexity.Performer.ID == nil {
			break
		}

		return e.complexity.Performer.ID(childComplexity), true

	case "Performer.images":
		if e.complexity.Performer.Images == nil {
			break
		}

		return e.complexity.Performer.Images(childComplexity), true

	case "Performer.is_favorite":
		if e.complexity.Performer.IsFavorite == nil {
			break
		}

		return e.complexity.Performer.IsFavorite(childComplexity), true

	case "Performer.measurements":
		if e.complexity.Performer.Measurements == nil {
			break
		}

		return e.complexity.Performer.Measurements(childComplexity), true

	case "Performer.merged_ids":
		if e.complexity.Performer.MergedIds == nil {
			break
		}

		return e.complexity.Performer.MergedIds(childComplexity), true

	case "Performer.merged_into_id":
		if e.complexity.Performer.MergedIntoID == nil {
			break
		}

		return e.complexity.Performer.MergedIntoID(childComplexity), true

	case "Performer.name":
		if e.complexity.Performer.Name == nil {
			break
		}

		return e.complexity.Performer.Name(childComplexity), true

	case "Performer.piercings":
		if e.complexity.Performer.Piercings == nil {
			break
		}

		return e.complexity.Performer.Piercings(childComplexity), true

	case "Performer.scene_count":
		if e.complexity.Performer.SceneCount == nil {
			break
		}

		return e.complexity.Performer.SceneCount(childComplexity), true

	case "Performer.scenes":
		if e.complexity.Performer.Scenes == nil {
			break
		}

		args, err := ec.field_Performer_scenes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Performer.Scenes(childComplexity, args["input"].(*PerformerScenesInput)), true

	case "Performer.studios":
		if e.complexity.Performer.Studios == nil {
			break
		}

		return e.complexity.Performer.Studios(childComplexity), true

	case "Performer.tattoos":
		if e.complexity.Performer.Tattoos == nil {
			break
		}

		return e.complexity.Performer.Tattoos(childComplexity), true

	case "Performer.updated":
		if e.complexity.Performer.Updated == nil {
			break
		}

		return e.complexity.Performer.Updated(childComplexity), true

	case "Performer.urls":
		if e.complexity.Performer.Urls == nil {
			break
		}

		return e.complexity.Performer.Urls(childComplexity), true

	case "Performer.waist_size":
		if e.complexity.Performer.WaistSize == nil {
			break
		}

		return e.complexity.Performer.WaistSize(childComplexity), true

	case "PerformerAppearance.as":
		if e.complexity.PerformerAppearance.As == nil {
			break
		}

		return e.complexity.PerformerAppearance.As(childComplexity), true

	case "PerformerAppearance.performer":
		if e.complexity.PerformerAppearance.Performer == nil {
			break
		}

		return e.complexity.PerformerAppearance.Performer(childComplexity), true

	case "PerformerDraft.aliases":
		if e.complexity.PerformerDraft.Aliases == nil {
			break
		}

		return e.complexity.PerformerDraft.Aliases(childComplexity), true

	case "PerformerDraft.birthdate":
		if e.complexity.PerformerDraft.Birthdate == nil {
			break
		}

		return e.complexity.PerformerDraft.Birthdate(childComplexity), true

	case "PerformerDraft.breast_type":
		if e.complexity.PerformerDraft.BreastType == nil {
			break
		}

		return e.complexity.PerformerDraft.BreastType(childComplexity), true

	case "PerformerDraft.career_end_year":
		if e.complexity.PerformerDraft.CareerEndYear == nil {
			break
		}

		return e.complexity.PerformerDraft.CareerEndYear(childComplexity), true

	case "PerformerDraft.career_start_year":
		if e.complexity.PerformerDraft.CareerStartYear == nil {
			break
		}

		return e.complexity.PerformerDraft.CareerStartYear(childComplexity), true

	case "PerformerDraft.country":
		if e.complexity.PerformerDraft.Country == nil {
			break
		}

		return e.complexity.PerformerDraft.Country(childComplexity), true

	case "PerformerDraft.deathdate":
		if e.complexity.PerformerDraft.Deathdate == nil {
			break
		}

		return e.complexity.PerformerDraft.Deathdate(childComplexity), true

	case "PerformerDraft.disambiguation":
		if e.complexity.PerformerDraft.Disambiguation == nil {
			break
		}

		return e.complexity.PerformerDraft.Disambiguation(childComplexity), true

	case "PerformerDraft.ethnicity":
		if e.complexity.PerformerDraft.Ethnicity == nil {
			break
		}

		return e.complexity.PerformerDraft.Ethnicity(childComplexity), true

	case "PerformerDraft.eye_color":
		if e.complexity.PerformerDraft.EyeColor == nil {
			break
		}

		return e.complexity.PerformerDraft.EyeColor(childComplexity), true

	case "PerformerDraft.gender":
		if e.complexity.PerformerDraft.Gender == nil {
			break
		}

		return e.complexity.PerformerDraft.Gender(childComplexity), true

	case "PerformerDraft.hair_color":
		if e.complexity.PerformerDraft.HairColor == nil {
			break
		}

		return e.complexity.PerformerDraft.HairColor(childComplexity), true

	case "PerformerDraft.height":
		if e.complexity.PerformerDraft.Height == nil {
			break
		}

		return e.complexity.PerformerDraft.Height(childComplexity), true

	case "PerformerDraft.id":
		if e.complexity.PerformerDraft.ID == nil {
			break
		}

		return e.complexity.PerformerDraft.ID(childComplexity), true

	case "PerformerDraft.image":
		if e.complexity.PerformerDraft.Image == nil {
			break
		}

		return e.complexity.PerformerDraft.Image(childComplexity), true

	case "PerformerDraft.measurements":
		if e.complexity.PerformerDraft.Measurements == nil {
			break
		}

		return e.complexity.PerformerDraft.Measurements(childComplexity), true

	case "PerformerDraft.name":
		if e.complexity.PerformerDraft.Name == nil {
			break
		}

		return e.complexity.PerformerDraft.Name(childComplexity), true

	case "PerformerDraft.piercings":
		if e.complexity.PerformerDraft.Piercings == nil {
			break
		}

		return e.complexity.PerformerDraft.Piercings(childComplexity), true

	case "PerformerDraft.tattoos":
		if e.complexity.PerformerDraft.Tattoos == nil {
			break
		}

		return e.complexity.PerformerDraft.Tattoos(childComplexity), true

	case "PerformerDraft.urls":
		if e.complexity.PerformerDraft.Urls == nil {
			break
		}

		return e.complexity.PerformerDraft.Urls(childComplexity), true

	case "PerformerEdit.added_aliases":
		if e.complexity.PerformerEdit.AddedAliases == nil {
			break
		}

		return e.complexity.PerformerEdit.AddedAliases(childComplexity), true

	case "PerformerEdit.added_images":
		if e.complexity.PerformerEdit.AddedImages == nil {
			break
		}

		return e.complexity.PerformerEdit.AddedImages(childComplexity), true

	case "PerformerEdit.added_piercings":
		if e.complexity.PerformerEdit.AddedPiercings == nil {
			break
		}

		return e.complexity.PerformerEdit.AddedPiercings(childComplexity), true

	case "PerformerEdit.added_tattoos":
		if e.complexity.PerformerEdit.AddedTattoos == nil {
			break
		}

		return e.complexity.PerformerEdit.AddedTattoos(childComplexity), true

	case "PerformerEdit.added_urls":
		if e.complexity.PerformerEdit.AddedUrls == nil {
			break
		}

		return e.complexity.PerformerEdit.AddedUrls(childComplexity), true

	case "PerformerEdit.aliases":
		if e.complexity.PerformerEdit.Aliases == nil {
			break
		}

		return e.complexity.PerformerEdit.Aliases(childComplexity), true

	case "PerformerEdit.band_size":
		if e.complexity.PerformerEdit.BandSize == nil {
			break
		}

		return e.complexity.PerformerEdit.BandSize(childComplexity), true

	case "PerformerEdit.birthdate":
		if e.complexity.PerformerEdit.Birthdate == nil {
			break
		}

		return e.complexity.PerformerEdit.Birthdate(childComplexity), true

	case "PerformerEdit.breast_type":
		if e.complexity.PerformerEdit.BreastType == nil {
			break
		}

		return e.complexity.PerformerEdit.BreastType(childComplexity), true

	case "PerformerEdit.career_end_year":
		if e.complexity.PerformerEdit.CareerEndYear == nil {
			break
		}

		return e.complexity.PerformerEdit.CareerEndYear(childComplexity), true

	case "PerformerEdit.career_start_year":
		if e.complexity.PerformerEdit.CareerStartYear == nil {
			break
		}

		return e.complexity.PerformerEdit.CareerStartYear(childComplexity), true

	case "PerformerEdit.country":
		if e.complexity.PerformerEdit.Country == nil {
			break
		}

		return e.complexity.PerformerEdit.Country(childComplexity), true

	case "PerformerEdit.cup_size":
		if e.complexity.PerformerEdit.CupSize == nil {
			break
		}

		return e.complexity.PerformerEdit.CupSize(childComplexity), true

	case "PerformerEdit.deathdate":
		if e.complexity.PerformerEdit.Deathdate == nil {
			break
		}

		return e.complexity.PerformerEdit.Deathdate(childComplexity), true

	case "PerformerEdit.disambiguation":
		if e.complexity.PerformerEdit.Disambiguation == nil {
			break
		}

		return e.complexity.PerformerEdit.Disambiguation(childComplexity), true

	case "PerformerEdit.draft_id":
		if e.complexity.PerformerEdit.DraftID == nil {
			break
		}

		return e.complexity.PerformerEdit.DraftID(childComplexity), true

	case "PerformerEdit.ethnicity":
		if e.complexity.PerformerEdit.Ethnicity == nil {
			break
		}

		return e.complexity.PerformerEdit.Ethnicity(childComplexity), true

	case "PerformerEdit.eye_color":
		if e.complexity.PerformerEdit.EyeColor == nil {
			break
		}

		return e.complexity.PerformerEdit.EyeColor(childComplexity), true

	case "PerformerEdit.gender":
		if e.complexity.PerformerEdit.Gender == nil {
			break
		}

		return e.complexity.PerformerEdit.Gender(childComplexity), true

	case "PerformerEdit.hair_color":
		if e.complexity.PerformerEdit.HairColor == nil {
			break
		}

		return e.complexity.PerformerEdit.HairColor(childComplexity), true

	case "PerformerEdit.height":
		if e.complexity.PerformerEdit.Height == nil {
			break
		}

		return e.complexity.PerformerEdit.Height(childComplexity), true

	case "PerformerEdit.hip_size":
		if e.complexity.PerformerEdit.HipSize == nil {
			break
		}

		return e.complexity.PerformerEdit.HipSize(childComplexity), true

	case "PerformerEdit.images":
		if e.complexity.PerformerEdit.Images == nil {
			break
		}

		return e.complexity.PerformerEdit.Images(childComplexity), true

	case "PerformerEdit.name":
		if e.complexity.PerformerEdit.Name == nil {
			break
		}

		return e.complexity.PerformerEdit.Name(childComplexity), true

	case "PerformerEdit.piercings":
		if e.complexity.PerformerEdit.Piercings == nil {
			break
		}

		return e.complexity.PerformerEdit.Piercings(childComplexity), true

	case "PerformerEdit.removed_aliases":
		if e.complexity.PerformerEdit.RemovedAliases == nil {
			break
		}

		return e.complexity.PerformerEdit.RemovedAliases(childComplexity), true

	case "PerformerEdit.removed_images":
		if e.complexity.PerformerEdit.RemovedImages == nil {
			break
		}

		return e.complexity.PerformerEdit.RemovedImages(childComplexity), true

	case "PerformerEdit.removed_piercings":
		if e.complexity.PerformerEdit.RemovedPiercings == nil {
			break
		}

		return e.complexity.PerformerEdit.RemovedPiercings(childComplexity), true

	case "PerformerEdit.removed_tattoos":
		if e.complexity.PerformerEdit.RemovedTattoos == nil {
			break
		}

		return e.complexity.PerformerEdit.RemovedTattoos(childComplexity), true

	case "PerformerEdit.removed_urls":
		if e.complexity.PerformerEdit.RemovedUrls == nil {
			break
		}

		return e.complexity.PerformerEdit.RemovedUrls(childComplexity), true

	case "PerformerEdit.tattoos":
		if e.complexity.PerformerEdit.Tattoos == nil {
			break
		}

		return e.complexity.PerformerEdit.Tattoos(childComplexity), true

	case "PerformerEdit.urls":
		if e.complexity.PerformerEdit.Urls == nil {
			break
		}

		return e.complexity.PerformerEdit.Urls(childComplexity), true

	case "PerformerEdit.waist_size":
		if e.complexity.PerformerEdit.WaistSize == nil {
			break
		}

		return e.complexity.PerformerEdit.WaistSize(childComplexity), true

	case "PerformerEditOptions.set_merge_aliases":
		if e.complexity.PerformerEditOptions.SetMergeAliases == nil {
			break
		}

		return e.complexity.PerformerEditOptions.SetMergeAliases(childComplexity), true

	case "PerformerEditOptions.set_modify_aliases":
		if e.complexity.PerformerEditOptions.SetModifyAliases == nil {
			break
		}

		return e.complexity.PerformerEditOptions.SetModifyAliases(childComplexity), true

	case "PerformerStudio.scene_count":
		if e.complexity.PerformerStudio.SceneCount == nil {
			break
		}

		return e.complexity.PerformerStudio.SceneCount(childComplexity), true

	case "PerformerStudio.studio":
		if e.complexity.PerformerStudio.Studio == nil {
			break
		}

		return e.complexity.PerformerStudio.Studio(childComplexity), true

	case "Query.findDraft":
		if e.complexity.Query.FindDraft == nil {
			break
		}

		args, err := ec.field_Query_findDraft_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindDraft(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.findDrafts":
		if e.complexity.Query.FindDrafts == nil {
			break
		}

		return e.complexity.Query.FindDrafts(childComplexity), true

	case "Query.findEdit":
		if e.complexity.Query.FindEdit == nil {
			break
		}

		args, err := ec.field_Query_findEdit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindEdit(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.findPerformer":
		if e.complexity.Query.FindPerformer == nil {
			break
		}

		args, err := ec.field_Query_findPerformer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindPerformer(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.findScene":
		if e.complexity.Query.FindScene == nil {
			break
		}

		args, err := ec.field_Query_findScene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindScene(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.findSceneByFingerprint":
		if e.complexity.Query.FindSceneByFingerprint == nil {
			break
		}

		args, err := ec.field_Query_findSceneByFingerprint_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindSceneByFingerprint(childComplexity, args["fingerprint"].(FingerprintQueryInput)), true

	case "Query.findScenesByFingerprints":
		if e.complexity.Query.FindScenesByFingerprints == nil {
			break
		}

		args, err := ec.field_Query_findScenesByFingerprints_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindScenesByFingerprints(childComplexity, args["fingerprints"].([]string)), true

	case "Query.findScenesByFullFingerprints":
		if e.complexity.Query.FindScenesByFullFingerprints == nil {
			break
		}

		args, err := ec.field_Query_findScenesByFullFingerprints_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindScenesByFullFingerprints(childComplexity, args["fingerprints"].([]*FingerprintQueryInput)), true

	case "Query.findScenesBySceneFingerprints":
		if e.complexity.Query.FindScenesBySceneFingerprints == nil {
			break
		}

		args, err := ec.field_Query_findScenesBySceneFingerprints_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindScenesBySceneFingerprints(childComplexity, args["fingerprints"].([][]*FingerprintQueryInput)), true

	case "Query.findSite":
		if e.complexity.Query.FindSite == nil {
			break
		}

		args, err := ec.field_Query_findSite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindSite(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.findStudio":
		if e.complexity.Query.FindStudio == nil {
			break
		}

		args, err := ec.field_Query_findStudio_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindStudio(childComplexity, args["id"].(*uuid.UUID), args["name"].(*string)), true

	case "Query.findTag":
		if e.complexity.Query.FindTag == nil {
			break
		}

		args, err := ec.field_Query_findTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTag(childComplexity, args["id"].(*uuid.UUID), args["name"].(*string)), true

	case "Query.findTagCategory":
		if e.complexity.Query.FindTagCategory == nil {
			break
		}

		args, err := ec.field_Query_findTagCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTagCategory(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.findTagOrAlias":
		if e.complexity.Query.FindTagOrAlias == nil {
			break
		}

		args, err := ec.field_Query_findTagOrAlias_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTagOrAlias(childComplexity, args["name"].(string)), true

	case "Query.findUser":
		if e.complexity.Query.FindUser == nil {
			break
		}

		args, err := ec.field_Query_findUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUser(childComplexity, args["id"].(*uuid.UUID), args["username"].(*string)), true

	case "Query.getConfig":
		if e.complexity.Query.GetConfig == nil {
			break
		}

		return e.complexity.Query.GetConfig(childComplexity), true

	case "Query.getUnreadNotificationCount":
		if e.complexity.Query.GetUnreadNotificationCount == nil {
			break
		}

		return e.complexity.Query.GetUnreadNotificationCount(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.queryEdits":
		if e.complexity.Query.QueryEdits == nil {
			break
		}

		args, err := ec.field_Query_queryEdits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEdits(childComplexity, args["input"].(EditQueryInput)), true

	case "Query.queryExistingPerformer":
		if e.complexity.Query.QueryExistingPerformer == nil {
			break
		}

		args, err := ec.field_Query_queryExistingPerformer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryExistingPerformer(childComplexity, args["input"].(QueryExistingPerformerInput)), true

	case "Query.queryExistingScene":
		if e.complexity.Query.QueryExistingScene == nil {
			break
		}

		args, err := ec.field_Query_queryExistingScene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryExistingScene(childComplexity, args["input"].(QueryExistingSceneInput)), true

	case "Query.queryNotifications":
		if e.complexity.Query.QueryNotifications == nil {
			break
		}

		args, err := ec.field_Query_queryNotifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryNotifications(childComplexity, args["input"].(QueryNotificationsInput)), true

	case "Query.queryPerformers":
		if e.complexity.Query.QueryPerformers == nil {
			break
		}

		args, err := ec.field_Query_queryPerformers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPerformers(childComplexity, args["input"].(PerformerQueryInput)), true

	case "Query.queryScenes":
		if e.complexity.Query.QueryScenes == nil {
			break
		}

		args, err := ec.field_Query_queryScenes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryScenes(childComplexity, args["input"].(SceneQueryInput)), true

	case "Query.querySites":
		if e.complexity.Query.QuerySites == nil {
			break
		}

		return e.complexity.Query.QuerySites(childComplexity), true

	case "Query.queryStudios":
		if e.complexity.Query.QueryStudios == nil {
			break
		}

		args, err := ec.field_Query_queryStudios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryStudios(childComplexity, args["input"].(StudioQueryInput)), true

	case "Query.queryTagCategories":
		if e.complexity.Query.QueryTagCategories == nil {
			break
		}

		return e.complexity.Query.QueryTagCategories(childComplexity), true

	case "Query.queryTags":
		if e.complexity.Query.QueryTags == nil {
			break
		}

		args, err := ec.field_Query_queryTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryTags(childComplexity, args["input"].(TagQueryInput)), true

	case "Query.queryUsers":
		if e.complexity.Query.QueryUsers == nil {
			break
		}

		args, err := ec.field_Query_queryUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryUsers(childComplexity, args["input"].(UserQueryInput)), true

	case "Query.searchPerformer":
		if e.complexity.Query.SearchPerformer == nil {
			break
		}

		args, err := ec.field_Query_searchPerformer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchPerformer(childComplexity, args["term"].(string), args["limit"].(*int)), true

	case "Query.searchScene":
		if e.complexity.Query.SearchScene == nil {
			break
		}

		args, err := ec.field_Query_searchScene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchScene(childComplexity, args["term"].(string), args["limit"].(*int)), true

	case "Query.searchStudio":
		if e.complexity.Query.SearchStudio == nil {
			break
		}

		args, err := ec.field_Query_searchStudio_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchStudio(childComplexity, args["term"].(string), args["limit"].(*int)), true

	case "Query.searchTag":
		if e.complexity.Query.SearchTag == nil {
			break
		}

		args, err := ec.field_Query_searchTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchTag(childComplexity, args["term"].(string), args["limit"].(*int)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		return e.complexity.Query.Version(childComplexity), true

	case "QueryEditsResultType.count":
		if e.complexity.QueryEditsResultType.Count == nil {
			break
		}

		return e.complexity.QueryEditsResultType.Count(childComplexity), true

	case "QueryEditsResultType.edits":
		if e.complexity.QueryEditsResultType.Edits == nil {
			break
		}

		return e.complexity.QueryEditsResultType.Edits(childComplexity), true

	case "QueryExistingPerformerResult.edits":
		if e.complexity.QueryExistingPerformerResult.Edits == nil {
			break
		}

		return e.complexity.QueryExistingPerformerResult.Edits(childComplexity), true

	case "QueryExistingPerformerResult.performers":
		if e.complexity.QueryExistingPerformerResult.Performers == nil {
			break
		}

		return e.complexity.QueryExistingPerformerResult.Performers(childComplexity), true

	case "QueryExistingSceneResult.edits":
		if e.complexity.QueryExistingSceneResult.Edits == nil {
			break
		}

		return e.complexity.QueryExistingSceneResult.Edits(childComplexity), true

	case "QueryExistingSceneResult.scenes":
		if e.complexity.QueryExistingSceneResult.Scenes == nil {
			break
		}

		return e.complexity.QueryExistingSceneResult.Scenes(childComplexity), true

	case "QueryNotificationsResult.count":
		if e.complexity.QueryNotificationsResult.Count == nil {
			break
		}

		return e.complexity.QueryNotificationsResult.Count(childComplexity), true

	case "QueryNotificationsResult.notifications":
		if e.complexity.QueryNotificationsResult.Notifications == nil {
			break
		}

		return e.complexity.QueryNotificationsResult.Notifications(childComplexity), true

	case "QueryPerformersResultType.count":
		if e.complexity.QueryPerformersResultType.Count == nil {
			break
		}

		return e.complexity.QueryPerformersResultType.Count(childComplexity), true

	case "QueryPerformersResultType.performers":
		if e.complexity.QueryPerformersResultType.Performers == nil {
			break
		}

		return e.complexity.QueryPerformersResultType.Performers(childComplexity), true

	case "QueryScenesResultType.count":
		if e.complexity.QueryScenesResultType.Count == nil {
			break
		}

		return e.complexity.QueryScenesResultType.Count(childComplexity), true

	case "QueryScenesResultType.scenes":
		if e.complexity.QueryScenesResultType.Scenes == nil {
			break
		}

		return e.complexity.QueryScenesResultType.Scenes(childComplexity), true

	case "QuerySitesResultType.count":
		if e.complexity.QuerySitesResultType.Count == nil {
			break
		}

		return e.complexity.QuerySitesResultType.Count(childComplexity), true

	case "QuerySitesResultType.sites":
		if e.complexity.QuerySitesResultType.Sites == nil {
			break
		}

		return e.complexity.QuerySitesResultType.Sites(childComplexity), true

	case "QueryStudiosResultType.count":
		if e.complexity.QueryStudiosResultType.Count == nil {
			break
		}

		return e.complexity.QueryStudiosResultType.Count(childComplexity), true

	case "QueryStudiosResultType.studios":
		if e.complexity.QueryStudiosResultType.Studios == nil {
			break
		}

		return e.complexity.QueryStudiosResultType.Studios(childComplexity), true

	case "QueryTagCategoriesResultType.count":
		if e.complexity.QueryTagCategoriesResultType.Count == nil {
			break
		}

		return e.complexity.QueryTagCategoriesResultType.Count(childComplexity), true

	case "QueryTagCategoriesResultType.tag_categories":
		if e.complexity.QueryTagCategoriesResultType.TagCategories == nil {
			break
		}

		return e.complexity.QueryTagCategoriesResultType.TagCategories(childComplexity), true

	case "QueryTagsResultType.count":
		if e.complexity.QueryTagsResultType.Count == nil {
			break
		}

		return e.complexity.QueryTagsResultType.Count(childComplexity), true

	case "QueryTagsResultType.tags":
		if e.complexity.QueryTagsResultType.Tags == nil {
			break
		}

		return e.complexity.QueryTagsResultType.Tags(childComplexity), true

	case "QueryUsersResultType.count":
		if e.complexity.QueryUsersResultType.Count == nil {
			break
		}

		return e.complexity.QueryUsersResultType.Count(childComplexity), true

	case "QueryUsersResultType.users":
		if e.complexity.QueryUsersResultType.Users == nil {
			break
		}

		return e.complexity.QueryUsersResultType.Users(childComplexity), true

	case "Scene.code":
		if e.complexity.Scene.Code == nil {
			break
		}

		return e.complexity.Scene.Code(childComplexity), true

	case "Scene.created":
		if e.complexity.Scene.Created == nil {
			break
		}

		return e.complexity.Scene.Created(childComplexity), true

	case "Scene.date":
		if e.complexity.Scene.Date == nil {
			break
		}

		return e.complexity.Scene.Date(childComplexity), true

	case "Scene.deleted":
		if e.complexity.Scene.Deleted == nil {
			break
		}

		return e.complexity.Scene.Deleted(childComplexity), true

	case "Scene.details":
		if e.complexity.Scene.Details == nil {
			break
		}

		return e.complexity.Scene.Details(childComplexity), true

	case "Scene.director":
		if e.complexity.Scene.Director == nil {
			break
		}

		return e.complexity.Scene.Director(childComplexity), true

	case "Scene.duration":
		if e.complexity.Scene.Duration == nil {
			break
		}

		return e.complexity.Scene.Duration(childComplexity), true

	case "Scene.edits":
		if e.complexity.Scene.Edits == nil {
			break
		}

		return e.complexity.Scene.Edits(childComplexity), true

	case "Scene.fingerprints":
		if e.complexity.Scene.Fingerprints == nil {
			break
		}

		args, err := ec.field_Scene_fingerprints_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Scene.Fingerprints(childComplexity, args["is_submitted"].(*bool)), true

	case "Scene.id":
		if e.complexity.Scene.ID == nil {
			break
		}

		return e.complexity.Scene.ID(childComplexity), true

	case "Scene.images":
		if e.complexity.Scene.Images == nil {
			break
		}

		return e.complexity.Scene.Images(childComplexity), true

	case "Scene.performers":
		if e.complexity.Scene.Performers == nil {
			break
		}

		return e.complexity.Scene.Performers(childComplexity), true

	case "Scene.production_date":
		if e.complexity.Scene.ProductionDate == nil {
			break
		}

		return e.complexity.Scene.ProductionDate(childComplexity), true

	case "Scene.release_date":
		if e.complexity.Scene.ReleaseDate == nil {
			break
		}

		return e.complexity.Scene.ReleaseDate(childComplexity), true

	case "Scene.studio":
		if e.complexity.Scene.Studio == nil {
			break
		}

		return e.complexity.Scene.Studio(childComplexity), true

	case "Scene.tags":
		if e.complexity.Scene.Tags == nil {
			break
		}

		return e.complexity.Scene.Tags(childComplexity), true

	case "Scene.title":
		if e.complexity.Scene.Title == nil {
			break
		}

		return e.complexity.Scene.Title(childComplexity), true

	case "Scene.updated":
		if e.complexity.Scene.Updated == nil {
			break
		}

		return e.complexity.Scene.Updated(childComplexity), true

	case "Scene.urls":
		if e.complexity.Scene.Urls == nil {
			break
		}

		return e.complexity.Scene.Urls(childComplexity), true

	case "SceneDraft.code":
		if e.complexity.SceneDraft.Code == nil {
			break
		}

		return e.complexity.SceneDraft.Code(childComplexity), true

	case "SceneDraft.date":
		if e.complexity.SceneDraft.Date == nil {
			break
		}

		return e.complexity.SceneDraft.Date(childComplexity), true

	case "SceneDraft.details":
		if e.complexity.SceneDraft.Details == nil {
			break
		}

		return e.complexity.SceneDraft.Details(childComplexity), true

	case "SceneDraft.director":
		if e.complexity.SceneDraft.Director == nil {
			break
		}

		return e.complexity.SceneDraft.Director(childComplexity), true

	case "SceneDraft.fingerprints":
		if e.complexity.SceneDraft.Fingerprints == nil {
			break
		}

		return e.complexity.SceneDraft.Fingerprints(childComplexity), true

	case "SceneDraft.id":
		if e.complexity.SceneDraft.ID == nil {
			break
		}

		return e.complexity.SceneDraft.ID(childComplexity), true

	case "SceneDraft.image":
		if e.complexity.SceneDraft.Image == nil {
			break
		}

		return e.complexity.SceneDraft.Image(childComplexity), true

	case "SceneDraft.performers":
		if e.complexity.SceneDraft.Performers == nil {
			break
		}

		return e.complexity.SceneDraft.Performers(childComplexity), true

	case "SceneDraft.production_date":
		if e.complexity.SceneDraft.ProductionDate == nil {
			break
		}

		return e.complexity.SceneDraft.ProductionDate(childComplexity), true

	case "SceneDraft.studio":
		if e.complexity.SceneDraft.Studio == nil {
			break
		}

		return e.complexity.SceneDraft.Studio(childComplexity), true

	case "SceneDraft.tags":
		if e.complexity.SceneDraft.Tags == nil {
			break
		}

		return e.complexity.SceneDraft.Tags(childComplexity), true

	case "SceneDraft.title":
		if e.complexity.SceneDraft.Title == nil {
			break
		}

		return e.complexity.SceneDraft.Title(childComplexity), true

	case "SceneDraft.urls":
		if e.complexity.SceneDraft.URLs == nil {
			break
		}

		return e.complexity.SceneDraft.URLs(childComplexity), true

	case "SceneEdit.added_fingerprints":
		if e.complexity.SceneEdit.AddedFingerprints == nil {
			break
		}

		return e.complexity.SceneEdit.AddedFingerprints(childComplexity), true

	case "SceneEdit.added_images":
		if e.complexity.SceneEdit.AddedImages == nil {
			break
		}

		return e.complexity.SceneEdit.AddedImages(childComplexity), true

	case "SceneEdit.added_performers":
		if e.complexity.SceneEdit.AddedPerformers == nil {
			break
		}

		return e.complexity.SceneEdit.AddedPerformers(childComplexity), true

	case "SceneEdit.added_tags":
		if e.complexity.SceneEdit.AddedTags == nil {
			break
		}

		return e.complexity.SceneEdit.AddedTags(childComplexity), true

	case "SceneEdit.added_urls":
		if e.complexity.SceneEdit.AddedUrls == nil {
			break
		}

		return e.complexity.SceneEdit.AddedUrls(childComplexity), true

	case "SceneEdit.code":
		if e.complexity.SceneEdit.Code == nil {
			break
		}

		return e.complexity.SceneEdit.Code(childComplexity), true

	case "SceneEdit.date":
		if e.complexity.SceneEdit.Date == nil {
			break
		}

		return e.complexity.SceneEdit.Date(childComplexity), true

	case "SceneEdit.details":
		if e.complexity.SceneEdit.Details == nil {
			break
		}

		return e.complexity.SceneEdit.Details(childComplexity), true

	case "SceneEdit.director":
		if e.complexity.SceneEdit.Director == nil {
			break
		}

		return e.complexity.SceneEdit.Director(childComplexity), true

	case "SceneEdit.draft_id":
		if e.complexity.SceneEdit.DraftID == nil {
			break
		}

		return e.complexity.SceneEdit.DraftID(childComplexity), true

	case "SceneEdit.duration":
		if e.complexity.SceneEdit.Duration == nil {
			break
		}

		return e.complexity.SceneEdit.Duration(childComplexity), true

	case "SceneEdit.fingerprints":
		if e.complexity.SceneEdit.Fingerprints == nil {
			break
		}

		return e.complexity.SceneEdit.Fingerprints(childComplexity), true

	case "SceneEdit.images":
		if e.complexity.SceneEdit.Images == nil {
			break
		}

		return e.complexity.SceneEdit.Images(childComplexity), true

	case "SceneEdit.performers":
		if e.complexity.SceneEdit.Performers == nil {
			break
		}

		return e.complexity.SceneEdit.Performers(childComplexity), true

	case "SceneEdit.production_date":
		if e.complexity.SceneEdit.ProductionDate == nil {
			break
		}

		return e.complexity.SceneEdit.ProductionDate(childComplexity), true

	case "SceneEdit.removed_fingerprints":
		if e.complexity.SceneEdit.RemovedFingerprints == nil {
			break
		}

		return e.complexity.SceneEdit.RemovedFingerprints(childComplexity), true

	case "SceneEdit.removed_images":
		if e.complexity.SceneEdit.RemovedImages == nil {
			break
		}

		return e.complexity.SceneEdit.RemovedImages(childComplexity), true

	case "SceneEdit.removed_performers":
		if e.complexity.SceneEdit.RemovedPerformers == nil {
			break
		}

		return e.complexity.SceneEdit.RemovedPerformers(childComplexity), true

	case "SceneEdit.removed_tags":
		if e.complexity.SceneEdit.RemovedTags == nil {
			break
		}

		return e.complexity.SceneEdit.RemovedTags(childComplexity), true

	case "SceneEdit.removed_urls":
		if e.complexity.SceneEdit.RemovedUrls == nil {
			break
		}

		return e.complexity.SceneEdit.RemovedUrls(childComplexity), true

	case "SceneEdit.studio":
		if e.complexity.SceneEdit.Studio == nil {
			break
		}

		return e.complexity.SceneEdit.Studio(childComplexity), true

	case "SceneEdit.tags":
		if e.complexity.SceneEdit.Tags == nil {
			break
		}

		return e.complexity.SceneEdit.Tags(childComplexity), true

	case "SceneEdit.title":
		if e.complexity.SceneEdit.Title == nil {
			break
		}

		return e.complexity.SceneEdit.Title(childComplexity), true

	case "SceneEdit.urls":
		if e.complexity.SceneEdit.Urls == nil {
			break
		}

		return e.complexity.SceneEdit.Urls(childComplexity), true

	case "Site.created":
		if e.complexity.Site.Created == nil {
			break
		}

		return e.complexity.Site.Created(childComplexity), true

	case "Site.description":
		if e.complexity.Site.Description == nil {
			break
		}

		return e.complexity.Site.Description(childComplexity), true

	case "Site.id":
		if e.complexity.Site.ID == nil {
			break
		}

		return e.complexity.Site.ID(childComplexity), true

	case "Site.icon":
		if e.complexity.Site.Icon == nil {
			break
		}

		return e.complexity.Site.Icon(childComplexity), true

	case "Site.name":
		if e.complexity.Site.Name == nil {
			break
		}

		return e.complexity.Site.Name(childComplexity), true

	case "Site.regex":
		if e.complexity.Site.Regex == nil {
			break
		}

		return e.complexity.Site.Regex(childComplexity), true

	case "Site.url":
		if e.complexity.Site.URL == nil {
			break
		}

		return e.complexity.Site.URL(childComplexity), true

	case "Site.updated":
		if e.complexity.Site.Updated == nil {
			break
		}

		return e.complexity.Site.Updated(childComplexity), true

	case "Site.valid_types":
		if e.complexity.Site.ValidTypes == nil {
			break
		}

		return e.complexity.Site.ValidTypes(childComplexity), true

	case "StashBoxConfig.edit_update_limit":
		if e.complexity.StashBoxConfig.EditUpdateLimit == nil {
			break
		}

		return e.complexity.StashBoxConfig.EditUpdateLimit(childComplexity), true

	case "StashBoxConfig.guidelines_url":
		if e.complexity.StashBoxConfig.GuidelinesURL == nil {
			break
		}

		return e.complexity.StashBoxConfig.GuidelinesURL(childComplexity), true

	case "StashBoxConfig.host_url":
		if e.complexity.StashBoxConfig.HostURL == nil {
			break
		}

		return e.complexity.StashBoxConfig.HostURL(childComplexity), true

	case "StashBoxConfig.min_destructive_voting_period":
		if e.complexity.StashBoxConfig.MinDestructiveVotingPeriod == nil {
			break
		}

		return e.complexity.StashBoxConfig.MinDestructiveVotingPeriod(childComplexity), true

	case "StashBoxConfig.require_activation":
		if e.complexity.StashBoxConfig.RequireActivation == nil {
			break
		}

		return e.complexity.StashBoxConfig.RequireActivation(childComplexity), true

	case "StashBoxConfig.require_invite":
		if e.complexity.StashBoxConfig.RequireInvite == nil {
			break
		}

		return e.complexity.StashBoxConfig.RequireInvite(childComplexity), true

	case "StashBoxConfig.require_scene_draft":
		if e.complexity.StashBoxConfig.RequireSceneDraft == nil {
			break
		}

		return e.complexity.StashBoxConfig.RequireSceneDraft(childComplexity), true

	case "StashBoxConfig.vote_application_threshold":
		if e.complexity.StashBoxConfig.VoteApplicationThreshold == nil {
			break
		}

		return e.complexity.StashBoxConfig.VoteApplicationThreshold(childComplexity), true

	case "StashBoxConfig.vote_cron_interval":
		if e.complexity.StashBoxConfig.VoteCronInterval == nil {
			break
		}

		return e.complexity.StashBoxConfig.VoteCronInterval(childComplexity), true

	case "StashBoxConfig.vote_promotion_threshold":
		if e.complexity.StashBoxConfig.VotePromotionThreshold == nil {
			break
		}

		return e.complexity.StashBoxConfig.VotePromotionThreshold(childComplexity), true

	case "StashBoxConfig.voting_period":
		if e.complexity.StashBoxConfig.VotingPeriod == nil {
			break
		}

		return e.complexity.StashBoxConfig.VotingPeriod(childComplexity), true

	case "Studio.aliases":
		if e.complexity.Studio.Aliases == nil {
			break
		}

		return e.complexity.Studio.Aliases(childComplexity), true

	case "Studio.child_studios":
		if e.complexity.Studio.ChildStudios == nil {
			break
		}

		return e.complexity.Studio.ChildStudios(childComplexity), true

	case "Studio.created":
		if e.complexity.Studio.Created == nil {
			break
		}

		return e.complexity.Studio.Created(childComplexity), true

	case "Studio.deleted":
		if e.complexity.Studio.Deleted == nil {
			break
		}

		return e.complexity.Studio.Deleted(childComplexity), true

	case "Studio.id":
		if e.complexity.Studio.ID == nil {
			break
		}

		return e.complexity.Studio.ID(childComplexity), true

	case "Studio.images":
		if e.complexity.Studio.Images == nil {
			break
		}

		return e.complexity.Studio.Images(childComplexity), true

	case "Studio.is_favorite":
		if e.complexity.Studio.IsFavorite == nil {
			break
		}

		return e.complexity.Studio.IsFavorite(childComplexity), true

	case "Studio.name":
		if e.complexity.Studio.Name == nil {
			break
		}

		return e.complexity.Studio.Name(childComplexity), true

	case "Studio.parent":
		if e.complexity.Studio.Parent == nil {
			break
		}

		return e.complexity.Studio.Parent(childComplexity), true

	case "Studio.performers":
		if e.complexity.Studio.Performers == nil {
			break
		}

		args, err := ec.field_Studio_performers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Studio.Performers(childComplexity, args["input"].(PerformerQueryInput)), true

	case "Studio.updated":
		if e.complexity.Studio.Updated == nil {
			break
		}

		return e.complexity.Studio.Updated(childComplexity), true

	case "Studio.urls":
		if e.complexity.Studio.Urls == nil {
			break
		}

		return e.complexity.Studio.Urls(childComplexity), true

	case "StudioEdit.added_aliases":
		if e.complexity.StudioEdit.AddedAliases == nil {
			break
		}

		return e.complexity.StudioEdit.AddedAliases(childComplexity), true

	case "StudioEdit.added_images":
		if e.complexity.StudioEdit.AddedImages == nil {
			break
		}

		return e.complexity.StudioEdit.AddedImages(childComplexity), true

	case "StudioEdit.added_urls":
		if e.complexity.StudioEdit.AddedUrls == nil {
			break
		}

		return e.complexity.StudioEdit.AddedUrls(childComplexity), true

	case "StudioEdit.images":
		if e.complexity.StudioEdit.Images == nil {
			break
		}

		return e.complexity.StudioEdit.Images(childComplexity), true

	case "StudioEdit.name":
		if e.complexity.StudioEdit.Name == nil {
			break
		}

		return e.complexity.StudioEdit.Name(childComplexity), true

	case "StudioEdit.parent":
		if e.complexity.StudioEdit.Parent == nil {
			break
		}

		return e.complexity.StudioEdit.Parent(childComplexity), true

	case "StudioEdit.removed_aliases":
		if e.complexity.StudioEdit.RemovedAliases == nil {
			break
		}

		return e.complexity.StudioEdit.RemovedAliases(childComplexity), true

	case "StudioEdit.removed_images":
		if e.complexity.StudioEdit.RemovedImages == nil {
			break
		}

		return e.complexity.StudioEdit.RemovedImages(childComplexity), true

	case "StudioEdit.removed_urls":
		if e.complexity.StudioEdit.RemovedUrls == nil {
			break
		}

		return e.complexity.StudioEdit.RemovedUrls(childComplexity), true

	case "StudioEdit.urls":
		if e.complexity.StudioEdit.Urls == nil {
			break
		}

		return e.complexity.StudioEdit.Urls(childComplexity), true

	case "Tag.aliases":
		if e.complexity.Tag.Aliases == nil {
			break
		}

		return e.complexity.Tag.Aliases(childComplexity), true

	case "Tag.category":
		if e.complexity.Tag.Category == nil {
			break
		}

		return e.complexity.Tag.Category(childComplexity), true

	case "Tag.created":
		if e.complexity.Tag.Created == nil {
			break
		}

		return e.complexity.Tag.Created(childComplexity), true

	case "Tag.deleted":
		if e.complexity.Tag.Deleted == nil {
			break
		}

		return e.complexity.Tag.Deleted(childComplexity), true

	case "Tag.description":
		if e.complexity.Tag.Description == nil {
			break
		}

		return e.complexity.Tag.Description(childComplexity), true

	case "Tag.edits":
		if e.complexity.Tag.Edits == nil {
			break
		}

		return e.complexity.Tag.Edits(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.updated":
		if e.complexity.Tag.Updated == nil {
			break
		}

		return e.complexity.Tag.Updated(childComplexity), true

	case "TagCategory.description":
		if e.complexity.TagCategory.Description == nil {
			break
		}

		return e.complexity.TagCategory.Description(childComplexity), true

	case "TagCategory.group":
		if e.complexity.TagCategory.Group == nil {
			break
		}

		return e.complexity.TagCategory.Group(childComplexity), true

	case "TagCategory.id":
		if e.complexity.TagCategory.ID == nil {
			break
		}

		return e.complexity.TagCategory.ID(childComplexity), true

	case "TagCategory.name":
		if e.complexity.TagCategory.Name == nil {
			break
		}

		return e.complexity.TagCategory.Name(childComplexity), true

	case "TagEdit.added_aliases":
		if e.complexity.TagEdit.AddedAliases == nil {
			break
		}

		return e.complexity.TagEdit.AddedAliases(childComplexity), true

	case "TagEdit.aliases":
		if e.complexity.TagEdit.Aliases == nil {
			break
		}

		return e.complexity.TagEdit.Aliases(childComplexity), true

	case "TagEdit.category":
		if e.complexity.TagEdit.Category == nil {
			break
		}

		return e.complexity.TagEdit.Category(childComplexity), true

	case "TagEdit.description":
		if e.complexity.TagEdit.Description == nil {
			break
		}

		return e.complexity.TagEdit.Description(childComplexity), true

	case "TagEdit.name":
		if e.complexity.TagEdit.Name == nil {
			break
		}

		return e.complexity.TagEdit.Name(childComplexity), true

	case "TagEdit.removed_aliases":
		if e.complexity.TagEdit.RemovedAliases == nil {
			break
		}

		return e.complexity.TagEdit.RemovedAliases(childComplexity), true

	case "URL.site":
		if e.complexity.URL.Site == nil {
			break
		}

		return e.complexity.URL.Site(childComplexity), true

	case "URL.type":
		if e.complexity.URL.Type == nil {
			break
		}

		return e.complexity.URL.Type(childComplexity), true

	case "URL.url":
		if e.complexity.URL.URL == nil {
			break
		}

		return e.complexity.URL.URL(childComplexity), true

	case "UpdatedEdit.edit":
		if e.complexity.UpdatedEdit.Edit == nil {
			break
		}

		return e.complexity.UpdatedEdit.Edit(childComplexity), true

	case "User.api_calls":
		if e.complexity.User.APICalls == nil {
			break
		}

		return e.complexity.User.APICalls(childComplexity), true

	case "User.api_key":
		if e.complexity.User.APIKey == nil {
			break
		}

		return e.complexity.User.APIKey(childComplexity), true

	case "User.active_invite_codes":
		if e.complexity.User.ActiveInviteCodes == nil {
			break
		}

		return e.complexity.User.ActiveInviteCodes(childComplexity), true

	case "User.edit_count":
		if e.complexity.User.EditCount == nil {
			break
		}

		return e.complexity.User.EditCount(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.invite_codes":
		if e.complexity.User.InviteCodes == nil {
			break
		}

		return e.complexity.User.InviteCodes(childComplexity), true

	case "User.invite_tokens":
		if e.complexity.User.InviteTokens == nil {
			break
		}

		return e.complexity.User.InviteTokens(childComplexity), true

	case "User.invited_by":
		if e.complexity.User.InvitedBy == nil {
			break
		}

		return e.complexity.User.InvitedBy(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.notification_subscriptions":
		if e.complexity.User.NotificationSubscriptions == nil {
			break
		}

		return e.complexity.User.NotificationSubscriptions(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.vote_count":
		if e.complexity.User.VoteCount == nil {
			break
		}

		return e.complexity.User.VoteCount(childComplexity), true

	case "UserEditCount.accepted":
		if e.complexity.UserEditCount.Accepted == nil {
			break
		}

		return e.complexity.UserEditCount.Accepted(childComplexity), true

	case "UserEditCount.canceled":
		if e.complexity.UserEditCount.Canceled == nil {
			break
		}

		return e.complexity.UserEditCount.Canceled(childComplexity), true

	case "UserEditCount.failed":
		if e.complexity.UserEditCount.Failed == nil {
			break
		}

		return e.complexity.UserEditCount.Failed(childComplexity), true

	case "UserEditCount.immediate_accepted":
		if e.complexity.UserEditCount.ImmediateAccepted == nil {
			break
		}

		return e.complexity.UserEditCount.ImmediateAccepted(childComplexity), true

	case "UserEditCount.immediate_rejected":
		if e.complexity.UserEditCount.ImmediateRejected == nil {
			break
		}

		return e.complexity.UserEditCount.ImmediateRejected(childComplexity), true

	case "UserEditCount.pending":
		if e.complexity.UserEditCount.Pending == nil {
			break
		}

		return e.complexity.UserEditCount.Pending(childComplexity), true

	case "UserEditCount.rejected":
		if e.complexity.UserEditCount.Rejected == nil {
			break
		}

		return e.complexity.UserEditCount.Rejected(childComplexity), true

	case "UserVoteCount.abstain":
		if e.complexity.UserVoteCount.Abstain == nil {
			break
		}

		return e.complexity.UserVoteCount.Abstain(childComplexity), true

	case "UserVoteCount.accept":
		if e.complexity.UserVoteCount.Accept == nil {
			break
		}

		return e.complexity.UserVoteCount.Accept(childComplexity), true

	case "UserVoteCount.immediate_accept":
		if e.complexity.UserVoteCount.ImmediateAccept == nil {
			break
		}

		return e.complexity.UserVoteCount.ImmediateAccept(childComplexity), true

	case "UserVoteCount.immediate_reject":
		if e.complexity.UserVoteCount.ImmediateReject == nil {
			break
		}

		return e.complexity.UserVoteCount.ImmediateReject(childComplexity), true

	case "UserVoteCount.reject":
		if e.complexity.UserVoteCount.Reject == nil {
			break
		}

		return e.complexity.UserVoteCount.Reject(childComplexity), true

	case "Version.build_time":
		if e.complexity.Version.BuildTime == nil {
			break
		}

		return e.complexity.Version.BuildTime(childComplexity), true

	case "Version.build_type":
		if e.complexity.Version.BuildType == nil {
			break
		}

		return e.complexity.Version.BuildType(childComplexity), true

	case "Version.hash":
		if e.complexity.Version.Hash == nil {
			break
		}

		return e.complexity.Version.Hash(childComplexity), true

	case "Version.version":
		if e.complexity.Version.Version == nil {
			break
		}

		return e.complexity.Version.Version(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputActivateNewUserInput,
		ec.unmarshalInputApplyEditInput,
		ec.unmarshalInputBodyModificationCriterionInput,
		ec.unmarshalInputBodyModificationInput,
		ec.unmarshalInputBreastTypeCriterionInput,
		ec.unmarshalInputCancelEditInput,
		ec.unmarshalInputDateCriterionInput,
		ec.unmarshalInputDraftEntityInput,
		ec.unmarshalInputEditCommentInput,
		ec.unmarshalInputEditInput,
		ec.unmarshalInputEditQueryInput,
		ec.unmarshalInputEditVoteInput,
		ec.unmarshalInputEyeColorCriterionInput,
		ec.unmarshalInputFingerprintEditInput,
		ec.unmarshalInputFingerprintInput,
		ec.unmarshalInputFingerprintQueryInput,
		ec.unmarshalInputFingerprintSubmission,
		ec.unmarshalInputGenerateInviteCodeInput,
		ec.unmarshalInputGrantInviteInput,
		ec.unmarshalInputHairColorCriterionInput,
		ec.unmarshalInputIDCriterionInput,
		ec.unmarshalInputImageCreateInput,
		ec.unmarshalInputImageDestroyInput,
		ec.unmarshalInputImageUpdateInput,
		ec.unmarshalInputIntCriterionInput,
		ec.unmarshalInputMultiIDCriterionInput,
		ec.unmarshalInputMultiStringCriterionInput,
		ec.unmarshalInputNewUserInput,
		ec.unmarshalInputPerformerAppearanceInput,
		ec.unmarshalInputPerformerCreateInput,
		ec.unmarshalInputPerformerDestroyInput,
		ec.unmarshalInputPerformerDraftInput,
		ec.unmarshalInputPerformerEditDetailsInput,
		ec.unmarshalInputPerformerEditInput,
		ec.unmarshalInputPerformerEditOptionsInput,
		ec.unmarshalInputPerformerQueryInput,
		ec.unmarshalInputPerformerScenesInput,
		ec.unmarshalInputPerformerUpdateInput,
		ec.unmarshalInputQueryExistingPerformerInput,
		ec.unmarshalInputQueryExistingSceneInput,
		ec.unmarshalInputQueryNotificationsInput,
		ec.unmarshalInputResetPasswordInput,
		ec.unmarshalInputRevokeInviteInput,
		ec.unmarshalInputRoleCriterionInput,
		ec.unmarshalInputSceneCreateInput,
		ec.unmarshalInputSceneDestroyInput,
		ec.unmarshalInputSceneDraftInput,
		ec.unmarshalInputSceneEditDetailsInput,
		ec.unmarshalInputSceneEditInput,
		ec.unmarshalInputSceneQueryInput,
		ec.unmarshalInputSceneUpdateInput,
		ec.unmarshalInputSiteCreateInput,
		ec.unmarshalInputSiteDestroyInput,
		ec.unmarshalInputSiteUpdateInput,
		ec.unmarshalInputStringCriterionInput,
		ec.unmarshalInputStudioCreateInput,
		ec.unmarshalInputStudioDestroyInput,
		ec.unmarshalInputStudioEditDetailsInput,
		ec.unmarshalInputStudioEditInput,
		ec.unmarshalInputStudioQueryInput,
		ec.unmarshalInputStudioUpdateInput,
		ec.unmarshalInputTagCategoryCreateInput,
		ec.unmarshalInputTagCategoryDestroyInput,
		ec.unmarshalInputTagCategoryUpdateInput,
		ec.unmarshalInputTagCreateInput,
		ec.unmarshalInputTagDestroyInput,
		ec.unmarshalInputTagEditDetailsInput,
		ec.unmarshalInputTagEditInput,
		ec.unmarshalInputTagQueryInput,
		ec.unmarshalInputTagUpdateInput,
		ec.unmarshalInputURLInput,
		ec.unmarshalInputUserChangeEmailInput,
		ec.unmarshalInputUserChangePasswordInput,
		ec.unmarshalInputUserCreateInput,
		ec.unmarshalInputUserDestroyInput,
		ec.unmarshalInputUserQueryInput,
		ec.unmarshalInputUserUpdateInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../graphql/schema/types/config.graphql", Input: `type StashBoxConfig {
  host_url: String!
  require_invite: Boolean!
  require_activation: Boolean!
  vote_promotion_threshold: Int
  vote_application_threshold: Int!
  voting_period: Int!
  min_destructive_voting_period: Int!
  vote_cron_interval: String!
  guidelines_url: String!
  require_scene_draft: Boolean!
  edit_update_limit: Int!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/draft.graphql", Input: `type DraftSubmissionStatus {
  id: ID
}

type DraftEntity {
  name: String!
  id: ID
}

input DraftEntityInput {
  name: String!
  id: ID
}

type Draft {
  id: ID!
  created: Time!
  expires: Time!
  data: DraftData!
}

union DraftData = SceneDraft | PerformerDraft
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/edit.graphql", Input: `enum OperationEnum {
    CREATE
    MODIFY
    DESTROY
    MERGE
}

enum VoteTypeEnum {
    ABSTAIN
    ACCEPT
    REJECT
    """Immediately accepts the edit - bypassing the vote"""
    IMMEDIATE_ACCEPT
    """Immediately rejects the edit - bypassing the vote"""
    IMMEDIATE_REJECT
}

enum VoteStatusEnum {
    ACCEPTED
    REJECTED
    PENDING
    IMMEDIATE_ACCEPTED
    IMMEDIATE_REJECTED
    FAILED
    CANCELED
}

type EditVote {
    user: User
    date: Time!
    vote: VoteTypeEnum!
}

type EditComment {
    id: ID!
    user: User
    date: Time!
    comment: String!
    edit: Edit!
}

union EditDetails = PerformerEdit | SceneEdit | StudioEdit | TagEdit

enum TargetTypeEnum {
    SCENE
    STUDIO
    PERFORMER
    TAG
}

union EditTarget = Performer | Scene | Studio | Tag

type Edit {
    id: ID!
    user: User
    """Object being edited - null if creating a new object"""
    target: EditTarget
    target_type: TargetTypeEnum!
    """Objects to merge with the target. Only applicable to merges"""
    merge_sources: [EditTarget!]!
    operation: OperationEnum!
    bot: Boolean!
    details: EditDetails
    """Previous state of fields being modified - null if operation is create or delete."""
    old_details: EditDetails
    """Entity specific options"""
    options: PerformerEditOptions
    comments: [EditComment!]!
    votes: [EditVote!]!
    """ = Accepted - Rejected"""
    vote_count: Int!
    """Is the edit considered destructive."""
    destructive: Boolean!
    status: VoteStatusEnum!
    applied: Boolean!
    update_count: Int!
    updatable: Boolean!
    created: Time!
    updated: Time
    closed: Time
    expires: Time
}

input EditInput {
  """Not required for create type"""
  id: ID
  operation: OperationEnum!
  """Only required for merge type"""
  merge_source_ids: [ID!]
  comment: String
  """Edit submitted by an automated script. Requires bot permission"""
  bot: Boolean
}

input EditVoteInput {
    id: ID!
    vote: VoteTypeEnum!
}

input EditCommentInput {
    id: ID!
    comment: String!
}

type QueryEditsResultType {
  count: Int!
  edits: [Edit!]!
}

enum EditSortEnum {
  CREATED_AT
  UPDATED_AT
  CLOSED_AT
}

enum UserVotedFilterEnum {
    ABSTAIN
    ACCEPT
    REJECT
    NOT_VOTED
}

input EditQueryInput {
  """Filter by user id"""
  user_id: ID
  """Filter by status"""
  status: VoteStatusEnum
  """Filter by operation"""
  operation: OperationEnum
  """Filter by vote count"""
  vote_count: IntCriterionInput
  """Filter by applied status"""
  applied: Boolean
  """Filter by target type"""
  target_type: TargetTypeEnum
  """Filter by target id"""
  target_id: ID
  """Filter by favorite status"""
  is_favorite: Boolean
  """Filter by user voted status"""
  voted: UserVotedFilterEnum
  """Filter to bot edits only"""
  is_bot: Boolean
  """Filter out user's own edits"""
  include_user_submitted: Boolean

  page: Int! = 1
  per_page: Int! = 25
  direction: SortDirectionEnum! = DESC
  sort: EditSortEnum! = CREATED_AT
}

input ApplyEditInput {
    id: ID!
}
input CancelEditInput {
    id: ID!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/filter.graphql", Input: `input MultiIDCriterionInput {
  value: [ID!]
  modifier: CriterionModifier!
}

input IDCriterionInput {
  value: [ID!]!
  modifier: CriterionModifier!
}

input StringCriterionInput {
  value: String!
  modifier: CriterionModifier!
}

input MultiStringCriterionInput {
  value: [String!]!
  modifier: CriterionModifier!
}

input IntCriterionInput {
  value: Int!
  modifier: CriterionModifier!
}

input DateCriterionInput {
  value: Date!
  modifier: CriterionModifier!
}

enum CriterionModifier {
  """="""
  EQUALS,
  """!="""
  NOT_EQUALS,
  """>"""
  GREATER_THAN,
  """<"""
  LESS_THAN,
  """IS NULL"""
  IS_NULL,
  """IS NOT NULL"""
  NOT_NULL,
  """INCLUDES ALL"""
  INCLUDES_ALL,
  INCLUDES,
  EXCLUDES,
}`, BuiltIn: false},
	{Name: "../../graphql/schema/types/image.graphql", Input: `scalar Upload

type Image {
  id: ID!
  url: String!
  width: Int!
  height: Int!
}

input ImageCreateInput {
  url: String
  file: Upload
}

input ImageUpdateInput {
  id: ID!
  url: String
}

input ImageDestroyInput {
  id: ID!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/misc.graphql", Input: `scalar Date
scalar DateTime
scalar Time

enum DateAccuracyEnum {
  YEAR
  MONTH
  DAY
}

type FuzzyDate {
  date: Date!
  accuracy: DateAccuracyEnum!
}

enum SortDirectionEnum {
  ASC
  DESC
}

type URL {
  url: String!
  type: String! @deprecated(reason: "Use the site field instead")
  site: Site!
}

input URLInput {
  url: String!
  site_id: ID!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/notifications.graphql", Input: `type Notification {
  created: Time!
  read: Boolean!
  data: NotificationData!
}

enum NotificationEnum {
  FAVORITE_PERFORMER_SCENE
  FAVORITE_PERFORMER_EDIT
  FAVORITE_STUDIO_SCENE
  FAVORITE_STUDIO_EDIT
  COMMENT_OWN_EDIT
  DOWNVOTE_OWN_EDIT
  FAILED_OWN_EDIT
  COMMENT_COMMENTED_EDIT
  COMMENT_VOTED_EDIT
  UPDATED_EDIT
}

union NotificationData =
   | FavoritePerformerScene
   | FavoritePerformerEdit
   | FavoriteStudioScene 
   | FavoriteStudioEdit
   | CommentOwnEdit
   | CommentCommentedEdit
   | CommentVotedEdit
   | DownvoteOwnEdit
   | FailedOwnEdit
   | UpdatedEdit

type FavoritePerformerScene {
  scene: Scene!
}

type FavoritePerformerEdit {
  edit: Edit!
}

type FavoriteStudioScene {
  scene: Scene!
}

type FavoriteStudioEdit {
  edit: Edit!
}

type CommentOwnEdit {
  comment: EditComment!
}

type DownvoteOwnEdit {
  edit: Edit!
}

type FailedOwnEdit {
  edit: Edit!
}

type CommentCommentedEdit {
  comment: EditComment!
}

type CommentVotedEdit {
  comment: EditComment!
}

type UpdatedEdit {
  edit: Edit!
}

input QueryNotificationsInput {
  page: Int! = 1
  per_page: Int! = 25
  type: NotificationEnum
  unread_only: Boolean
}

type QueryNotificationsResult {
  count: Int!
  notifications: [Notification!]!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/performer.graphql", Input: `enum GenderEnum {
  MALE
  FEMALE
  TRANSGENDER_MALE
  TRANSGENDER_FEMALE
  INTERSEX
  NON_BINARY
}

enum GenderFilterEnum {
  UNKNOWN
  MALE
  FEMALE
  TRANSGENDER_MALE
  TRANSGENDER_FEMALE
  INTERSEX
  NON_BINARY
}

enum BreastTypeEnum {
  NATURAL
  FAKE
  NA
}

type Measurements {
  cup_size: String
  band_size: Int
  waist: Int
  hip: Int
}

enum EthnicityEnum {
  CAUCASIAN
  BLACK
  ASIAN
  INDIAN
  LATIN
  MIDDLE_EASTERN
  MIXED
  OTHER
}
enum EthnicityFilterEnum {
  UNKNOWN
  CAUCASIAN
  BLACK
  ASIAN
  INDIAN
  LATIN
  MIDDLE_EASTERN
  MIXED
  OTHER
}

enum EyeColorEnum {
  BLUE
  BROWN
  GREY
  GREEN
  HAZEL
  RED
}

enum HairColorEnum {
  BLONDE
  BRUNETTE
  BLACK
  RED
  AUBURN
  GREY
  BALD
  VARIOUS
  WHITE
  OTHER
}

type BodyModification {
  location: String!
  description: String
}

input BodyModificationInput {
  location: String!
  description: String
}

type Performer {
  id: ID!
  name: String!
  disambiguation: String
  aliases: [String!]!
  gender: GenderEnum
  urls: [URL!]!
  birthdate: FuzzyDate @deprecated(reason: "Please use ` + "`" + `birth_date` + "`" + `")
  birth_date: String
  death_date: String
  age: Int # resolver
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  """Height in cm"""
  height: Int
  measurements: Measurements! @deprecated(reason: "Use individual fields, cup/band/waist/hip_size")
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModification!]
  piercings: [BodyModification!]
  images: [Image!]!
  deleted: Boolean!
  edits: [Edit!]!
  scene_count: Int!
  scenes(input: PerformerScenesInput): [Scene!]!
  """IDs of performers that were merged into this one"""
  merged_ids: [ID!]!
  """ID of performer that replaces this one"""
  merged_into_id: ID
  studios: [PerformerStudio!]!
  is_favorite: Boolean!
  created: Time!
  updated: Time!
}

input PerformerScenesInput {
  """Filter by another performer that also performs in the scenes"""
  performed_with: ID

  """Filter by a studio"""
  studio_id: ID

  """Filter by tags"""
  tags: MultiIDCriterionInput
}

type PerformerStudio {
  studio: Studio!
  scene_count: Int!
}

input PerformerCreateInput {
  name: String!
  disambiguation: String
  aliases: [String!]
  gender: GenderEnum
  urls: [URLInput!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModificationInput!]
  piercings: [BodyModificationInput!]
  image_ids: [ID!]
  draft_id: ID
}

input PerformerUpdateInput {
  id: ID!
  name: String
  disambiguation: String
  aliases: [String!]
  gender: GenderEnum
  urls: [URLInput!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModificationInput!]
  piercings: [BodyModificationInput!]
  image_ids: [ID!]
}

input PerformerDestroyInput {
  id: ID!
}

input PerformerEditDetailsInput {
  name: String
  disambiguation: String
  aliases: [String!]
  gender: GenderEnum
  urls: [URLInput!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  tattoos: [BodyModificationInput!]
  piercings: [BodyModificationInput!]
  image_ids: [ID!]
  draft_id: ID
}

input PerformerEditOptionsInput {
  """Set performer alias on scenes without alias to old name if name is changed"""
  set_modify_aliases: Boolean = false
  """Set performer alias on scenes attached to merge sources to old name"""
  set_merge_aliases: Boolean = true
}

input PerformerEditInput {
  edit: EditInput!
  """Not required for destroy type"""
  details: PerformerEditDetailsInput
  """Controls aliases modification for merges and name modifications"""
  options: PerformerEditOptionsInput
}

type PerformerEdit {
  name: String
  disambiguation: String
  added_aliases: [String!]
  removed_aliases: [String!]
  gender: GenderEnum
  added_urls: [URL!]
  removed_urls: [URL!]
  birthdate: String
  deathdate: String
  ethnicity: EthnicityEnum
  country: String
  eye_color: EyeColorEnum
  hair_color: HairColorEnum
  """Height in cm"""
  height: Int
  cup_size: String
  band_size: Int
  waist_size: Int
  hip_size: Int
  breast_type: BreastTypeEnum
  career_start_year: Int
  career_end_year: Int
  added_tattoos: [BodyModification!]
  removed_tattoos: [BodyModification!]
  added_piercings: [BodyModification!]
  removed_piercings: [BodyModification!]
  added_images: [Image]
  removed_images: [Image]
  draft_id: ID

  aliases: [String!]!
  urls: [URL!]!
  images: [Image!]!
  tattoos: [BodyModification!]!
  piercings: [BodyModification!]!
}

type PerformerEditOptions {
  """Set performer alias on scenes without alias to old name if name is changed"""
  set_modify_aliases: Boolean!
  """Set performer alias on scenes attached to merge sources to old name"""
  set_merge_aliases: Boolean!
}

type QueryPerformersResultType {
  count: Int!
  performers: [Performer!]!
}

input BreastTypeCriterionInput {
  value: BreastTypeEnum
  modifier: CriterionModifier!
}

input EyeColorCriterionInput {
  value: EyeColorEnum
  modifier: CriterionModifier!
}

input HairColorCriterionInput {
  value: HairColorEnum
  modifier: CriterionModifier!
}

input BodyModificationCriterionInput {
  location: String
  description: String
  modifier: CriterionModifier!
}

enum PerformerSortEnum {
  NAME
  BIRTHDATE
  DEATHDATE
  SCENE_COUNT
  CAREER_START_YEAR
  DEBUT
  LAST_SCENE
  CREATED_AT
  UPDATED_AT
}

input PerformerQueryInput {
  """Searches name and disambiguation - assumes like query unless quoted"""
  names: String

  """Searches name only - assumes like query unless quoted"""
  name: String

  """Search aliases only - assumes like query unless quoted"""
  alias: String

  disambiguation: StringCriterionInput

  gender: GenderFilterEnum

  """Filter to search urls - assumes like query unless quoted"""
  url: String

  birthdate: DateCriterionInput
  deathdate: DateCriterionInput
  birth_year: IntCriterionInput
  age: IntCriterionInput

  ethnicity: EthnicityFilterEnum
  country: StringCriterionInput
  eye_color: EyeColorCriterionInput
  hair_color: HairColorCriterionInput
  height: IntCriterionInput

  cup_size: StringCriterionInput
  band_size: IntCriterionInput
  waist_size: IntCriterionInput
  hip_size: IntCriterionInput

  breast_type: BreastTypeCriterionInput

  career_start_year: IntCriterionInput
  career_end_year: IntCriterionInput
  tattoos: BodyModificationCriterionInput
  piercings: BodyModificationCriterionInput
  """Filter by performerfavorite status for the current user"""
  is_favorite: Boolean

  """Filter by a performer they have performed in scenes with"""
  performed_with: ID

  """Filter by a studio"""
  studio_id: ID

  page: Int! = 1
  per_page: Int! = 25
  direction: SortDirectionEnum! = DESC
  sort: PerformerSortEnum! = CREATED_AT
}

type PerformerDraft {
  id: ID
  name: String!
  disambiguation: String
  aliases: String
  gender: String
  birthdate: String
  deathdate: String
  urls: [String!]
  ethnicity: String
  country: String
  eye_color: String
  hair_color: String
  height: String
  measurements: String
  breast_type: String
  tattoos: String
  piercings: String
  career_start_year: Int
  career_end_year: Int
  image: Image
}

input PerformerDraftInput {
  id: ID
  disambiguation: String
  name: String!
  aliases: String
  gender: String
  birthdate: String
  deathdate: String
  urls: [String!]
  ethnicity: String
  country: String
  eye_color: String
  hair_color: String
  height: String
  measurements: String
  breast_type: String
  tattoos: String
  piercings: String
  career_start_year: Int
  career_end_year: Int
  image: Upload
}

input QueryExistingPerformerInput {
  name: String
  disambiguation: String
  urls: [String!]!
}

type QueryExistingPerformerResult {
  edits: [Edit!]!
  performers: [Performer!]!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/scene.graphql", Input: `type PerformerAppearance {
  performer: Performer!
  """Performing as alias"""
  as: String
}

input PerformerAppearanceInput {
  performer_id: ID!
  """Performing as alias"""
  as: String
}

enum FingerprintAlgorithm {
  MD5
  OSHASH
  PHASH
}

enum FavoriteFilter {
  PERFORMER
  STUDIO
  ALL
}

enum FingerprintSubmissionType {
  "Positive vote"
  VALID
  "Report as invalid"
  INVALID
  "Remove vote"
  REMOVE
}

type Fingerprint {
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
  "number of times this fingerprint has been submitted (excluding reports)"
  submissions: Int!
  "number of times this fingerprint has been reported"
  reports: Int!
  created: Time!
  updated: Time!
  "true if the current user submitted this fingerprint"
  user_submitted: Boolean!
  "true if the current user reported this fingerprint"
  user_reported: Boolean!
}

type DraftFingerprint {
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
}

input FingerprintInput {
  """assumes current user if omitted. Ignored for non-modify Users"""
  user_ids: [ID!]
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
}

input FingerprintEditInput {
  user_ids: [ID!]
  hash: String!
  algorithm: FingerprintAlgorithm!
  duration: Int!
  created: Time!
  submissions: Int @deprecated(reason: "Unused")
  updated: Time @deprecated(reason: "Unused")
}

input FingerprintQueryInput {
  hash: String!
  algorithm: FingerprintAlgorithm!
}

input FingerprintSubmission {
  scene_id: ID!
  fingerprint: FingerprintInput!
  unmatch: Boolean @deprecated(reason: "Use ` + "`" + `vote` + "`" + ` with REMOVE instead")
  vote: FingerprintSubmissionType = VALID
}

type Scene {
  id: ID!
  title: String
  details: String
  date: String @deprecated(reason: "Please use ` + "`" + `release_date` + "`" + ` instead")
  release_date: String
  production_date: String
  urls: [URL!]!
  studio: Studio
  tags: [Tag!]!
  images: [Image!]!
  performers: [PerformerAppearance!]!
  fingerprints(is_submitted: Boolean = False): [Fingerprint!]!
  duration: Int
  director: String
  code: String
  deleted: Boolean!
  edits: [Edit!]!
  created: Time!
  updated: Time!
}

input SceneCreateInput {
  title: String
  details: String
  urls: [URLInput!]
  date: String!
  production_date: String
  studio_id: ID
  performers: [PerformerAppearanceInput!]
  tag_ids: [ID!]
  image_ids: [ID!]
  fingerprints: [FingerprintEditInput!]!
  duration: Int
  director: String
  code: String
}

input SceneUpdateInput {
  id: ID!
  title: String
  details: String
  urls: [URLInput!]
  date: String
  production_date: String
  studio_id: ID
  performers: [PerformerAppearanceInput!]
  tag_ids: [ID!]
  image_ids: [ID!]
  fingerprints: [FingerprintEditInput!]
  duration: Int
  director: String
  code: String
}

input SceneDestroyInput {
  id: ID!
}

input SceneEditDetailsInput {
  title: String
  details: String
  urls: [URLInput!]
  date: String
  production_date: String
  studio_id: ID
  performers: [PerformerAppearanceInput!]
  tag_ids: [ID!]
  image_ids: [ID!]
  duration: Int
  director: String
  code: String
  fingerprints: [FingerprintInput!]
  draft_id: ID
}

input SceneEditInput {
  edit: EditInput!
  """Not required for destroy type"""
  details: SceneEditDetailsInput
}

type SceneEdit {
  title: String
  details: String
  added_urls: [URL!]
  removed_urls: [URL!]
  date: String
  production_date: String
  studio: Studio
  """Added or modified performer appearance entries"""
  added_performers: [PerformerAppearance!]
  removed_performers: [PerformerAppearance!]
  added_tags: [Tag!]
  removed_tags: [Tag!]
  added_images: [Image]
  removed_images: [Image]
  added_fingerprints: [Fingerprint!]
  removed_fingerprints: [Fingerprint!]
  duration: Int
  director: String
  code: String
  draft_id: ID

  urls: [URL!]!
  performers: [PerformerAppearance!]!
  tags: [Tag!]!
  images: [Image!]!
  fingerprints: [Fingerprint!]!
}

type QueryScenesResultType {
  count: Int!
  scenes: [Scene!]!
}

enum SceneSortEnum {
  TITLE
  DATE
  TRENDING
  CREATED_AT
  UPDATED_AT
}

input SceneQueryInput {
  """Filter to search title and details - assumes like query unless quoted"""
  text: String
  """Filter to search title - assumes like query unless quoted"""
  title: String
  """Filter to search urls - assumes like query unless quoted"""
  url: String
  """Filter by date"""
  date: DateCriterionInput
  """Filter by production date"""
  production_date: DateCriterionInput
  """Filter to only include scenes with this studio"""
  studios: MultiIDCriterionInput
  """Filter to only include scenes with this studio as primary or parent"""
  parentStudio: String
  """Filter to only include scenes with these tags"""
  tags: MultiIDCriterionInput
  """Filter to only include scenes with these performers"""
  performers: MultiIDCriterionInput
  """Filter to include scenes with performer appearing as alias"""
  alias: StringCriterionInput
  """Filter to only include scenes with these fingerprints"""
  fingerprints: MultiStringCriterionInput
  """Filter by favorited entity"""
  favorites: FavoriteFilter
  """Filter to scenes with fingerprints submitted by the user"""
  has_fingerprint_submissions: Boolean = False

  page: Int! = 1
  per_page: Int! = 25
  direction: SortDirectionEnum! = DESC
  sort: SceneSortEnum! = DATE
}

union SceneDraftStudio = Studio | DraftEntity
union SceneDraftPerformer = Performer | DraftEntity
union SceneDraftTag = Tag | DraftEntity

type SceneDraft {
  id: ID
  title: String
  code: String
  details: String
  director: String
  urls: [String!]
  date: String
  production_date: String
  studio: SceneDraftStudio
  performers: [SceneDraftPerformer!]!
  tags: [SceneDraftTag!]
  image: Image
  fingerprints: [DraftFingerprint!]!
}

input SceneDraftInput {
  id: ID
  title: String
  code: String
  details: String
  director: String
  url: String @deprecated(reason: "Use urls field instead.")
  urls: [String!]
  date: String
  production_date: String
  studio: DraftEntityInput
  performers: [DraftEntityInput!]!
  tags: [DraftEntityInput!]
  image: Upload
  fingerprints: [FingerprintInput!]!
}

input QueryExistingSceneInput {
  title: String
  studio_id: ID
  fingerprints: [FingerprintInput!]!
}

type QueryExistingSceneResult {
  edits: [Edit!]!
  scenes: [Scene!]!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/site.graphql", Input: `type Site {
  id: ID!
  name: String!
  description:  String
  url:  String
  regex:  String
  valid_types: [ValidSiteTypeEnum!]!
  icon: String!
  created: Time!
  updated: Time!
}

input SiteCreateInput {
  name: String!
  description: String
  url: String
  regex: String
  valid_types: [ValidSiteTypeEnum!]!
}

input SiteUpdateInput {
  id: ID!
  name: String!
  description: String
  url: String
  regex: String
  valid_types: [ValidSiteTypeEnum!]!
}

input SiteDestroyInput {
  id: ID!
}

type QuerySitesResultType {
  count: Int!
  sites: [Site!]!
}

enum ValidSiteTypeEnum {
  PERFORMER
  SCENE
  STUDIO
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/studio.graphql", Input: `type Studio {
  id: ID!
  name: String!
  aliases: [String!]!
  urls: [URL!]!
  parent: Studio
  child_studios: [Studio!]!
  images: [Image!]!
  deleted: Boolean!
  is_favorite: Boolean!
  created: Time!
  updated: Time!

  performers(input: PerformerQueryInput!): QueryPerformersResultType!
}

input StudioCreateInput {
  name: String!
  aliases: [String!]
  urls: [URLInput!]
  parent_id: ID
  image_ids: [ID!]
}

input StudioUpdateInput {
  id: ID!
  name: String
  aliases: [String!]
  urls: [URLInput!]
  parent_id: ID
  image_ids: [ID!]
}

input StudioDestroyInput {
  id: ID!
}

input StudioEditDetailsInput {
  name: String
  aliases: [String!]
  urls: [URLInput!]
  parent_id: ID
  image_ids: [ID!]
}

input StudioEditInput {
  edit: EditInput!
  """Not required for destroy type"""
  details: StudioEditDetailsInput
}

type StudioEdit {
  name: String
  """Added and modified URLs"""
  added_urls: [URL!]
  removed_urls: [URL!]
  parent: Studio
  added_images: [Image]
  removed_images: [Image]
  added_aliases: [String!]
  removed_aliases: [String!]

  images: [Image!]!
  urls: [URL!]!
}

type QueryStudiosResultType {
  count: Int!
  studios: [Studio!]!
}

enum StudioSortEnum {
  NAME
  CREATED_AT
  UPDATED_AT
}

input StudioQueryInput {
  """Filter to search name - assumes like query unless quoted"""
  name: String
  """Filter to search studio name, aliases and parent studio name - assumes like query unless quoted"""
  names: String
  """Filter to search url - assumes like query unless quoted"""
  url: String
  parent: IDCriterionInput
  has_parent: Boolean
  """Filter by studio favorite status for the current user"""
  is_favorite: Boolean

  page: Int! = 1
  per_page: Int! = 25
  direction: SortDirectionEnum! = ASC
  sort: StudioSortEnum! = NAME
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/tag.graphql", Input: `enum TagGroupEnum {
  PEOPLE
  SCENE
  ACTION
}

type Tag {
  id: ID!
  name: String!
  description: String
  aliases: [String!]!
  deleted: Boolean!
  edits: [Edit!]!
  category: TagCategory
  created: Time!
  updated: Time!
}

input TagCreateInput {
  name: String!
  description: String
  aliases: [String!]
  category_id: ID
}

input TagUpdateInput {
  id: ID!
  name: String
  description: String
  aliases: [String!]
  category_id: ID
}

input TagDestroyInput {
  id: ID!
}

input TagEditDetailsInput {
  name: String
  description: String
  aliases: [String!]
  category_id: ID
}

input TagEditInput {
  edit: EditInput!
  """Not required for destroy type"""
  details: TagEditDetailsInput
}

type TagEdit {
  name: String
  description: String
  added_aliases: [String!]
  removed_aliases: [String!]
  category: TagCategory

  aliases: [String!]!
}

type QueryTagsResultType {
  count: Int!
  tags: [Tag!]!
}

type QueryTagCategoriesResultType {
  count: Int!
  tag_categories: [TagCategory!]!
}

enum TagSortEnum {
  NAME
  CREATED_AT
  UPDATED_AT
}

input TagQueryInput {
  """Filter to search name, aliases and description - assumes like query unless quoted"""
  text: String
  """Searches name and aliases - assumes like query unless quoted"""
  names: String
  """Filter to search name - assumes like query unless quoted"""
  name: String
  """Filter to category ID"""
  category_id: ID

  page: Int! = 1
  per_page: Int! = 25
  direction: SortDirectionEnum! = ASC
  sort: TagSortEnum! = NAME
}

type TagCategory {
  id: ID!
  name: String!
  group:  TagGroupEnum!
  description: String
}

input TagCategoryCreateInput {
  name: String!
  group:  TagGroupEnum!
  description: String
}

input TagCategoryUpdateInput {
  id: ID!
  name: String
  group:  TagGroupEnum
  description: String
}

input TagCategoryDestroyInput {
  id: ID!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/user.graphql", Input: `directive @isUserOwner on FIELD_DEFINITION
directive @hasRole(role: RoleEnum!) on FIELD_DEFINITION

enum RoleEnum {
  READ
  VOTE
  EDIT
  MODIFY
  ADMIN
  """May generate invites without tokens"""
  INVITE
  """May grant and rescind invite tokens and resind invite keys"""
  MANAGE_INVITES
  BOT
}

type InviteKey {
  id: ID!
  uses: Int
  expires: Time
}

type User {
  id: ID!
  name: String!
  """Should not be visible to other users"""
  roles: [RoleEnum!] @isUserOwner
  """Should not be visible to other users"""
  email: String @isUserOwner
  """Should not be visible to other users"""
  api_key: String @isUserOwner
  notification_subscriptions: [NotificationEnum!]! @isUserOwner

  """ Vote counts by type """
  vote_count: UserVoteCount!
  """ Edit counts by status """
  edit_count: UserEditCount!

  """Calls to the API from this user over a configurable time period"""
  api_calls: Int! @isUserOwner
  invited_by: User @isUserOwner
  invite_tokens: Int @isUserOwner
  active_invite_codes: [String!] @isUserOwner @deprecated(reason: "Use invite_codes instead")
  invite_codes: [InviteKey!] @isUserOwner
}

input UserCreateInput {
  name: String!
  """Password in plain text"""
  password: String!
  roles: [RoleEnum!]!
  email: String!
  invited_by_id: ID
}

input UserUpdateInput {
  id: ID!
  name: String
  """Password in plain text"""
  password: String
  roles: [RoleEnum!]
  email: String
}

input NewUserInput {
  email: String!
  invite_key: ID 
}

input ActivateNewUserInput {
  name: String!
  activation_key: ID!
  password: String!
}

input ResetPasswordInput {
  email: String!
}

input UserChangePasswordInput {
  """Password in plain text"""
  existing_password: String
  new_password: String!
  reset_key: ID
}

input UserDestroyInput {
    id: ID!
}

input GrantInviteInput {
  user_id: ID!
  amount: Int!
}

input RevokeInviteInput {
  user_id: ID!
  amount: Int!
}

type QueryUsersResultType {
  count: Int!
  users: [User!]!
}

input RoleCriterionInput {
  value: [RoleEnum!]!
  modifier: CriterionModifier!
}

input UserQueryInput {
  """Filter to search user name - assumes like query unless quoted"""
  name: String
  """Filter to search email - assumes like query unless quoted"""
  email: String
  """Filter by roles"""
  roles: RoleCriterionInput
  """Filter by api key"""
  apiKey: String

  """Filter by successful edits"""
  successful_edits: IntCriterionInput
  """Filter by unsuccessful edits"""
  unsuccessful_edits: IntCriterionInput
  """Filter by votes on successful edits"""
  successful_votes: IntCriterionInput
  """Filter by votes on unsuccessful edits"""
  unsuccessful_votes: IntCriterionInput
  """Filter by number of API calls"""
  api_calls: IntCriterionInput
  """Filter by user that invited"""
  invited_by: ID

  page: Int! = 1
  per_page: Int! = 25
}

type UserEditCount {
  accepted: Int!
  rejected: Int!
  pending: Int!
  immediate_accepted: Int!
  immediate_rejected: Int!
  failed: Int!
  canceled: Int!
}

type UserVoteCount {
  abstain: Int!
  accept: Int!
  reject: Int!
  immediate_accept: Int!
  immediate_reject: Int!
}

input GenerateInviteCodeInput {
  # the number of invite keys to generate. If not set, a single invite key will be generated
  keys: Int
  # the number of uses for each invite key. If not set, the invite key will have one use
  uses: Int
  # the number of seconds until the invite code expires. If not set, the invite code will never expire
  ttl: Int
}

input UserChangeEmailInput {
  existing_email_token: ID
  new_email_token: ID
  new_email: String
}

enum UserChangeEmailStatus {
  CONFIRM_OLD
  CONFIRM_NEW
  EXPIRED
  INVALID_TOKEN
  SUCCESS
  ERROR
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/types/version.graphql", Input: `type Version {
  hash: String!
  build_time: String!
  build_type: String!
  version: String!
}
`, BuiltIn: false},
	{Name: "../../graphql/schema/schema.graphql", Input: `"""The query root for this schema"""
type Query {
  #### Performers ####

  # performer names may not be unique
  """Find a performer by ID"""
  findPerformer(id: ID!): Performer @hasRole(role: READ)
  queryPerformers(input: PerformerQueryInput!): QueryPerformersResultType! @hasRole(role: READ)

  #### Studios ####

  # studio names should be unique
  """Find a studio by ID or name"""
  findStudio(id: ID, name: String): Studio @hasRole(role: READ)
  queryStudios(input: StudioQueryInput!): QueryStudiosResultType! @hasRole(role: READ)

  #### Tags ####

  # tag names will be unique
  """Find a tag by ID or name"""
  findTag(id: ID, name: String): Tag @hasRole(role: READ)
  """Find a tag with a matching name or alias"""
  findTagOrAlias(name: String!): Tag @hasRole(role: READ)
  queryTags(input: TagQueryInput!): QueryTagsResultType! @hasRole(role: READ)

  """Find a tag category by ID"""
  findTagCategory(id: ID!): TagCategory @hasRole(role: READ)
  queryTagCategories: QueryTagCategoriesResultType! @hasRole(role: READ)

  #### Scenes ####

  # ids should be unique
  """Find a scene by ID"""
  findScene(id: ID!): Scene @hasRole(role: READ)

  """Finds a scene by an algorithm-specific checksum"""
  findSceneByFingerprint(fingerprint: FingerprintQueryInput!): [Scene!]! @hasRole(role: READ)
  """Finds scenes that match a list of hashes"""
  findScenesByFingerprints(fingerprints: [String!]!): [Scene!]! @hasRole(role: READ) @deprecated(reason: "Use findScenesBySceneFingerprints")
  findScenesByFullFingerprints(fingerprints: [FingerprintQueryInput!]!): [Scene!]! @hasRole(role: READ) @deprecated(reason: "Use findScenesBySceneFingerprints")
  findScenesBySceneFingerprints(fingerprints: [[FingerprintQueryInput!]!]!): [[Scene!]!]! @hasRole(role: READ)
  queryScenes(input: SceneQueryInput!): QueryScenesResultType! @hasRole(role: READ)

  """Find an external site by ID"""
  findSite(id: ID!): Site @hasRole(role: READ)
  querySites: QuerySitesResultType! @hasRole(role: READ)

  #### Edits ####

  findEdit(id: ID!): Edit @hasRole(role: READ)
  queryEdits(input: EditQueryInput!): QueryEditsResultType! @hasRole(role: READ)

  #### Users ####

  """Find user by ID or username"""
  findUser(id: ID, username: String): User @hasRole(role: READ)
  queryUsers(input: UserQueryInput!): QueryUsersResultType! @hasRole(role: ADMIN)

  """Returns currently authenticated user"""
  me: User

  ### Full text search ###
  searchPerformer(term: String!, limit: Int): [Performer!]! @hasRole(role: READ)
  searchScene(term: String!, limit: Int): [Scene!]! @hasRole(role: READ)
  searchTag(term: String!, limit: Int): [Tag!]! @hasRole(role: READ)
  searchStudio(term: String!, limit: Int): [Studio!]! @hasRole(role: READ)

  ### Drafts ###
  findDraft(id: ID!): Draft @hasRole(role: READ)
  findDrafts: [Draft!]! @hasRole(role: READ)

  ###Find scenes or pending scenes which match scene input###
  queryExistingScene(input: QueryExistingSceneInput!): QueryExistingSceneResult! @hasRole(role: READ)

  ###Find performers or pending performers which match performer input###
  queryExistingPerformer(input: QueryExistingPerformerInput!): QueryExistingPerformerResult! @hasRole(role: READ)

  #### Version ####
  version: Version! @hasRole(role: READ)

  ### Instance Config ###
  getConfig: StashBoxConfig!

  queryNotifications(input: QueryNotificationsInput!): QueryNotificationsResult! @hasRole(role: READ)
  getUnreadNotificationCount: Int! @hasRole(role: READ)
}

type Mutation {
  # Admin-only interface
  sceneCreate(input: SceneCreateInput!): Scene @hasRole(role: MODIFY)
  sceneUpdate(input: SceneUpdateInput!): Scene @hasRole(role: MODIFY)
  sceneDestroy(input: SceneDestroyInput!): Boolean! @hasRole(role: MODIFY)

  performerCreate(input: PerformerCreateInput!): Performer @hasRole(role: MODIFY)
  performerUpdate(input: PerformerUpdateInput!): Performer @hasRole(role: MODIFY)
  performerDestroy(input: PerformerDestroyInput!): Boolean! @hasRole(role: MODIFY)

  studioCreate(input: StudioCreateInput!): Studio @hasRole(role: MODIFY)
  studioUpdate(input: StudioUpdateInput!): Studio @hasRole(role: MODIFY)
  studioDestroy(input: StudioDestroyInput!): Boolean! @hasRole(role: MODIFY)

  tagCreate(input: TagCreateInput!): Tag @hasRole(role: MODIFY)
  tagUpdate(input: TagUpdateInput!): Tag @hasRole(role: MODIFY)
  tagDestroy(input: TagDestroyInput!): Boolean! @hasRole(role: MODIFY)

  userCreate(input: UserCreateInput!): User @hasRole(role: ADMIN)
  userUpdate(input: UserUpdateInput!): User @hasRole(role: ADMIN)
  userDestroy(input: UserDestroyInput!): Boolean! @hasRole(role: ADMIN)

  imageCreate(input: ImageCreateInput!): Image @hasRole(role: EDIT)
  imageDestroy(input: ImageDestroyInput!): Boolean! @hasRole(role: MODIFY)

  """User interface for registering"""
  newUser(input: NewUserInput!): ID
  activateNewUser(input: ActivateNewUserInput!): User

  generateInviteCode: ID @deprecated(reason: "Use generateInviteCodes")
  """Generates an invite code using an invite token"""
  generateInviteCodes(input: GenerateInviteCodeInput): [ID!]!
  """Removes a pending invite code - refunding the token"""
  rescindInviteCode(code: ID!): Boolean!
  """Adds invite tokens for a user"""
  grantInvite(input: GrantInviteInput!): Int!
  """Removes invite tokens from a user"""
  revokeInvite(input: RevokeInviteInput!): Int!

  tagCategoryCreate(input: TagCategoryCreateInput!): TagCategory @hasRole(role: ADMIN)
  tagCategoryUpdate(input: TagCategoryUpdateInput!): TagCategory @hasRole(role: ADMIN)
  tagCategoryDestroy(input: TagCategoryDestroyInput!): Boolean! @hasRole(role: ADMIN)

  siteCreate(input: SiteCreateInput!): Site @hasRole(role: ADMIN)
  siteUpdate(input: SiteUpdateInput!): Site @hasRole(role: ADMIN)
  siteDestroy(input: SiteDestroyInput!): Boolean! @hasRole(role: ADMIN)

  """Regenerates the api key for the given user, or the current user if id not provided"""
  regenerateAPIKey(userID: ID): String!

  """Generates an email to reset a user password"""
  resetPassword(input: ResetPasswordInput!): Boolean!

  """Changes the password for the current user"""
  changePassword(input: UserChangePasswordInput!): Boolean!

  """Request an email change for the current user"""
  requestChangeEmail: UserChangeEmailStatus! @hasRole(role: READ)
  validateChangeEmail(token: ID!, email: String!): UserChangeEmailStatus! @hasRole(role: READ)
  confirmChangeEmail(token: ID!): UserChangeEmailStatus! @hasRole(role: READ)

  # Edit interfaces
  """Propose a new scene or modification to a scene"""
  sceneEdit(input: SceneEditInput!): Edit! @hasRole(role: EDIT)
  """Propose a new performer or modification to a performer"""
  performerEdit(input: PerformerEditInput!): Edit! @hasRole(role: EDIT)
  """Propose a new studio or modification to a studio"""
  studioEdit(input: StudioEditInput!): Edit! @hasRole(role: EDIT)
  """Propose a new tag or modification to a tag"""
  tagEdit(input: TagEditInput!): Edit! @hasRole(role: EDIT)

  """Update a pending scene edit"""
  sceneEditUpdate(id: ID!, input: SceneEditInput!): Edit! @hasRole(role: EDIT)
  """Update a pending performer edit"""
  performerEditUpdate(id: ID!, input: PerformerEditInput!): Edit! @hasRole(role: EDIT)
  """Update a pending studio edit"""
  studioEditUpdate(id: ID!, input: StudioEditInput!): Edit! @hasRole(role: EDIT)
  """Update a pending tag edit"""
  tagEditUpdate(id: ID!, input: TagEditInput!): Edit! @hasRole(role: EDIT)

  """Vote to accept/reject an edit"""
  editVote(input: EditVoteInput!): Edit! @hasRole(role: VOTE)
  """Comment on an edit"""
  editComment(input: EditCommentInput!): Edit! @hasRole(role: EDIT)
  """Apply edit without voting"""
  applyEdit(input: ApplyEditInput!): Edit! @hasRole(role: ADMIN)
  """Cancel edit without voting"""
  cancelEdit(input: CancelEditInput!): Edit! @hasRole(role: EDIT)

  """Matches/unmatches a scene to fingerprint"""
  submitFingerprint(input: FingerprintSubmission!): Boolean! @hasRole(role: READ)

  """Draft submissions"""
  submitSceneDraft(input: SceneDraftInput!): DraftSubmissionStatus! @hasRole(role: EDIT)
  submitPerformerDraft(input: PerformerDraftInput!): DraftSubmissionStatus! @hasRole(role: EDIT)
  destroyDraft(id: ID!): Boolean! @hasRole(role: EDIT)

  """Favorite or unfavorite a performer"""
  favoritePerformer(id: ID!, favorite: Boolean!): Boolean! @hasRole(role: READ)
  """Favorite or unfavorite a studio"""
  favoriteStudio(id: ID!, favorite: Boolean!): Boolean! @hasRole(role: READ)

  """Mark all of the current users notifications as read."""
  markNotificationsRead: Boolean! @hasRole(role: READ)
  """Update notification subscriptions for current user."""
  updateNotificationSubscriptions(subscriptions: [NotificationEnum!]!): Boolean! @hasRole(role: EDIT)
}

schema {
  query: Query
  mutation: Mutation
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.dir_hasRole_argsRole(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["role"] = arg0
	return args, nil
}
func (ec *executionContext) dir_hasRole_argsRole(
	ctx context.Context,
	rawArgs map[string]interface{},
) (RoleEnum, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["role"]
	if !ok {
		var zeroVal RoleEnum
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
	if tmp, ok := rawArgs["role"]; ok {
		return ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, tmp)
	}

	var zeroVal RoleEnum
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_activateNewUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_activateNewUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_activateNewUser_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ActivateNewUserInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ActivateNewUserInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNActivateNewUserInput2githubcomstashappstashboxpkgmodelsActivateNewUserInput(ctx, tmp)
	}

	var zeroVal ActivateNewUserInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_applyEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_applyEdit_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_applyEdit_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ApplyEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ApplyEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNApplyEditInput2githubcomstashappstashboxpkgmodelsApplyEditInput(ctx, tmp)
	}

	var zeroVal ApplyEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_cancelEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_cancelEdit_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_cancelEdit_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (CancelEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal CancelEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCancelEditInput2githubcomstashappstashboxpkgmodelsCancelEditInput(ctx, tmp)
	}

	var zeroVal CancelEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_changePassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_changePassword_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_changePassword_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (UserChangePasswordInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal UserChangePasswordInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUserChangePasswordInput2githubcomstashappstashboxpkgmodelsUserChangePasswordInput(ctx, tmp)
	}

	var zeroVal UserChangePasswordInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_confirmChangeEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_confirmChangeEmail_argsToken(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["token"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_confirmChangeEmail_argsToken(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["token"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
	if tmp, ok := rawArgs["token"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_destroyDraft_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_destroyDraft_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_destroyDraft_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editComment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_editComment_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editComment_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (EditCommentInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal EditCommentInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNEditCommentInput2githubcomstashappstashboxpkgmodelsEditCommentInput(ctx, tmp)
	}

	var zeroVal EditCommentInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editVote_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_editVote_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editVote_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (EditVoteInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal EditVoteInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNEditVoteInput2githubcomstashappstashboxpkgmodelsEditVoteInput(ctx, tmp)
	}

	var zeroVal EditVoteInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_favoritePerformer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_favoritePerformer_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_favoritePerformer_argsFavorite(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["favorite"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_favoritePerformer_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_favoritePerformer_argsFavorite(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["favorite"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("favorite"))
	if tmp, ok := rawArgs["favorite"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_favoriteStudio_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_favoriteStudio_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_favoriteStudio_argsFavorite(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["favorite"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_favoriteStudio_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_favoriteStudio_argsFavorite(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["favorite"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("favorite"))
	if tmp, ok := rawArgs["favorite"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_generateInviteCodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_generateInviteCodes_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_generateInviteCodes_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*GenerateInviteCodeInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal *GenerateInviteCodeInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOGenerateInviteCodeInput2githubcomstashappstashboxpkgmodelsGenerateInviteCodeInput(ctx, tmp)
	}

	var zeroVal *GenerateInviteCodeInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_grantInvite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_grantInvite_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_grantInvite_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (GrantInviteInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal GrantInviteInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNGrantInviteInput2githubcomstashappstashboxpkgmodelsGrantInviteInput(ctx, tmp)
	}

	var zeroVal GrantInviteInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_imageCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_imageCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_imageCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ImageCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ImageCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNImageCreateInput2githubcomstashappstashboxpkgmodelsImageCreateInput(ctx, tmp)
	}

	var zeroVal ImageCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_imageDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_imageDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_imageDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ImageDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ImageDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNImageDestroyInput2githubcomstashappstashboxpkgmodelsImageDestroyInput(ctx, tmp)
	}

	var zeroVal ImageDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_newUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_newUser_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_newUser_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (NewUserInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal NewUserInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNewUserInput2githubcomstashappstashboxpkgmodelsNewUserInput(ctx, tmp)
	}

	var zeroVal NewUserInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_performerCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_performerCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_performerCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerCreateInput2githubcomstashappstashboxpkgmodelsPerformerCreateInput(ctx, tmp)
	}

	var zeroVal PerformerCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_performerDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_performerDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_performerDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerDestroyInput2githubcomstashappstashboxpkgmodelsPerformerDestroyInput(ctx, tmp)
	}

	var zeroVal PerformerDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_performerEditUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_performerEditUpdate_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_performerEditUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_performerEditUpdate_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_performerEditUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerEditInput2githubcomstashappstashboxpkgmodelsPerformerEditInput(ctx, tmp)
	}

	var zeroVal PerformerEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_performerEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_performerEdit_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_performerEdit_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerEditInput2githubcomstashappstashboxpkgmodelsPerformerEditInput(ctx, tmp)
	}

	var zeroVal PerformerEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_performerUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_performerUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_performerUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerUpdateInput2githubcomstashappstashboxpkgmodelsPerformerUpdateInput(ctx, tmp)
	}

	var zeroVal PerformerUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_regenerateAPIKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_regenerateAPIKey_argsUserID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["userID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_regenerateAPIKey_argsUserID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["userID"]
	if !ok {
		var zeroVal *uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
	if tmp, ok := rawArgs["userID"]; ok {
		return ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal *uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rescindInviteCode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_rescindInviteCode_argsCode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["code"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rescindInviteCode_argsCode(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["code"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
	if tmp, ok := rawArgs["code"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_resetPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_resetPassword_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_resetPassword_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ResetPasswordInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ResetPasswordInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNResetPasswordInput2githubcomstashappstashboxpkgmodelsResetPasswordInput(ctx, tmp)
	}

	var zeroVal ResetPasswordInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_revokeInvite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_revokeInvite_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_revokeInvite_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (RevokeInviteInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal RevokeInviteInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRevokeInviteInput2githubcomstashappstashboxpkgmodelsRevokeInviteInput(ctx, tmp)
	}

	var zeroVal RevokeInviteInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sceneCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_sceneCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_sceneCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneCreateInput2githubcomstashappstashboxpkgmodelsSceneCreateInput(ctx, tmp)
	}

	var zeroVal SceneCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sceneDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_sceneDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_sceneDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneDestroyInput2githubcomstashappstashboxpkgmodelsSceneDestroyInput(ctx, tmp)
	}

	var zeroVal SceneDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sceneEditUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_sceneEditUpdate_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_sceneEditUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_sceneEditUpdate_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sceneEditUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneEditInput2githubcomstashappstashboxpkgmodelsSceneEditInput(ctx, tmp)
	}

	var zeroVal SceneEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sceneEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_sceneEdit_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_sceneEdit_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneEditInput2githubcomstashappstashboxpkgmodelsSceneEditInput(ctx, tmp)
	}

	var zeroVal SceneEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sceneUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_sceneUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_sceneUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneUpdateInput2githubcomstashappstashboxpkgmodelsSceneUpdateInput(ctx, tmp)
	}

	var zeroVal SceneUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_siteCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_siteCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_siteCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SiteCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SiteCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSiteCreateInput2githubcomstashappstashboxpkgmodelsSiteCreateInput(ctx, tmp)
	}

	var zeroVal SiteCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_siteDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_siteDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_siteDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SiteDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SiteDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSiteDestroyInput2githubcomstashappstashboxpkgmodelsSiteDestroyInput(ctx, tmp)
	}

	var zeroVal SiteDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_siteUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_siteUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_siteUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SiteUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SiteUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSiteUpdateInput2githubcomstashappstashboxpkgmodelsSiteUpdateInput(ctx, tmp)
	}

	var zeroVal SiteUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_studioCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_studioCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_studioCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (StudioCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal StudioCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNStudioCreateInput2githubcomstashappstashboxpkgmodelsStudioCreateInput(ctx, tmp)
	}

	var zeroVal StudioCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_studioDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_studioDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_studioDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (StudioDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal StudioDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNStudioDestroyInput2githubcomstashappstashboxpkgmodelsStudioDestroyInput(ctx, tmp)
	}

	var zeroVal StudioDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_studioEditUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_studioEditUpdate_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_studioEditUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_studioEditUpdate_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_studioEditUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (StudioEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal StudioEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNStudioEditInput2githubcomstashappstashboxpkgmodelsStudioEditInput(ctx, tmp)
	}

	var zeroVal StudioEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_studioEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_studioEdit_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_studioEdit_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (StudioEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal StudioEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNStudioEditInput2githubcomstashappstashboxpkgmodelsStudioEditInput(ctx, tmp)
	}

	var zeroVal StudioEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_studioUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_studioUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_studioUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (StudioUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal StudioUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNStudioUpdateInput2githubcomstashappstashboxpkgmodelsStudioUpdateInput(ctx, tmp)
	}

	var zeroVal StudioUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_submitFingerprint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_submitFingerprint_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_submitFingerprint_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (FingerprintSubmission, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal FingerprintSubmission
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNFingerprintSubmission2githubcomstashappstashboxpkgmodelsFingerprintSubmission(ctx, tmp)
	}

	var zeroVal FingerprintSubmission
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_submitPerformerDraft_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_submitPerformerDraft_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_submitPerformerDraft_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerDraftInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerDraftInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerDraftInput2githubcomstashappstashboxpkgmodelsPerformerDraftInput(ctx, tmp)
	}

	var zeroVal PerformerDraftInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_submitSceneDraft_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_submitSceneDraft_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_submitSceneDraft_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneDraftInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneDraftInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneDraftInput2githubcomstashappstashboxpkgmodelsSceneDraftInput(ctx, tmp)
	}

	var zeroVal SceneDraftInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagCategoryCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagCategoryCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagCategoryCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagCategoryCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagCategoryCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagCategoryCreateInput2githubcomstashappstashboxpkgmodelsTagCategoryCreateInput(ctx, tmp)
	}

	var zeroVal TagCategoryCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagCategoryDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagCategoryDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagCategoryDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagCategoryDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagCategoryDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagCategoryDestroyInput2githubcomstashappstashboxpkgmodelsTagCategoryDestroyInput(ctx, tmp)
	}

	var zeroVal TagCategoryDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagCategoryUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagCategoryUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagCategoryUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagCategoryUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagCategoryUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagCategoryUpdateInput2githubcomstashappstashboxpkgmodelsTagCategoryUpdateInput(ctx, tmp)
	}

	var zeroVal TagCategoryUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagCreateInput2githubcomstashappstashboxpkgmodelsTagCreateInput(ctx, tmp)
	}

	var zeroVal TagCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagDestroyInput2githubcomstashappstashboxpkgmodelsTagDestroyInput(ctx, tmp)
	}

	var zeroVal TagDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagEditUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagEditUpdate_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_tagEditUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_tagEditUpdate_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagEditUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagEditInput2githubcomstashappstashboxpkgmodelsTagEditInput(ctx, tmp)
	}

	var zeroVal TagEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagEdit_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagEdit_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagEditInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagEditInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagEditInput2githubcomstashappstashboxpkgmodelsTagEditInput(ctx, tmp)
	}

	var zeroVal TagEditInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_tagUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_tagUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_tagUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagUpdateInput2githubcomstashappstashboxpkgmodelsTagUpdateInput(ctx, tmp)
	}

	var zeroVal TagUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateNotificationSubscriptions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_updateNotificationSubscriptions_argsSubscriptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["subscriptions"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateNotificationSubscriptions_argsSubscriptions(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([]NotificationEnum, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["subscriptions"]
	if !ok {
		var zeroVal []NotificationEnum
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
	if tmp, ok := rawArgs["subscriptions"]; ok {
		return ec.unmarshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx, tmp)
	}

	var zeroVal []NotificationEnum
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_userCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_userCreate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_userCreate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (UserCreateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal UserCreateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUserCreateInput2githubcomstashappstashboxpkgmodelsUserCreateInput(ctx, tmp)
	}

	var zeroVal UserCreateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_userDestroy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_userDestroy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_userDestroy_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (UserDestroyInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal UserDestroyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUserDestroyInput2githubcomstashappstashboxpkgmodelsUserDestroyInput(ctx, tmp)
	}

	var zeroVal UserDestroyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_userUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_userUpdate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_userUpdate_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (UserUpdateInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal UserUpdateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUserUpdateInput2githubcomstashappstashboxpkgmodelsUserUpdateInput(ctx, tmp)
	}

	var zeroVal UserUpdateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_validateChangeEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_validateChangeEmail_argsToken(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["token"] = arg0
	arg1, err := ec.field_Mutation_validateChangeEmail_argsEmail(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["email"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_validateChangeEmail_argsToken(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["token"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
	if tmp, ok := rawArgs["token"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_validateChangeEmail_argsEmail(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["email"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
	if tmp, ok := rawArgs["email"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Performer_scenes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Performer_scenes_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Performer_scenes_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*PerformerScenesInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal *PerformerScenesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalOPerformerScenesInput2githubcomstashappstashboxpkgmodelsPerformerScenesInput(ctx, tmp)
	}

	var zeroVal *PerformerScenesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findDraft_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findDraft_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findDraft_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findEdit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findEdit_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findEdit_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findPerformer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findPerformer_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findPerformer_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findSceneByFingerprint_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findSceneByFingerprint_argsFingerprint(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fingerprint"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findSceneByFingerprint_argsFingerprint(
	ctx context.Context,
	rawArgs map[string]interface{},
) (FingerprintQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["fingerprint"]
	if !ok {
		var zeroVal FingerprintQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprint"))
	if tmp, ok := rawArgs["fingerprint"]; ok {
		return ec.unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx, tmp)
	}

	var zeroVal FingerprintQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findScene_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findScene_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findScene_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findScenesByFingerprints_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findScenesByFingerprints_argsFingerprints(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fingerprints"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findScenesByFingerprints_argsFingerprints(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([]string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["fingerprints"]
	if !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
	if tmp, ok := rawArgs["fingerprints"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findScenesByFullFingerprints_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findScenesByFullFingerprints_argsFingerprints(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fingerprints"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findScenesByFullFingerprints_argsFingerprints(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([]*FingerprintQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["fingerprints"]
	if !ok {
		var zeroVal []*FingerprintQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
	if tmp, ok := rawArgs["fingerprints"]; ok {
		return ec.unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx, tmp)
	}

	var zeroVal []*FingerprintQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findScenesBySceneFingerprints_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findScenesBySceneFingerprints_argsFingerprints(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fingerprints"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findScenesBySceneFingerprints_argsFingerprints(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([][]*FingerprintQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["fingerprints"]
	if !ok {
		var zeroVal [][]*FingerprintQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
	if tmp, ok := rawArgs["fingerprints"]; ok {
		return ec.unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx, tmp)
	}

	var zeroVal [][]*FingerprintQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findSite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findSite_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findSite_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findStudio_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findStudio_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Query_findStudio_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_findStudio_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal *uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal *uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findStudio_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findTagCategory_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findTagCategory_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findTagCategory_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findTagOrAlias_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findTagOrAlias_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_findTagOrAlias_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findTag_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Query_findTag_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_findTag_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal *uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal *uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findTag_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_findUser_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Query_findUser_argsUsername(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["username"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_findUser_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*uuid.UUID, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal *uuid.UUID
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, tmp)
	}

	var zeroVal *uuid.UUID
	return zeroVal, nil
}

func (ec *executionContext) field_Query_findUser_argsUsername(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["username"]
	if !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
	if tmp, ok := rawArgs["username"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryEdits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryEdits_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryEdits_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (EditQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal EditQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNEditQueryInput2githubcomstashappstashboxpkgmodelsEditQueryInput(ctx, tmp)
	}

	var zeroVal EditQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryExistingPerformer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryExistingPerformer_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryExistingPerformer_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (QueryExistingPerformerInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal QueryExistingPerformerInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNQueryExistingPerformerInput2githubcomstashappstashboxpkgmodelsQueryExistingPerformerInput(ctx, tmp)
	}

	var zeroVal QueryExistingPerformerInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryExistingScene_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryExistingScene_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryExistingScene_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (QueryExistingSceneInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal QueryExistingSceneInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNQueryExistingSceneInput2githubcomstashappstashboxpkgmodelsQueryExistingSceneInput(ctx, tmp)
	}

	var zeroVal QueryExistingSceneInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryNotifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryNotifications_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryNotifications_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (QueryNotificationsInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal QueryNotificationsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNQueryNotificationsInput2githubcomstashappstashboxpkgmodelsQueryNotificationsInput(ctx, tmp)
	}

	var zeroVal QueryNotificationsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryPerformers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryPerformers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryPerformers_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerQueryInput2githubcomstashappstashboxpkgmodelsPerformerQueryInput(ctx, tmp)
	}

	var zeroVal PerformerQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryScenes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryScenes_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryScenes_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (SceneQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal SceneQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNSceneQueryInput2githubcomstashappstashboxpkgmodelsSceneQueryInput(ctx, tmp)
	}

	var zeroVal SceneQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryStudios_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryStudios_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryStudios_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (StudioQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal StudioQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNStudioQueryInput2githubcomstashappstashboxpkgmodelsStudioQueryInput(ctx, tmp)
	}

	var zeroVal StudioQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryTags_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryTags_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (TagQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal TagQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNTagQueryInput2githubcomstashappstashboxpkgmodelsTagQueryInput(ctx, tmp)
	}

	var zeroVal TagQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_queryUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_queryUsers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_queryUsers_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (UserQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal UserQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUserQueryInput2githubcomstashappstashboxpkgmodelsUserQueryInput(ctx, tmp)
	}

	var zeroVal UserQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchPerformer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_searchPerformer_argsTerm(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["term"] = arg0
	arg1, err := ec.field_Query_searchPerformer_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_searchPerformer_argsTerm(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["term"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("term"))
	if tmp, ok := rawArgs["term"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchPerformer_argsLimit(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["limit"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchScene_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_searchScene_argsTerm(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["term"] = arg0
	arg1, err := ec.field_Query_searchScene_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_searchScene_argsTerm(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["term"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("term"))
	if tmp, ok := rawArgs["term"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchScene_argsLimit(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["limit"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchStudio_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_searchStudio_argsTerm(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["term"] = arg0
	arg1, err := ec.field_Query_searchStudio_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_searchStudio_argsTerm(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["term"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("term"))
	if tmp, ok := rawArgs["term"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchStudio_argsLimit(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["limit"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_searchTag_argsTerm(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["term"] = arg0
	arg1, err := ec.field_Query_searchTag_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_searchTag_argsTerm(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["term"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("term"))
	if tmp, ok := rawArgs["term"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_searchTag_argsLimit(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["limit"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Scene_fingerprints_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Scene_fingerprints_argsIsSubmitted(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["is_submitted"] = arg0
	return args, nil
}
func (ec *executionContext) field_Scene_fingerprints_argsIsSubmitted(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["is_submitted"]
	if !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("is_submitted"))
	if tmp, ok := rawArgs["is_submitted"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Studio_performers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Studio_performers_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Studio_performers_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (PerformerQueryInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal PerformerQueryInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNPerformerQueryInput2githubcomstashappstashboxpkgmodelsPerformerQueryInput(ctx, tmp)
	}

	var zeroVal PerformerQueryInput
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BodyModification_location(ctx context.Context, field graphql.CollectedField, obj *BodyModification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyModification_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyModification_location(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyModification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyModification_description(ctx context.Context, field graphql.CollectedField, obj *BodyModification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyModification_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyModification_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyModification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommentCommentedEdit_comment(ctx context.Context, field graphql.CollectedField, obj *CommentCommentedEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommentCommentedEdit_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EditComment)
	fc.Result = res
	return ec.marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommentCommentedEdit_comment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommentCommentedEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EditComment_id(ctx, field)
			case "user":
				return ec.fieldContext_EditComment_user(ctx, field)
			case "date":
				return ec.fieldContext_EditComment_date(ctx, field)
			case "comment":
				return ec.fieldContext_EditComment_comment(ctx, field)
			case "edit":
				return ec.fieldContext_EditComment_edit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EditComment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommentOwnEdit_comment(ctx context.Context, field graphql.CollectedField, obj *CommentOwnEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommentOwnEdit_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EditComment)
	fc.Result = res
	return ec.marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommentOwnEdit_comment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommentOwnEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EditComment_id(ctx, field)
			case "user":
				return ec.fieldContext_EditComment_user(ctx, field)
			case "date":
				return ec.fieldContext_EditComment_date(ctx, field)
			case "comment":
				return ec.fieldContext_EditComment_comment(ctx, field)
			case "edit":
				return ec.fieldContext_EditComment_edit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EditComment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommentVotedEdit_comment(ctx context.Context, field graphql.CollectedField, obj *CommentVotedEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommentVotedEdit_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EditComment)
	fc.Result = res
	return ec.marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommentVotedEdit_comment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommentVotedEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EditComment_id(ctx, field)
			case "user":
				return ec.fieldContext_EditComment_user(ctx, field)
			case "date":
				return ec.fieldContext_EditComment_date(ctx, field)
			case "comment":
				return ec.fieldContext_EditComment_comment(ctx, field)
			case "edit":
				return ec.fieldContext_EditComment_edit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EditComment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownvoteOwnEdit_edit(ctx context.Context, field graphql.CollectedField, obj *DownvoteOwnEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DownvoteOwnEdit_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DownvoteOwnEdit_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownvoteOwnEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Draft_id(ctx context.Context, field graphql.CollectedField, obj *Draft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Draft_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Draft_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Draft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Draft_created(ctx context.Context, field graphql.CollectedField, obj *Draft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Draft_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Draft().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Draft_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Draft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Draft_expires(ctx context.Context, field graphql.CollectedField, obj *Draft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Draft_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Draft().Expires(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Draft_expires(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Draft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Draft_data(ctx context.Context, field graphql.CollectedField, obj *Draft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Draft_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Draft().Data(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DraftData)
	fc.Result = res
	return ec.marshalNDraftData2githubcomstashappstashboxpkgmodelsDraftData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Draft_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Draft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DraftData does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DraftEntity_name(ctx context.Context, field graphql.CollectedField, obj *DraftEntity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DraftEntity_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DraftEntity_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DraftEntity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DraftEntity_id(ctx context.Context, field graphql.CollectedField, obj *DraftEntity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DraftEntity_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DraftEntity_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DraftEntity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DraftFingerprint_hash(ctx context.Context, field graphql.CollectedField, obj *DraftFingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DraftFingerprint_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DraftFingerprint_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DraftFingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DraftFingerprint_algorithm(ctx context.Context, field graphql.CollectedField, obj *DraftFingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DraftFingerprint_algorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Algorithm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FingerprintAlgorithm)
	fc.Result = res
	return ec.marshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DraftFingerprint_algorithm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DraftFingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FingerprintAlgorithm does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DraftFingerprint_duration(ctx context.Context, field graphql.CollectedField, obj *DraftFingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DraftFingerprint_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DraftFingerprint_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DraftFingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DraftSubmissionStatus_id(ctx context.Context, field graphql.CollectedField, obj *DraftSubmissionStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DraftSubmissionStatus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DraftSubmissionStatus_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DraftSubmissionStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_id(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_user(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_target(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_target(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Target(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(EditTarget)
	fc.Result = res
	return ec.marshalOEditTarget2githubcomstashappstashboxpkgmodelsEditTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_target(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EditTarget does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_target_type(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_target_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().TargetType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TargetTypeEnum)
	fc.Result = res
	return ec.marshalNTargetTypeEnum2githubcomstashappstashboxpkgmodelsTargetTypeEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_target_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TargetTypeEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_merge_sources(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_merge_sources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().MergeSources(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]EditTarget)
	fc.Result = res
	return ec.marshalNEditTarget2githubcomstashappstashboxpkgmodelsEditTarget(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_merge_sources(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EditTarget does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_operation(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_operation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Operation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(OperationEnum)
	fc.Result = res
	return ec.marshalNOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_operation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OperationEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_bot(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_bot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_bot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_details(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Details(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(EditDetails)
	fc.Result = res
	return ec.marshalOEditDetails2githubcomstashappstashboxpkgmodelsEditDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EditDetails does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_old_details(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_old_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().OldDetails(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(EditDetails)
	fc.Result = res
	return ec.marshalOEditDetails2githubcomstashappstashboxpkgmodelsEditDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_old_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EditDetails does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_options(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_options(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Options(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PerformerEditOptions)
	fc.Result = res
	return ec.marshalOPerformerEditOptions2githubcomstashappstashboxpkgmodelsPerformerEditOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_options(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "set_modify_aliases":
				return ec.fieldContext_PerformerEditOptions_set_modify_aliases(ctx, field)
			case "set_merge_aliases":
				return ec.fieldContext_PerformerEditOptions_set_merge_aliases(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PerformerEditOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_comments(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_comments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Comments(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*EditComment)
	fc.Result = res
	return ec.marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_comments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EditComment_id(ctx, field)
			case "user":
				return ec.fieldContext_EditComment_user(ctx, field)
			case "date":
				return ec.fieldContext_EditComment_date(ctx, field)
			case "comment":
				return ec.fieldContext_EditComment_comment(ctx, field)
			case "edit":
				return ec.fieldContext_EditComment_edit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EditComment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_votes(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_votes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Votes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*EditVote)
	fc.Result = res
	return ec.marshalNEditVote2githubcomstashappstashboxpkgmodelsEditVote(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_votes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_EditVote_user(ctx, field)
			case "date":
				return ec.fieldContext_EditVote_date(ctx, field)
			case "vote":
				return ec.fieldContext_EditVote_vote(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EditVote", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_vote_count(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_vote_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_vote_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_destructive(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_destructive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Destructive(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_destructive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_status(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VoteStatusEnum)
	fc.Result = res
	return ec.marshalNVoteStatusEnum2githubcomstashappstashboxpkgmodelsVoteStatusEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VoteStatusEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_applied(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_applied(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Applied, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_applied(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_update_count(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_update_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_update_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_updatable(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_updatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Updatable(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_updatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_created(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_updated(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Updated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_closed(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_closed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Closed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_closed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Edit_expires(ctx context.Context, field graphql.CollectedField, obj *Edit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Edit_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Edit().Expires(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Edit_expires(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Edit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditComment_id(ctx context.Context, field graphql.CollectedField, obj *EditComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditComment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditComment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditComment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditComment_user(ctx context.Context, field graphql.CollectedField, obj *EditComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditComment_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditComment().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditComment_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditComment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditComment_date(ctx context.Context, field graphql.CollectedField, obj *EditComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditComment_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditComment().Date(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditComment_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditComment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditComment_comment(ctx context.Context, field graphql.CollectedField, obj *EditComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditComment_comment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditComment().Comment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditComment_comment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditComment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditComment_edit(ctx context.Context, field graphql.CollectedField, obj *EditComment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditComment_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditComment().Edit(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditComment_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditComment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditVote_user(ctx context.Context, field graphql.CollectedField, obj *EditVote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditVote_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditVote().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditVote_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditVote",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditVote_date(ctx context.Context, field graphql.CollectedField, obj *EditVote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditVote_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditVote().Date(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditVote_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditVote",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EditVote_vote(ctx context.Context, field graphql.CollectedField, obj *EditVote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EditVote_vote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EditVote().Vote(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(VoteTypeEnum)
	fc.Result = res
	return ec.marshalNVoteTypeEnum2githubcomstashappstashboxpkgmodelsVoteTypeEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EditVote_vote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EditVote",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VoteTypeEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedOwnEdit_edit(ctx context.Context, field graphql.CollectedField, obj *FailedOwnEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FailedOwnEdit_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FailedOwnEdit_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedOwnEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FavoritePerformerEdit_edit(ctx context.Context, field graphql.CollectedField, obj *FavoritePerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FavoritePerformerEdit_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FavoritePerformerEdit_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FavoritePerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FavoritePerformerScene_scene(ctx context.Context, field graphql.CollectedField, obj *FavoritePerformerScene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FavoritePerformerScene_scene(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scene, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FavoritePerformerScene_scene(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FavoritePerformerScene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FavoriteStudioEdit_edit(ctx context.Context, field graphql.CollectedField, obj *FavoriteStudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FavoriteStudioEdit_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FavoriteStudioEdit_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FavoriteStudioEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FavoriteStudioScene_scene(ctx context.Context, field graphql.CollectedField, obj *FavoriteStudioScene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FavoriteStudioScene_scene(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scene, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FavoriteStudioScene_scene(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FavoriteStudioScene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_hash(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_algorithm(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_algorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Algorithm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FingerprintAlgorithm)
	fc.Result = res
	return ec.marshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_algorithm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FingerprintAlgorithm does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_duration(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_submissions(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_submissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Submissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_submissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_reports(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_reports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_reports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_created(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_updated(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_user_submitted(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_user_submitted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSubmitted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_user_submitted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Fingerprint_user_reported(ctx context.Context, field graphql.CollectedField, obj *Fingerprint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Fingerprint_user_reported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserReported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Fingerprint_user_reported(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Fingerprint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FuzzyDate_date(ctx context.Context, field graphql.CollectedField, obj *FuzzyDate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FuzzyDate_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FuzzyDate_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FuzzyDate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FuzzyDate_accuracy(ctx context.Context, field graphql.CollectedField, obj *FuzzyDate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FuzzyDate_accuracy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accuracy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DateAccuracyEnum)
	fc.Result = res
	return ec.marshalNDateAccuracyEnum2githubcomstashappstashboxpkgmodelsDateAccuracyEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FuzzyDate_accuracy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FuzzyDate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateAccuracyEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_id(ctx context.Context, field graphql.CollectedField, obj *Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_url(ctx context.Context, field graphql.CollectedField, obj *Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().URL(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_width(ctx context.Context, field graphql.CollectedField, obj *Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_height(ctx context.Context, field graphql.CollectedField, obj *Image) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InviteKey_id(ctx context.Context, field graphql.CollectedField, obj *InviteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InviteKey_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InviteKey_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InviteKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InviteKey_uses(ctx context.Context, field graphql.CollectedField, obj *InviteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InviteKey_uses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InviteKey_uses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InviteKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InviteKey_expires(ctx context.Context, field graphql.CollectedField, obj *InviteKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InviteKey_expires(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expires, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InviteKey_expires(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InviteKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Measurements_cup_size(ctx context.Context, field graphql.CollectedField, obj *Measurements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Measurements_cup_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CupSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Measurements_cup_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Measurements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Measurements_band_size(ctx context.Context, field graphql.CollectedField, obj *Measurements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Measurements_band_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BandSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Measurements_band_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Measurements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Measurements_waist(ctx context.Context, field graphql.CollectedField, obj *Measurements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Measurements_waist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Waist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Measurements_waist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Measurements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Measurements_hip(ctx context.Context, field graphql.CollectedField, obj *Measurements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Measurements_hip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Measurements_hip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Measurements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sceneCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sceneCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SceneCreate(rctx, fc.Args["input"].(SceneCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Scene)
	fc.Result = res
	return ec.marshalOScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sceneCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sceneCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sceneUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sceneUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SceneUpdate(rctx, fc.Args["input"].(SceneUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Scene)
	fc.Result = res
	return ec.marshalOScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sceneUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sceneUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sceneDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sceneDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SceneDestroy(rctx, fc.Args["input"].(SceneDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sceneDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sceneDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_performerCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_performerCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PerformerCreate(rctx, fc.Args["input"].(PerformerCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Performer
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Performer
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Performer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Performer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Performer)
	fc.Result = res
	return ec.marshalOPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_performerCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_performerCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_performerUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_performerUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PerformerUpdate(rctx, fc.Args["input"].(PerformerUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Performer
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Performer
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Performer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Performer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Performer)
	fc.Result = res
	return ec.marshalOPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_performerUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_performerUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_performerDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_performerDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PerformerDestroy(rctx, fc.Args["input"].(PerformerDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_performerDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_performerDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_studioCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_studioCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StudioCreate(rctx, fc.Args["input"].(StudioCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Studio
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Studio
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Studio); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Studio`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_studioCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_studioCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_studioUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_studioUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StudioUpdate(rctx, fc.Args["input"].(StudioUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Studio
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Studio
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Studio); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Studio`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_studioUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_studioUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_studioDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_studioDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StudioDestroy(rctx, fc.Args["input"].(StudioDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_studioDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_studioDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagCreate(rctx, fc.Args["input"].(TagCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Tag
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Tag
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagUpdate(rctx, fc.Args["input"].(TagUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal *Tag
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Tag
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagDestroy(rctx, fc.Args["input"].(TagDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserCreate(rctx, fc.Args["input"].(UserCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserUpdate(rctx, fc.Args["input"].(UserUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserDestroy(rctx, fc.Args["input"].(UserDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_imageCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_imageCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ImageCreate(rctx, fc.Args["input"].(ImageCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Image
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Image
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Image); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Image`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_imageCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_imageCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_imageDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_imageDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ImageDestroy(rctx, fc.Args["input"].(ImageDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "MODIFY")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_imageDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_imageDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_newUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_newUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NewUser(rctx, fc.Args["input"].(NewUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_newUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_newUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_activateNewUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_activateNewUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ActivateNewUser(rctx, fc.Args["input"].(ActivateNewUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_activateNewUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_activateNewUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_generateInviteCode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_generateInviteCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GenerateInviteCode(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_generateInviteCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_generateInviteCodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_generateInviteCodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GenerateInviteCodes(rctx, fc.Args["input"].(*GenerateInviteCodeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_generateInviteCodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_generateInviteCodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rescindInviteCode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rescindInviteCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RescindInviteCode(rctx, fc.Args["code"].(uuid.UUID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rescindInviteCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rescindInviteCode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_grantInvite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_grantInvite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GrantInvite(rctx, fc.Args["input"].(GrantInviteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_grantInvite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_grantInvite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeInvite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeInvite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RevokeInvite(rctx, fc.Args["input"].(RevokeInviteInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeInvite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeInvite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagCategoryCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagCategoryCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagCategoryCreate(rctx, fc.Args["input"].(TagCategoryCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *TagCategory
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *TagCategory
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TagCategory); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.TagCategory`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TagCategory)
	fc.Result = res
	return ec.marshalOTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagCategoryCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TagCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_TagCategory_name(ctx, field)
			case "group":
				return ec.fieldContext_TagCategory_group(ctx, field)
			case "description":
				return ec.fieldContext_TagCategory_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagCategory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagCategoryCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagCategoryUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagCategoryUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagCategoryUpdate(rctx, fc.Args["input"].(TagCategoryUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *TagCategory
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *TagCategory
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TagCategory); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.TagCategory`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TagCategory)
	fc.Result = res
	return ec.marshalOTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagCategoryUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TagCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_TagCategory_name(ctx, field)
			case "group":
				return ec.fieldContext_TagCategory_group(ctx, field)
			case "description":
				return ec.fieldContext_TagCategory_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagCategory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagCategoryUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagCategoryDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagCategoryDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagCategoryDestroy(rctx, fc.Args["input"].(TagCategoryDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagCategoryDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagCategoryDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_siteCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_siteCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SiteCreate(rctx, fc.Args["input"].(SiteCreateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *Site
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Site
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Site); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Site`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Site)
	fc.Result = res
	return ec.marshalOSite2githubcomstashappstashboxpkgmodelsSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_siteCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "name":
				return ec.fieldContext_Site_name(ctx, field)
			case "description":
				return ec.fieldContext_Site_description(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "regex":
				return ec.fieldContext_Site_regex(ctx, field)
			case "valid_types":
				return ec.fieldContext_Site_valid_types(ctx, field)
			case "icon":
				return ec.fieldContext_Site_icon(ctx, field)
			case "created":
				return ec.fieldContext_Site_created(ctx, field)
			case "updated":
				return ec.fieldContext_Site_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_siteCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_siteUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_siteUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SiteUpdate(rctx, fc.Args["input"].(SiteUpdateInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *Site
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Site
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Site); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Site`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Site)
	fc.Result = res
	return ec.marshalOSite2githubcomstashappstashboxpkgmodelsSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_siteUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "name":
				return ec.fieldContext_Site_name(ctx, field)
			case "description":
				return ec.fieldContext_Site_description(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "regex":
				return ec.fieldContext_Site_regex(ctx, field)
			case "valid_types":
				return ec.fieldContext_Site_valid_types(ctx, field)
			case "icon":
				return ec.fieldContext_Site_icon(ctx, field)
			case "created":
				return ec.fieldContext_Site_created(ctx, field)
			case "updated":
				return ec.fieldContext_Site_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_siteUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_siteDestroy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_siteDestroy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SiteDestroy(rctx, fc.Args["input"].(SiteDestroyInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_siteDestroy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_siteDestroy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_regenerateAPIKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_regenerateAPIKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RegenerateAPIKey(rctx, fc.Args["userID"].(*uuid.UUID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_regenerateAPIKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_regenerateAPIKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resetPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ResetPassword(rctx, fc.Args["input"].(ResetPasswordInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resetPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_resetPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_changePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ChangePassword(rctx, fc.Args["input"].(UserChangePasswordInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_changePassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_requestChangeEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_requestChangeEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RequestChangeEmail(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal UserChangeEmailStatus
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal UserChangeEmailStatus
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(UserChangeEmailStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/stashapp/stash-box/pkg/models.UserChangeEmailStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UserChangeEmailStatus)
	fc.Result = res
	return ec.marshalNUserChangeEmailStatus2githubcomstashappstashboxpkgmodelsUserChangeEmailStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_requestChangeEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserChangeEmailStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_validateChangeEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_validateChangeEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ValidateChangeEmail(rctx, fc.Args["token"].(uuid.UUID), fc.Args["email"].(string))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal UserChangeEmailStatus
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal UserChangeEmailStatus
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(UserChangeEmailStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/stashapp/stash-box/pkg/models.UserChangeEmailStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UserChangeEmailStatus)
	fc.Result = res
	return ec.marshalNUserChangeEmailStatus2githubcomstashappstashboxpkgmodelsUserChangeEmailStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_validateChangeEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserChangeEmailStatus does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_validateChangeEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_confirmChangeEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_confirmChangeEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConfirmChangeEmail(rctx, fc.Args["token"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal UserChangeEmailStatus
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal UserChangeEmailStatus
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(UserChangeEmailStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/stashapp/stash-box/pkg/models.UserChangeEmailStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(UserChangeEmailStatus)
	fc.Result = res
	return ec.marshalNUserChangeEmailStatus2githubcomstashappstashboxpkgmodelsUserChangeEmailStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_confirmChangeEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserChangeEmailStatus does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_confirmChangeEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sceneEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sceneEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SceneEdit(rctx, fc.Args["input"].(SceneEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sceneEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sceneEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_performerEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_performerEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PerformerEdit(rctx, fc.Args["input"].(PerformerEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_performerEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_performerEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_studioEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_studioEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StudioEdit(rctx, fc.Args["input"].(StudioEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_studioEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_studioEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagEdit(rctx, fc.Args["input"].(TagEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sceneEditUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sceneEditUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SceneEditUpdate(rctx, fc.Args["id"].(uuid.UUID), fc.Args["input"].(SceneEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sceneEditUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sceneEditUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_performerEditUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_performerEditUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PerformerEditUpdate(rctx, fc.Args["id"].(uuid.UUID), fc.Args["input"].(PerformerEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_performerEditUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_performerEditUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_studioEditUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_studioEditUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().StudioEditUpdate(rctx, fc.Args["id"].(uuid.UUID), fc.Args["input"].(StudioEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_studioEditUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_studioEditUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_tagEditUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_tagEditUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().TagEditUpdate(rctx, fc.Args["id"].(uuid.UUID), fc.Args["input"].(TagEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_tagEditUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_tagEditUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editVote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editVote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EditVote(rctx, fc.Args["input"].(EditVoteInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "VOTE")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editVote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editVote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editComment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editComment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().EditComment(rctx, fc.Args["input"].(EditCommentInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editComment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editComment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_applyEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_applyEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApplyEdit(rctx, fc.Args["input"].(ApplyEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_applyEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_applyEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelEdit(rctx, fc.Args["input"].(CancelEditInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_submitFingerprint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_submitFingerprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SubmitFingerprint(rctx, fc.Args["input"].(FingerprintSubmission))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_submitFingerprint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_submitFingerprint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_submitSceneDraft(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_submitSceneDraft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SubmitSceneDraft(rctx, fc.Args["input"].(SceneDraftInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *DraftSubmissionStatus
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *DraftSubmissionStatus
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*DraftSubmissionStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.DraftSubmissionStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DraftSubmissionStatus)
	fc.Result = res
	return ec.marshalNDraftSubmissionStatus2githubcomstashappstashboxpkgmodelsDraftSubmissionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_submitSceneDraft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DraftSubmissionStatus_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DraftSubmissionStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_submitSceneDraft_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_submitPerformerDraft(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_submitPerformerDraft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SubmitPerformerDraft(rctx, fc.Args["input"].(PerformerDraftInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal *DraftSubmissionStatus
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *DraftSubmissionStatus
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*DraftSubmissionStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.DraftSubmissionStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DraftSubmissionStatus)
	fc.Result = res
	return ec.marshalNDraftSubmissionStatus2githubcomstashappstashboxpkgmodelsDraftSubmissionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_submitPerformerDraft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DraftSubmissionStatus_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DraftSubmissionStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_submitPerformerDraft_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_destroyDraft(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_destroyDraft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DestroyDraft(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_destroyDraft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_destroyDraft_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_favoritePerformer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_favoritePerformer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FavoritePerformer(rctx, fc.Args["id"].(uuid.UUID), fc.Args["favorite"].(bool))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_favoritePerformer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_favoritePerformer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_favoriteStudio(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_favoriteStudio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FavoriteStudio(rctx, fc.Args["id"].(uuid.UUID), fc.Args["favorite"].(bool))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_favoriteStudio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_favoriteStudio_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_markNotificationsRead(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_markNotificationsRead(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MarkNotificationsRead(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_markNotificationsRead(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNotificationSubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateNotificationSubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateNotificationSubscriptions(rctx, fc.Args["subscriptions"].([]NotificationEnum))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "EDIT")
			if err != nil {
				var zeroVal bool
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateNotificationSubscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNotificationSubscriptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Notification_created(ctx context.Context, field graphql.CollectedField, obj *Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_read(ctx context.Context, field graphql.CollectedField, obj *Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_read(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().Read(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_read(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notification_data(ctx context.Context, field graphql.CollectedField, obj *Notification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notification_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Notification().Data(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(NotificationData)
	fc.Result = res
	return ec.marshalNNotificationData2githubcomstashappstashboxpkgmodelsNotificationData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notification_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NotificationData does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_id(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_name(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_disambiguation(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_disambiguation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Disambiguation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_disambiguation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_aliases(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_gender(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*GenderEnum)
	fc.Result = res
	return ec.marshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_gender(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GenderEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_urls(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_birthdate(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_birthdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Birthdate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FuzzyDate)
	fc.Result = res
	return ec.marshalOFuzzyDate2githubcomstashappstashboxpkgmodelsFuzzyDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_birthdate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_FuzzyDate_date(ctx, field)
			case "accuracy":
				return ec.fieldContext_FuzzyDate_accuracy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FuzzyDate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_birth_date(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_birth_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().BirthDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_birth_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_death_date(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_death_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().DeathDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_death_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_age(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_age(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Age(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_age(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_ethnicity(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_ethnicity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Ethnicity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EthnicityEnum)
	fc.Result = res
	return ec.marshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_ethnicity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EthnicityEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_country(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_country(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Country(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_country(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_eye_color(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_eye_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().EyeColor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EyeColorEnum)
	fc.Result = res
	return ec.marshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_eye_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EyeColorEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_hair_color(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_hair_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().HairColor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HairColorEnum)
	fc.Result = res
	return ec.marshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_hair_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HairColorEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_height(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Height(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_measurements(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_measurements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Measurements(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Measurements)
	fc.Result = res
	return ec.marshalNMeasurements2githubcomstashappstashboxpkgmodelsMeasurements(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_measurements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cup_size":
				return ec.fieldContext_Measurements_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Measurements_band_size(ctx, field)
			case "waist":
				return ec.fieldContext_Measurements_waist(ctx, field)
			case "hip":
				return ec.fieldContext_Measurements_hip(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Measurements", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_cup_size(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_cup_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().CupSize(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_cup_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_band_size(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_band_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().BandSize(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_band_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_waist_size(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_waist_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().WaistSize(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_waist_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_hip_size(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_hip_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().HipSize(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_hip_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_breast_type(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_breast_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().BreastType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BreastTypeEnum)
	fc.Result = res
	return ec.marshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_breast_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BreastTypeEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_career_start_year(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_career_start_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().CareerStartYear(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_career_start_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_career_end_year(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_career_end_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().CareerEndYear(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_career_end_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_tattoos(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_tattoos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Tattoos(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_tattoos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_piercings(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_piercings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Piercings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_piercings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_images(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_deleted(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_deleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_edits(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_edits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Edits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_edits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_scene_count(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_scene_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().SceneCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_scene_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_scenes(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_scenes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Scenes(rctx, obj, fc.Args["input"].(*PerformerScenesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_scenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Performer_scenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Performer_merged_ids(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_merged_ids(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().MergedIds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_merged_ids(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_merged_into_id(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_merged_into_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().MergedIntoID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_merged_into_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_studios(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_studios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Studios(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*PerformerStudio)
	fc.Result = res
	return ec.marshalNPerformerStudio2githubcomstashappstashboxpkgmodelsPerformerStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_studios(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "studio":
				return ec.fieldContext_PerformerStudio_studio(ctx, field)
			case "scene_count":
				return ec.fieldContext_PerformerStudio_scene_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PerformerStudio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_is_favorite(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_is_favorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().IsFavorite(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_is_favorite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_created(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Performer_updated(ctx context.Context, field graphql.CollectedField, obj *Performer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Performer_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Performer().Updated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Performer_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Performer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerAppearance_performer(ctx context.Context, field graphql.CollectedField, obj *PerformerAppearance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerAppearance_performer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Performer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Performer)
	fc.Result = res
	return ec.marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerAppearance_performer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerAppearance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerAppearance_as(ctx context.Context, field graphql.CollectedField, obj *PerformerAppearance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerAppearance_as(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.As, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerAppearance_as(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerAppearance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_id(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_name(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_disambiguation(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_disambiguation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disambiguation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_disambiguation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_aliases(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_gender(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_gender(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_birthdate(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_birthdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Birthdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_birthdate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_deathdate(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_deathdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deathdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_deathdate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_urls(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Urls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_ethnicity(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_ethnicity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ethnicity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_ethnicity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_country(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_country(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_country(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_eye_color(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_eye_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EyeColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_eye_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_hair_color(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_hair_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HairColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_hair_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_height(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_measurements(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_measurements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Measurements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_measurements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_breast_type(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_breast_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BreastType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_breast_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_tattoos(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_tattoos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tattoos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_tattoos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_piercings(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_piercings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Piercings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_piercings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_career_start_year(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_career_start_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CareerStartYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_career_start_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_career_end_year(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_career_end_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CareerEndYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_career_end_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerDraft_image(ctx context.Context, field graphql.CollectedField, obj *PerformerDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerDraft_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerDraft().Image(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerDraft_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerDraft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_name(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_disambiguation(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_disambiguation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disambiguation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_disambiguation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_added_aliases(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_added_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_added_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_removed_aliases(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_removed_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_removed_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_gender(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Gender(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*GenderEnum)
	fc.Result = res
	return ec.marshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_gender(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GenderEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_added_urls(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_added_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedUrls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_added_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_removed_urls(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_removed_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedUrls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_removed_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_birthdate(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_birthdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Birthdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_birthdate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_deathdate(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_deathdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deathdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_deathdate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_ethnicity(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_ethnicity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Ethnicity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EthnicityEnum)
	fc.Result = res
	return ec.marshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_ethnicity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EthnicityEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_country(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_country(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_country(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_eye_color(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_eye_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().EyeColor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*EyeColorEnum)
	fc.Result = res
	return ec.marshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_eye_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EyeColorEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_hair_color(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_hair_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().HairColor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HairColorEnum)
	fc.Result = res
	return ec.marshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_hair_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HairColorEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_height(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_cup_size(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_cup_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CupSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_cup_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_band_size(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_band_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BandSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_band_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_waist_size(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_waist_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WaistSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_waist_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_hip_size(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_hip_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HipSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_hip_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_breast_type(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_breast_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().BreastType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*BreastTypeEnum)
	fc.Result = res
	return ec.marshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_breast_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BreastTypeEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_career_start_year(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_career_start_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CareerStartYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_career_start_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_career_end_year(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_career_end_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CareerEndYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_career_end_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_added_tattoos(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_added_tattoos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedTattoos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_added_tattoos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_removed_tattoos(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_removed_tattoos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedTattoos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_removed_tattoos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_added_piercings(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_added_piercings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedPiercings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_added_piercings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_removed_piercings(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_removed_piercings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedPiercings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_removed_piercings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_added_images(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_added_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().AddedImages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_added_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_removed_images(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_removed_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().RemovedImages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_removed_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_draft_id(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_draft_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DraftID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_draft_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_aliases(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_urls(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_images(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_tattoos(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_tattoos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Tattoos(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalNBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_tattoos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEdit_piercings(ctx context.Context, field graphql.CollectedField, obj *PerformerEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEdit_piercings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PerformerEdit().Piercings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*BodyModification)
	fc.Result = res
	return ec.marshalNBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEdit_piercings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "location":
				return ec.fieldContext_BodyModification_location(ctx, field)
			case "description":
				return ec.fieldContext_BodyModification_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyModification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEditOptions_set_modify_aliases(ctx context.Context, field graphql.CollectedField, obj *PerformerEditOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEditOptions_set_modify_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetModifyAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEditOptions_set_modify_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEditOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerEditOptions_set_merge_aliases(ctx context.Context, field graphql.CollectedField, obj *PerformerEditOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerEditOptions_set_merge_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetMergeAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerEditOptions_set_merge_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerEditOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerStudio_studio(ctx context.Context, field graphql.CollectedField, obj *PerformerStudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerStudio_studio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Studio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Studio)
	fc.Result = res
	return ec.marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerStudio_studio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerStudio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PerformerStudio_scene_count(ctx context.Context, field graphql.CollectedField, obj *PerformerStudio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PerformerStudio_scene_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SceneCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PerformerStudio_scene_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PerformerStudio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_findPerformer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findPerformer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindPerformer(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Performer
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Performer
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Performer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Performer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Performer)
	fc.Result = res
	return ec.marshalOPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findPerformer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findPerformer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryPerformers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryPerformers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryPerformers(rctx, fc.Args["input"].(PerformerQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *PerformerQuery
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *PerformerQuery
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*PerformerQuery); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.PerformerQuery`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PerformerQuery)
	fc.Result = res
	return ec.marshalNQueryPerformersResultType2githubcomstashappstashboxpkgmodelsPerformerQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryPerformers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryPerformersResultType_count(ctx, field)
			case "performers":
				return ec.fieldContext_QueryPerformersResultType_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryPerformersResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryPerformers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findStudio(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findStudio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindStudio(rctx, fc.Args["id"].(*uuid.UUID), fc.Args["name"].(*string))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Studio
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Studio
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Studio); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Studio`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findStudio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findStudio_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryStudios(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryStudios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryStudios(rctx, fc.Args["input"].(StudioQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QueryStudiosResultType
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryStudiosResultType
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryStudiosResultType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryStudiosResultType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryStudiosResultType)
	fc.Result = res
	return ec.marshalNQueryStudiosResultType2githubcomstashappstashboxpkgmodelsQueryStudiosResultType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryStudios(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryStudiosResultType_count(ctx, field)
			case "studios":
				return ec.fieldContext_QueryStudiosResultType_studios(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryStudiosResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryStudios_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindTag(rctx, fc.Args["id"].(*uuid.UUID), fc.Args["name"].(*string))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Tag
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Tag
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findTagOrAlias(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findTagOrAlias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindTagOrAlias(rctx, fc.Args["name"].(string))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Tag
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Tag
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findTagOrAlias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findTagOrAlias_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryTags(rctx, fc.Args["input"].(TagQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QueryTagsResultType
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryTagsResultType
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryTagsResultType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryTagsResultType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryTagsResultType)
	fc.Result = res
	return ec.marshalNQueryTagsResultType2githubcomstashappstashboxpkgmodelsQueryTagsResultType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryTagsResultType_count(ctx, field)
			case "tags":
				return ec.fieldContext_QueryTagsResultType_tags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryTagsResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findTagCategory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findTagCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindTagCategory(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *TagCategory
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *TagCategory
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TagCategory); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.TagCategory`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TagCategory)
	fc.Result = res
	return ec.marshalOTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findTagCategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TagCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_TagCategory_name(ctx, field)
			case "group":
				return ec.fieldContext_TagCategory_group(ctx, field)
			case "description":
				return ec.fieldContext_TagCategory_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagCategory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findTagCategory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryTagCategories(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryTagCategories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryTagCategories(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QueryTagCategoriesResultType
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryTagCategoriesResultType
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryTagCategoriesResultType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryTagCategoriesResultType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryTagCategoriesResultType)
	fc.Result = res
	return ec.marshalNQueryTagCategoriesResultType2githubcomstashappstashboxpkgmodelsQueryTagCategoriesResultType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryTagCategories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryTagCategoriesResultType_count(ctx, field)
			case "tag_categories":
				return ec.fieldContext_QueryTagCategoriesResultType_tag_categories(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryTagCategoriesResultType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_findScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findScene(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindScene(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Scene)
	fc.Result = res
	return ec.marshalOScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findSceneByFingerprint(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findSceneByFingerprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindSceneByFingerprint(rctx, fc.Args["fingerprint"].(FingerprintQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findSceneByFingerprint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findSceneByFingerprint_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findScenesByFingerprints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findScenesByFingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindScenesByFingerprints(rctx, fc.Args["fingerprints"].([]string))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findScenesByFingerprints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findScenesByFingerprints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findScenesByFullFingerprints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findScenesByFullFingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindScenesByFullFingerprints(rctx, fc.Args["fingerprints"].([]*FingerprintQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findScenesByFullFingerprints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findScenesByFullFingerprints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findScenesBySceneFingerprints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findScenesBySceneFingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindScenesBySceneFingerprints(rctx, fc.Args["fingerprints"].([][]*FingerprintQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal [][]*Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal [][]*Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([][]*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be [][]*github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([][]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findScenesBySceneFingerprints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findScenesBySceneFingerprints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryScenes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryScenes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryScenes(rctx, fc.Args["input"].(SceneQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *SceneQuery
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *SceneQuery
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*SceneQuery); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.SceneQuery`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SceneQuery)
	fc.Result = res
	return ec.marshalNQueryScenesResultType2githubcomstashappstashboxpkgmodelsSceneQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryScenes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryScenesResultType_count(ctx, field)
			case "scenes":
				return ec.fieldContext_QueryScenesResultType_scenes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryScenesResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryScenes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findSite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findSite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindSite(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Site
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Site
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Site); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Site`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Site)
	fc.Result = res
	return ec.marshalOSite2githubcomstashappstashboxpkgmodelsSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findSite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "name":
				return ec.fieldContext_Site_name(ctx, field)
			case "description":
				return ec.fieldContext_Site_description(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "regex":
				return ec.fieldContext_Site_regex(ctx, field)
			case "valid_types":
				return ec.fieldContext_Site_valid_types(ctx, field)
			case "icon":
				return ec.fieldContext_Site_icon(ctx, field)
			case "created":
				return ec.fieldContext_Site_created(ctx, field)
			case "updated":
				return ec.fieldContext_Site_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findSite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_querySites(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_querySites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QuerySites(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QuerySitesResultType
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QuerySitesResultType
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QuerySitesResultType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QuerySitesResultType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QuerySitesResultType)
	fc.Result = res
	return ec.marshalNQuerySitesResultType2githubcomstashappstashboxpkgmodelsQuerySitesResultType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_querySites(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QuerySitesResultType_count(ctx, field)
			case "sites":
				return ec.fieldContext_QuerySitesResultType_sites(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QuerySitesResultType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_findEdit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findEdit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindEdit(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Edit
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Edit
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Edit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Edit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalOEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findEdit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findEdit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryEdits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryEdits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryEdits(rctx, fc.Args["input"].(EditQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *EditQuery
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *EditQuery
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*EditQuery); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.EditQuery`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*EditQuery)
	fc.Result = res
	return ec.marshalNQueryEditsResultType2githubcomstashappstashboxpkgmodelsEditQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryEdits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryEditsResultType_count(ctx, field)
			case "edits":
				return ec.fieldContext_QueryEditsResultType_edits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryEditsResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryEdits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindUser(rctx, fc.Args["id"].(*uuid.UUID), fc.Args["username"].(*string))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *User
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *User
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryUsers(rctx, fc.Args["input"].(UserQueryInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "ADMIN")
			if err != nil {
				var zeroVal *QueryUsersResultType
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryUsersResultType
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryUsersResultType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryUsersResultType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryUsersResultType)
	fc.Result = res
	return ec.marshalNQueryUsersResultType2githubcomstashappstashboxpkgmodelsQueryUsersResultType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryUsersResultType_count(ctx, field)
			case "users":
				return ec.fieldContext_QueryUsersResultType_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryUsersResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchPerformer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchPerformer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchPerformer(rctx, fc.Args["term"].(string), fc.Args["limit"].(*int))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Performer
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Performer
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Performer); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Performer`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Performer)
	fc.Result = res
	return ec.marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchPerformer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchPerformer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchScene(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchScene(rctx, fc.Args["term"].(string), fc.Args["limit"].(*int))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Scene
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Scene
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Scene); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Scene`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchTag(rctx, fc.Args["term"].(string), fc.Args["limit"].(*int))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Tag
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Tag
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Tag); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Tag`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchStudio(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchStudio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SearchStudio(rctx, fc.Args["term"].(string), fc.Args["limit"].(*int))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Studio
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Studio
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Studio); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Studio`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Studio)
	fc.Result = res
	return ec.marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchStudio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchStudio_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findDraft(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findDraft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindDraft(rctx, fc.Args["id"].(uuid.UUID))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Draft
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Draft
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Draft); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Draft`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Draft)
	fc.Result = res
	return ec.marshalODraft2githubcomstashappstashboxpkgmodelsDraft(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findDraft(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Draft_id(ctx, field)
			case "created":
				return ec.fieldContext_Draft_created(ctx, field)
			case "expires":
				return ec.fieldContext_Draft_expires(ctx, field)
			case "data":
				return ec.fieldContext_Draft_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Draft", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findDraft_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findDrafts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_findDrafts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().FindDrafts(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal []*Draft
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal []*Draft
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*Draft); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.Draft`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Draft)
	fc.Result = res
	return ec.marshalNDraft2githubcomstashappstashboxpkgmodelsDraft(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_findDrafts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Draft_id(ctx, field)
			case "created":
				return ec.fieldContext_Draft_created(ctx, field)
			case "expires":
				return ec.fieldContext_Draft_expires(ctx, field)
			case "data":
				return ec.fieldContext_Draft_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Draft", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryExistingScene(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryExistingScene(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryExistingScene(rctx, fc.Args["input"].(QueryExistingSceneInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QueryExistingSceneResult
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryExistingSceneResult
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryExistingSceneResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryExistingSceneResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryExistingSceneResult)
	fc.Result = res
	return ec.marshalNQueryExistingSceneResult2githubcomstashappstashboxpkgmodelsQueryExistingSceneResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryExistingScene(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edits":
				return ec.fieldContext_QueryExistingSceneResult_edits(ctx, field)
			case "scenes":
				return ec.fieldContext_QueryExistingSceneResult_scenes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryExistingSceneResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryExistingScene_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryExistingPerformer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryExistingPerformer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryExistingPerformer(rctx, fc.Args["input"].(QueryExistingPerformerInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QueryExistingPerformerResult
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryExistingPerformerResult
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryExistingPerformerResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryExistingPerformerResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryExistingPerformerResult)
	fc.Result = res
	return ec.marshalNQueryExistingPerformerResult2githubcomstashappstashboxpkgmodelsQueryExistingPerformerResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryExistingPerformer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edits":
				return ec.fieldContext_QueryExistingPerformerResult_edits(ctx, field)
			case "performers":
				return ec.fieldContext_QueryExistingPerformerResult_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryExistingPerformerResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryExistingPerformer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Version(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *Version
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *Version
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*Version); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.Version`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Version)
	fc.Result = res
	return ec.marshalNVersion2githubcomstashappstashboxpkgmodelsVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Version_hash(ctx, field)
			case "build_time":
				return ec.fieldContext_Version_build_time(ctx, field)
			case "build_type":
				return ec.fieldContext_Version_build_type(ctx, field)
			case "version":
				return ec.fieldContext_Version_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*StashBoxConfig)
	fc.Result = res
	return ec.marshalNStashBoxConfig2githubcomstashappstashboxpkgmodelsStashBoxConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "host_url":
				return ec.fieldContext_StashBoxConfig_host_url(ctx, field)
			case "require_invite":
				return ec.fieldContext_StashBoxConfig_require_invite(ctx, field)
			case "require_activation":
				return ec.fieldContext_StashBoxConfig_require_activation(ctx, field)
			case "vote_promotion_threshold":
				return ec.fieldContext_StashBoxConfig_vote_promotion_threshold(ctx, field)
			case "vote_application_threshold":
				return ec.fieldContext_StashBoxConfig_vote_application_threshold(ctx, field)
			case "voting_period":
				return ec.fieldContext_StashBoxConfig_voting_period(ctx, field)
			case "min_destructive_voting_period":
				return ec.fieldContext_StashBoxConfig_min_destructive_voting_period(ctx, field)
			case "vote_cron_interval":
				return ec.fieldContext_StashBoxConfig_vote_cron_interval(ctx, field)
			case "guidelines_url":
				return ec.fieldContext_StashBoxConfig_guidelines_url(ctx, field)
			case "require_scene_draft":
				return ec.fieldContext_StashBoxConfig_require_scene_draft(ctx, field)
			case "edit_update_limit":
				return ec.fieldContext_StashBoxConfig_edit_update_limit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StashBoxConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_queryNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_queryNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().QueryNotifications(rctx, fc.Args["input"].(QueryNotificationsInput))
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal *QueryNotificationsResult
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal *QueryNotificationsResult
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*QueryNotificationsResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.QueryNotificationsResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*QueryNotificationsResult)
	fc.Result = res
	return ec.marshalNQueryNotificationsResult2githubcomstashappstashboxpkgmodelsQueryNotificationsResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_queryNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryNotificationsResult_count(ctx, field)
			case "notifications":
				return ec.fieldContext_QueryNotificationsResult_notifications(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryNotificationsResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_queryNotifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUnreadNotificationCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUnreadNotificationCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUnreadNotificationCount(rctx)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, "READ")
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.HasRole == nil {
				var zeroVal int
				return zeroVal, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUnreadNotificationCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryEditsResultType_count(ctx context.Context, field graphql.CollectedField, obj *EditQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryEditsResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryEditsResultType().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryEditsResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryEditsResultType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryEditsResultType_edits(ctx context.Context, field graphql.CollectedField, obj *EditQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryEditsResultType_edits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryEditsResultType().Edits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryEditsResultType_edits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryEditsResultType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryExistingPerformerResult_edits(ctx context.Context, field graphql.CollectedField, obj *QueryExistingPerformerResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryExistingPerformerResult_edits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryExistingPerformerResult().Edits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryExistingPerformerResult_edits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryExistingPerformerResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryExistingPerformerResult_performers(ctx context.Context, field graphql.CollectedField, obj *QueryExistingPerformerResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryExistingPerformerResult_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryExistingPerformerResult().Performers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Performer)
	fc.Result = res
	return ec.marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryExistingPerformerResult_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryExistingPerformerResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryExistingSceneResult_edits(ctx context.Context, field graphql.CollectedField, obj *QueryExistingSceneResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryExistingSceneResult_edits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryExistingSceneResult().Edits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryExistingSceneResult_edits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryExistingSceneResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryExistingSceneResult_scenes(ctx context.Context, field graphql.CollectedField, obj *QueryExistingSceneResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryExistingSceneResult_scenes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryExistingSceneResult().Scenes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryExistingSceneResult_scenes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryExistingSceneResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryNotificationsResult_count(ctx context.Context, field graphql.CollectedField, obj *QueryNotificationsResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryNotificationsResult_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryNotificationsResult().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryNotificationsResult_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryNotificationsResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryNotificationsResult_notifications(ctx context.Context, field graphql.CollectedField, obj *QueryNotificationsResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryNotificationsResult_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryNotificationsResult().Notifications(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Notification)
	fc.Result = res
	return ec.marshalNNotification2githubcomstashappstashboxpkgmodelsNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryNotificationsResult_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryNotificationsResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "created":
				return ec.fieldContext_Notification_created(ctx, field)
			case "read":
				return ec.fieldContext_Notification_read(ctx, field)
			case "data":
				return ec.fieldContext_Notification_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notification", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryPerformersResultType_count(ctx context.Context, field graphql.CollectedField, obj *PerformerQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryPerformersResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryPerformersResultType().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryPerformersResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryPerformersResultType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryPerformersResultType_performers(ctx context.Context, field graphql.CollectedField, obj *PerformerQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryPerformersResultType_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryPerformersResultType().Performers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Performer)
	fc.Result = res
	return ec.marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryPerformersResultType_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryPerformersResultType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Performer_id(ctx, field)
			case "name":
				return ec.fieldContext_Performer_name(ctx, field)
			case "disambiguation":
				return ec.fieldContext_Performer_disambiguation(ctx, field)
			case "aliases":
				return ec.fieldContext_Performer_aliases(ctx, field)
			case "gender":
				return ec.fieldContext_Performer_gender(ctx, field)
			case "urls":
				return ec.fieldContext_Performer_urls(ctx, field)
			case "birthdate":
				return ec.fieldContext_Performer_birthdate(ctx, field)
			case "birth_date":
				return ec.fieldContext_Performer_birth_date(ctx, field)
			case "death_date":
				return ec.fieldContext_Performer_death_date(ctx, field)
			case "age":
				return ec.fieldContext_Performer_age(ctx, field)
			case "ethnicity":
				return ec.fieldContext_Performer_ethnicity(ctx, field)
			case "country":
				return ec.fieldContext_Performer_country(ctx, field)
			case "eye_color":
				return ec.fieldContext_Performer_eye_color(ctx, field)
			case "hair_color":
				return ec.fieldContext_Performer_hair_color(ctx, field)
			case "height":
				return ec.fieldContext_Performer_height(ctx, field)
			case "measurements":
				return ec.fieldContext_Performer_measurements(ctx, field)
			case "cup_size":
				return ec.fieldContext_Performer_cup_size(ctx, field)
			case "band_size":
				return ec.fieldContext_Performer_band_size(ctx, field)
			case "waist_size":
				return ec.fieldContext_Performer_waist_size(ctx, field)
			case "hip_size":
				return ec.fieldContext_Performer_hip_size(ctx, field)
			case "breast_type":
				return ec.fieldContext_Performer_breast_type(ctx, field)
			case "career_start_year":
				return ec.fieldContext_Performer_career_start_year(ctx, field)
			case "career_end_year":
				return ec.fieldContext_Performer_career_end_year(ctx, field)
			case "tattoos":
				return ec.fieldContext_Performer_tattoos(ctx, field)
			case "piercings":
				return ec.fieldContext_Performer_piercings(ctx, field)
			case "images":
				return ec.fieldContext_Performer_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Performer_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Performer_edits(ctx, field)
			case "scene_count":
				return ec.fieldContext_Performer_scene_count(ctx, field)
			case "scenes":
				return ec.fieldContext_Performer_scenes(ctx, field)
			case "merged_ids":
				return ec.fieldContext_Performer_merged_ids(ctx, field)
			case "merged_into_id":
				return ec.fieldContext_Performer_merged_into_id(ctx, field)
			case "studios":
				return ec.fieldContext_Performer_studios(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Performer_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Performer_created(ctx, field)
			case "updated":
				return ec.fieldContext_Performer_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Performer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryScenesResultType_count(ctx context.Context, field graphql.CollectedField, obj *SceneQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryScenesResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryScenesResultType().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryScenesResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryScenesResultType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryScenesResultType_scenes(ctx context.Context, field graphql.CollectedField, obj *SceneQuery) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryScenesResultType_scenes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.QueryScenesResultType().Scenes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Scene)
	fc.Result = res
	return ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryScenesResultType_scenes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryScenesResultType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Scene_id(ctx, field)
			case "title":
				return ec.fieldContext_Scene_title(ctx, field)
			case "details":
				return ec.fieldContext_Scene_details(ctx, field)
			case "date":
				return ec.fieldContext_Scene_date(ctx, field)
			case "release_date":
				return ec.fieldContext_Scene_release_date(ctx, field)
			case "production_date":
				return ec.fieldContext_Scene_production_date(ctx, field)
			case "urls":
				return ec.fieldContext_Scene_urls(ctx, field)
			case "studio":
				return ec.fieldContext_Scene_studio(ctx, field)
			case "tags":
				return ec.fieldContext_Scene_tags(ctx, field)
			case "images":
				return ec.fieldContext_Scene_images(ctx, field)
			case "performers":
				return ec.fieldContext_Scene_performers(ctx, field)
			case "fingerprints":
				return ec.fieldContext_Scene_fingerprints(ctx, field)
			case "duration":
				return ec.fieldContext_Scene_duration(ctx, field)
			case "director":
				return ec.fieldContext_Scene_director(ctx, field)
			case "code":
				return ec.fieldContext_Scene_code(ctx, field)
			case "deleted":
				return ec.fieldContext_Scene_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Scene_edits(ctx, field)
			case "created":
				return ec.fieldContext_Scene_created(ctx, field)
			case "updated":
				return ec.fieldContext_Scene_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Scene", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuerySitesResultType_count(ctx context.Context, field graphql.CollectedField, obj *QuerySitesResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QuerySitesResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QuerySitesResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuerySitesResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuerySitesResultType_sites(ctx context.Context, field graphql.CollectedField, obj *QuerySitesResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QuerySitesResultType_sites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sites, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Site)
	fc.Result = res
	return ec.marshalNSite2githubcomstashappstashboxpkgmodelsSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QuerySitesResultType_sites(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuerySitesResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "name":
				return ec.fieldContext_Site_name(ctx, field)
			case "description":
				return ec.fieldContext_Site_description(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "regex":
				return ec.fieldContext_Site_regex(ctx, field)
			case "valid_types":
				return ec.fieldContext_Site_valid_types(ctx, field)
			case "icon":
				return ec.fieldContext_Site_icon(ctx, field)
			case "created":
				return ec.fieldContext_Site_created(ctx, field)
			case "updated":
				return ec.fieldContext_Site_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryStudiosResultType_count(ctx context.Context, field graphql.CollectedField, obj *QueryStudiosResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryStudiosResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryStudiosResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryStudiosResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryStudiosResultType_studios(ctx context.Context, field graphql.CollectedField, obj *QueryStudiosResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryStudiosResultType_studios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Studios, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Studio)
	fc.Result = res
	return ec.marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryStudiosResultType_studios(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryStudiosResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryTagCategoriesResultType_count(ctx context.Context, field graphql.CollectedField, obj *QueryTagCategoriesResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryTagCategoriesResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryTagCategoriesResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryTagCategoriesResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryTagCategoriesResultType_tag_categories(ctx context.Context, field graphql.CollectedField, obj *QueryTagCategoriesResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryTagCategoriesResultType_tag_categories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagCategories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TagCategory)
	fc.Result = res
	return ec.marshalNTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryTagCategoriesResultType_tag_categories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryTagCategoriesResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TagCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_TagCategory_name(ctx, field)
			case "group":
				return ec.fieldContext_TagCategory_group(ctx, field)
			case "description":
				return ec.fieldContext_TagCategory_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryTagsResultType_count(ctx context.Context, field graphql.CollectedField, obj *QueryTagsResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryTagsResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryTagsResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryTagsResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryTagsResultType_tags(ctx context.Context, field graphql.CollectedField, obj *QueryTagsResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryTagsResultType_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryTagsResultType_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryTagsResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryUsersResultType_count(ctx context.Context, field graphql.CollectedField, obj *QueryUsersResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryUsersResultType_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryUsersResultType_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryUsersResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QueryUsersResultType_users(ctx context.Context, field graphql.CollectedField, obj *QueryUsersResultType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_QueryUsersResultType_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*User)
	fc.Result = res
	return ec.marshalNUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_QueryUsersResultType_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QueryUsersResultType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_id(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_title(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Title(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_details(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Details(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_date(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Date(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_release_date(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_release_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().ReleaseDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_release_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_production_date(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_production_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().ProductionDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_production_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_urls(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_studio(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_studio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Studio(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_studio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_tags(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_images(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_performers(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Performers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*PerformerAppearance)
	fc.Result = res
	return ec.marshalNPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "performer":
				return ec.fieldContext_PerformerAppearance_performer(ctx, field)
			case "as":
				return ec.fieldContext_PerformerAppearance_as(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PerformerAppearance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_fingerprints(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_fingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Fingerprints(rctx, obj, fc.Args["is_submitted"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Fingerprint)
	fc.Result = res
	return ec.marshalNFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_fingerprints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Fingerprint_hash(ctx, field)
			case "algorithm":
				return ec.fieldContext_Fingerprint_algorithm(ctx, field)
			case "duration":
				return ec.fieldContext_Fingerprint_duration(ctx, field)
			case "submissions":
				return ec.fieldContext_Fingerprint_submissions(ctx, field)
			case "reports":
				return ec.fieldContext_Fingerprint_reports(ctx, field)
			case "created":
				return ec.fieldContext_Fingerprint_created(ctx, field)
			case "updated":
				return ec.fieldContext_Fingerprint_updated(ctx, field)
			case "user_submitted":
				return ec.fieldContext_Fingerprint_user_submitted(ctx, field)
			case "user_reported":
				return ec.fieldContext_Fingerprint_user_reported(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Fingerprint", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Scene_fingerprints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Scene_duration(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Duration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_director(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_director(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Director(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_director(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_code(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Code(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_deleted(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_deleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_edits(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_edits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Edits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_edits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_created(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Scene_updated(ctx context.Context, field graphql.CollectedField, obj *Scene) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Scene_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Scene().Updated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Scene_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Scene",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_id(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_title(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_code(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_details(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_director(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_director(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Director, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_director(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_urls(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_date(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_production_date(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_production_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProductionDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_production_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_studio(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_studio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneDraft().Studio(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(SceneDraftStudio)
	fc.Result = res
	return ec.marshalOSceneDraftStudio2githubcomstashappstashboxpkgmodelsSceneDraftStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_studio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SceneDraftStudio does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_performers(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneDraft().Performers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]SceneDraftPerformer)
	fc.Result = res
	return ec.marshalNSceneDraftPerformer2githubcomstashappstashboxpkgmodelsSceneDraftPerformer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SceneDraftPerformer does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_tags(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneDraft().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]SceneDraftTag)
	fc.Result = res
	return ec.marshalOSceneDraftTag2githubcomstashappstashboxpkgmodelsSceneDraftTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SceneDraftTag does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_image(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneDraft().Image(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneDraft_fingerprints(ctx context.Context, field graphql.CollectedField, obj *SceneDraft) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneDraft_fingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fingerprints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]DraftFingerprint)
	fc.Result = res
	return ec.marshalNDraftFingerprint2githubcomstashappstashboxpkgmodelsDraftFingerprint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneDraft_fingerprints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneDraft",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_DraftFingerprint_hash(ctx, field)
			case "algorithm":
				return ec.fieldContext_DraftFingerprint_algorithm(ctx, field)
			case "duration":
				return ec.fieldContext_DraftFingerprint_duration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DraftFingerprint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_title(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_details(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_added_urls(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_added_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedUrls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_added_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_removed_urls(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_removed_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedUrls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_removed_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_date(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_production_date(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_production_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProductionDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_production_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_studio(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_studio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().Studio(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_studio(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_added_performers(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_added_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().AddedPerformers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*PerformerAppearance)
	fc.Result = res
	return ec.marshalOPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_added_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "performer":
				return ec.fieldContext_PerformerAppearance_performer(ctx, field)
			case "as":
				return ec.fieldContext_PerformerAppearance_as(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PerformerAppearance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_removed_performers(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_removed_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().RemovedPerformers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*PerformerAppearance)
	fc.Result = res
	return ec.marshalOPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_removed_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "performer":
				return ec.fieldContext_PerformerAppearance_performer(ctx, field)
			case "as":
				return ec.fieldContext_PerformerAppearance_as(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PerformerAppearance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_added_tags(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_added_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().AddedTags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_added_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_removed_tags(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_removed_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().RemovedTags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_removed_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_added_images(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_added_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().AddedImages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_added_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_removed_images(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_removed_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().RemovedImages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_removed_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_added_fingerprints(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_added_fingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().AddedFingerprints(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Fingerprint)
	fc.Result = res
	return ec.marshalOFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_added_fingerprints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Fingerprint_hash(ctx, field)
			case "algorithm":
				return ec.fieldContext_Fingerprint_algorithm(ctx, field)
			case "duration":
				return ec.fieldContext_Fingerprint_duration(ctx, field)
			case "submissions":
				return ec.fieldContext_Fingerprint_submissions(ctx, field)
			case "reports":
				return ec.fieldContext_Fingerprint_reports(ctx, field)
			case "created":
				return ec.fieldContext_Fingerprint_created(ctx, field)
			case "updated":
				return ec.fieldContext_Fingerprint_updated(ctx, field)
			case "user_submitted":
				return ec.fieldContext_Fingerprint_user_submitted(ctx, field)
			case "user_reported":
				return ec.fieldContext_Fingerprint_user_reported(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Fingerprint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_removed_fingerprints(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_removed_fingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().RemovedFingerprints(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Fingerprint)
	fc.Result = res
	return ec.marshalOFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_removed_fingerprints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Fingerprint_hash(ctx, field)
			case "algorithm":
				return ec.fieldContext_Fingerprint_algorithm(ctx, field)
			case "duration":
				return ec.fieldContext_Fingerprint_duration(ctx, field)
			case "submissions":
				return ec.fieldContext_Fingerprint_submissions(ctx, field)
			case "reports":
				return ec.fieldContext_Fingerprint_reports(ctx, field)
			case "created":
				return ec.fieldContext_Fingerprint_created(ctx, field)
			case "updated":
				return ec.fieldContext_Fingerprint_updated(ctx, field)
			case "user_submitted":
				return ec.fieldContext_Fingerprint_user_submitted(ctx, field)
			case "user_reported":
				return ec.fieldContext_Fingerprint_user_reported(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Fingerprint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_duration(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_director(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_director(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Director, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_director(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_code(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_draft_id(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_draft_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DraftID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_draft_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_urls(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_performers(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().Performers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*PerformerAppearance)
	fc.Result = res
	return ec.marshalNPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_performers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "performer":
				return ec.fieldContext_PerformerAppearance_performer(ctx, field)
			case "as":
				return ec.fieldContext_PerformerAppearance_as(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PerformerAppearance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_tags(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			case "aliases":
				return ec.fieldContext_Tag_aliases(ctx, field)
			case "deleted":
				return ec.fieldContext_Tag_deleted(ctx, field)
			case "edits":
				return ec.fieldContext_Tag_edits(ctx, field)
			case "category":
				return ec.fieldContext_Tag_category(ctx, field)
			case "created":
				return ec.fieldContext_Tag_created(ctx, field)
			case "updated":
				return ec.fieldContext_Tag_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_images(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SceneEdit_fingerprints(ctx context.Context, field graphql.CollectedField, obj *SceneEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SceneEdit_fingerprints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SceneEdit().Fingerprints(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Fingerprint)
	fc.Result = res
	return ec.marshalNFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SceneEdit_fingerprints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SceneEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Fingerprint_hash(ctx, field)
			case "algorithm":
				return ec.fieldContext_Fingerprint_algorithm(ctx, field)
			case "duration":
				return ec.fieldContext_Fingerprint_duration(ctx, field)
			case "submissions":
				return ec.fieldContext_Fingerprint_submissions(ctx, field)
			case "reports":
				return ec.fieldContext_Fingerprint_reports(ctx, field)
			case "created":
				return ec.fieldContext_Fingerprint_created(ctx, field)
			case "updated":
				return ec.fieldContext_Fingerprint_updated(ctx, field)
			case "user_submitted":
				return ec.fieldContext_Fingerprint_user_submitted(ctx, field)
			case "user_reported":
				return ec.fieldContext_Fingerprint_user_reported(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Fingerprint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_id(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_name(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_description(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().Description(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_url(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().URL(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_regex(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_regex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().Regex(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_regex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_valid_types(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_valid_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().ValidTypes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ValidSiteTypeEnum)
	fc.Result = res
	return ec.marshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_valid_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ValidSiteTypeEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_icon(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_icon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().Icon(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_icon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_created(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Site_updated(ctx context.Context, field graphql.CollectedField, obj *Site) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Site_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Site().Updated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Site_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Site",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_host_url(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_host_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_host_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_require_invite(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_require_invite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequireInvite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_require_invite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_require_activation(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_require_activation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequireActivation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_require_activation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_vote_promotion_threshold(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_vote_promotion_threshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VotePromotionThreshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_vote_promotion_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_vote_application_threshold(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_vote_application_threshold(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteApplicationThreshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_vote_application_threshold(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_voting_period(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_voting_period(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VotingPeriod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_voting_period(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_min_destructive_voting_period(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_min_destructive_voting_period(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinDestructiveVotingPeriod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_min_destructive_voting_period(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_vote_cron_interval(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_vote_cron_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteCronInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_vote_cron_interval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_guidelines_url(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_guidelines_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GuidelinesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_guidelines_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_require_scene_draft(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_require_scene_draft(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequireSceneDraft, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_require_scene_draft(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StashBoxConfig_edit_update_limit(ctx context.Context, field graphql.CollectedField, obj *StashBoxConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StashBoxConfig_edit_update_limit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditUpdateLimit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StashBoxConfig_edit_update_limit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StashBoxConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_id(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_name(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_aliases(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_urls(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_parent(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Parent(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_parent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_child_studios(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_child_studios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().ChildStudios(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Studio)
	fc.Result = res
	return ec.marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_child_studios(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_images(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_deleted(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_deleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_is_favorite(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_is_favorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().IsFavorite(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_is_favorite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_created(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_updated(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Updated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Studio_performers(ctx context.Context, field graphql.CollectedField, obj *Studio) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Studio_performers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Studio().Performers(rctx, obj, fc.Args["input"].(PerformerQueryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PerformerQuery)
	fc.Result = res
	return ec.marshalNQueryPerformersResultType2githubcomstashappstashboxpkgmodelsPerformerQuery(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Studio_performers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Studio",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_QueryPerformersResultType_count(ctx, field)
			case "performers":
				return ec.fieldContext_QueryPerformersResultType_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QueryPerformersResultType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Studio_performers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_name(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_added_urls(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_added_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedUrls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_added_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_removed_urls(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_removed_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedUrls, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_removed_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_parent(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StudioEdit().Parent(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Studio)
	fc.Result = res
	return ec.marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_parent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Studio_id(ctx, field)
			case "name":
				return ec.fieldContext_Studio_name(ctx, field)
			case "aliases":
				return ec.fieldContext_Studio_aliases(ctx, field)
			case "urls":
				return ec.fieldContext_Studio_urls(ctx, field)
			case "parent":
				return ec.fieldContext_Studio_parent(ctx, field)
			case "child_studios":
				return ec.fieldContext_Studio_child_studios(ctx, field)
			case "images":
				return ec.fieldContext_Studio_images(ctx, field)
			case "deleted":
				return ec.fieldContext_Studio_deleted(ctx, field)
			case "is_favorite":
				return ec.fieldContext_Studio_is_favorite(ctx, field)
			case "created":
				return ec.fieldContext_Studio_created(ctx, field)
			case "updated":
				return ec.fieldContext_Studio_updated(ctx, field)
			case "performers":
				return ec.fieldContext_Studio_performers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Studio", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_added_images(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_added_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StudioEdit().AddedImages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_added_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_removed_images(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_removed_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StudioEdit().RemovedImages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_removed_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_added_aliases(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_added_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_added_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_removed_aliases(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_removed_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_removed_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_images(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StudioEdit().Images(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Image)
	fc.Result = res
	return ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "url":
				return ec.fieldContext_Image_url(ctx, field)
			case "width":
				return ec.fieldContext_Image_width(ctx, field)
			case "height":
				return ec.fieldContext_Image_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudioEdit_urls(ctx context.Context, field graphql.CollectedField, obj *StudioEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudioEdit_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StudioEdit().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*URL)
	fc.Result = res
	return ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudioEdit_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudioEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_URL_url(ctx, field)
			case "type":
				return ec.fieldContext_URL_type(ctx, field)
			case "site":
				return ec.fieldContext_URL_site(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type URL", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_description(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Description(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_aliases(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_deleted(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_deleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_edits(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_edits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Edits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_edits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_category(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Category(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TagCategory)
	fc.Result = res
	return ec.marshalOTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TagCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_TagCategory_name(ctx, field)
			case "group":
				return ec.fieldContext_TagCategory_group(ctx, field)
			case "description":
				return ec.fieldContext_TagCategory_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_created(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Created(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_updated(ctx context.Context, field graphql.CollectedField, obj *Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Updated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagCategory_id(ctx context.Context, field graphql.CollectedField, obj *TagCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagCategory_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagCategory_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagCategory_name(ctx context.Context, field graphql.CollectedField, obj *TagCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagCategory_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagCategory_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagCategory_group(ctx context.Context, field graphql.CollectedField, obj *TagCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagCategory_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagCategory().Group(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TagGroupEnum)
	fc.Result = res
	return ec.marshalNTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagCategory_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TagGroupEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagCategory_description(ctx context.Context, field graphql.CollectedField, obj *TagCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagCategory_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagCategory().Description(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagCategory_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdit_name(ctx context.Context, field graphql.CollectedField, obj *TagEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdit_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdit_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdit_description(ctx context.Context, field graphql.CollectedField, obj *TagEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdit_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdit_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdit_added_aliases(ctx context.Context, field graphql.CollectedField, obj *TagEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdit_added_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddedAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdit_added_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdit_removed_aliases(ctx context.Context, field graphql.CollectedField, obj *TagEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdit_removed_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemovedAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdit_removed_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdit_category(ctx context.Context, field graphql.CollectedField, obj *TagEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdit_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagEdit().Category(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TagCategory)
	fc.Result = res
	return ec.marshalOTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdit_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TagCategory_id(ctx, field)
			case "name":
				return ec.fieldContext_TagCategory_name(ctx, field)
			case "group":
				return ec.fieldContext_TagCategory_group(ctx, field)
			case "description":
				return ec.fieldContext_TagCategory_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdit_aliases(ctx context.Context, field graphql.CollectedField, obj *TagEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdit_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TagEdit().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdit_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _URL_url(ctx context.Context, field graphql.CollectedField, obj *URL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_URL_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_URL_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "URL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _URL_type(ctx context.Context, field graphql.CollectedField, obj *URL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_URL_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.URL().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_URL_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "URL",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _URL_site(ctx context.Context, field graphql.CollectedField, obj *URL) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_URL_site(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.URL().Site(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Site)
	fc.Result = res
	return ec.marshalNSite2githubcomstashappstashboxpkgmodelsSite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_URL_site(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "URL",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Site_id(ctx, field)
			case "name":
				return ec.fieldContext_Site_name(ctx, field)
			case "description":
				return ec.fieldContext_Site_description(ctx, field)
			case "url":
				return ec.fieldContext_Site_url(ctx, field)
			case "regex":
				return ec.fieldContext_Site_regex(ctx, field)
			case "valid_types":
				return ec.fieldContext_Site_valid_types(ctx, field)
			case "icon":
				return ec.fieldContext_Site_icon(ctx, field)
			case "created":
				return ec.fieldContext_Site_created(ctx, field)
			case "updated":
				return ec.fieldContext_Site_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Site", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdatedEdit_edit(ctx context.Context, field graphql.CollectedField, obj *UpdatedEdit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdatedEdit_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Edit)
	fc.Result = res
	return ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdatedEdit_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdatedEdit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Edit_id(ctx, field)
			case "user":
				return ec.fieldContext_Edit_user(ctx, field)
			case "target":
				return ec.fieldContext_Edit_target(ctx, field)
			case "target_type":
				return ec.fieldContext_Edit_target_type(ctx, field)
			case "merge_sources":
				return ec.fieldContext_Edit_merge_sources(ctx, field)
			case "operation":
				return ec.fieldContext_Edit_operation(ctx, field)
			case "bot":
				return ec.fieldContext_Edit_bot(ctx, field)
			case "details":
				return ec.fieldContext_Edit_details(ctx, field)
			case "old_details":
				return ec.fieldContext_Edit_old_details(ctx, field)
			case "options":
				return ec.fieldContext_Edit_options(ctx, field)
			case "comments":
				return ec.fieldContext_Edit_comments(ctx, field)
			case "votes":
				return ec.fieldContext_Edit_votes(ctx, field)
			case "vote_count":
				return ec.fieldContext_Edit_vote_count(ctx, field)
			case "destructive":
				return ec.fieldContext_Edit_destructive(ctx, field)
			case "status":
				return ec.fieldContext_Edit_status(ctx, field)
			case "applied":
				return ec.fieldContext_Edit_applied(ctx, field)
			case "update_count":
				return ec.fieldContext_Edit_update_count(ctx, field)
			case "updatable":
				return ec.fieldContext_Edit_updatable(ctx, field)
			case "created":
				return ec.fieldContext_Edit_created(ctx, field)
			case "updated":
				return ec.fieldContext_Edit_updated(ctx, field)
			case "closed":
				return ec.fieldContext_Edit_closed(ctx, field)
			case "expires":
				return ec.fieldContext_Edit_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Edit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNID2githubcomgofrsuuidUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().Roles(rctx, obj)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal []RoleEnum
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]RoleEnum); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/stashapp/stash-box/pkg/models.RoleEnum`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]RoleEnum)
	fc.Result = res
	return ec.marshalORoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoleEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Email, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal string
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_api_key(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_api_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.APIKey, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal string
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_api_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_notification_subscriptions(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_notification_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().NotificationSubscriptions(rctx, obj)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal []NotificationEnum
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]NotificationEnum); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/stashapp/stash-box/pkg/models.NotificationEnum`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]NotificationEnum)
	fc.Result = res
	return ec.marshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_notification_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NotificationEnum does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_vote_count(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_vote_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().VoteCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserVoteCount)
	fc.Result = res
	return ec.marshalNUserVoteCount2githubcomstashappstashboxpkgmodelsUserVoteCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_vote_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "abstain":
				return ec.fieldContext_UserVoteCount_abstain(ctx, field)
			case "accept":
				return ec.fieldContext_UserVoteCount_accept(ctx, field)
			case "reject":
				return ec.fieldContext_UserVoteCount_reject(ctx, field)
			case "immediate_accept":
				return ec.fieldContext_UserVoteCount_immediate_accept(ctx, field)
			case "immediate_reject":
				return ec.fieldContext_UserVoteCount_immediate_reject(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserVoteCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_edit_count(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_edit_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().EditCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*UserEditCount)
	fc.Result = res
	return ec.marshalNUserEditCount2githubcomstashappstashboxpkgmodelsUserEditCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_edit_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accepted":
				return ec.fieldContext_UserEditCount_accepted(ctx, field)
			case "rejected":
				return ec.fieldContext_UserEditCount_rejected(ctx, field)
			case "pending":
				return ec.fieldContext_UserEditCount_pending(ctx, field)
			case "immediate_accepted":
				return ec.fieldContext_UserEditCount_immediate_accepted(ctx, field)
			case "immediate_rejected":
				return ec.fieldContext_UserEditCount_immediate_rejected(ctx, field)
			case "failed":
				return ec.fieldContext_UserEditCount_failed(ctx, field)
			case "canceled":
				return ec.fieldContext_UserEditCount_canceled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEditCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_api_calls(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_api_calls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.APICalls, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal int
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_api_calls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_invited_by(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_invited_by(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().InvitedBy(rctx, obj)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal *User
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/stashapp/stash-box/pkg/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	fc.Result = res
	return ec.marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_invited_by(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "api_key":
				return ec.fieldContext_User_api_key(ctx, field)
			case "notification_subscriptions":
				return ec.fieldContext_User_notification_subscriptions(ctx, field)
			case "vote_count":
				return ec.fieldContext_User_vote_count(ctx, field)
			case "edit_count":
				return ec.fieldContext_User_edit_count(ctx, field)
			case "api_calls":
				return ec.fieldContext_User_api_calls(ctx, field)
			case "invited_by":
				return ec.fieldContext_User_invited_by(ctx, field)
			case "invite_tokens":
				return ec.fieldContext_User_invite_tokens(ctx, field)
			case "active_invite_codes":
				return ec.fieldContext_User_active_invite_codes(ctx, field)
			case "invite_codes":
				return ec.fieldContext_User_invite_codes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_invite_tokens(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_invite_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.InviteTokens, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal int
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_invite_tokens(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_active_invite_codes(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_active_invite_codes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().ActiveInviteCodes(rctx, obj)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal []string
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_active_invite_codes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_invite_codes(ctx context.Context, field graphql.CollectedField, obj *User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_invite_codes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.User().InviteCodes(rctx, obj)
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsUserOwner == nil {
				var zeroVal []*InviteKey
				return zeroVal, errors.New("directive isUserOwner is not implemented")
			}
			return ec.directives.IsUserOwner(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*InviteKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/stashapp/stash-box/pkg/models.InviteKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*InviteKey)
	fc.Result = res
	return ec.marshalOInviteKey2githubcomstashappstashboxpkgmodelsInviteKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_invite_codes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_InviteKey_id(ctx, field)
			case "uses":
				return ec.fieldContext_InviteKey_uses(ctx, field)
			case "expires":
				return ec.fieldContext_InviteKey_expires(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InviteKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_accepted(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_accepted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accepted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_accepted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_rejected(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_rejected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_pending(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_pending(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pending, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_pending(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_immediate_accepted(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_immediate_accepted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImmediateAccepted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_immediate_accepted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_immediate_rejected(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_immediate_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImmediateRejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_immediate_rejected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_failed(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_failed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEditCount_canceled(ctx context.Context, field graphql.CollectedField, obj *UserEditCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEditCount_canceled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Canceled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEditCount_canceled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEditCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserVoteCount_abstain(ctx context.Context, field graphql.CollectedField, obj *UserVoteCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserVoteCount_abstain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abstain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserVoteCount_abstain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserVoteCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserVoteCount_accept(ctx context.Context, field graphql.CollectedField, obj *UserVoteCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserVoteCount_accept(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accept, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserVoteCount_accept(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserVoteCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserVoteCount_reject(ctx context.Context, field graphql.CollectedField, obj *UserVoteCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserVoteCount_reject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserVoteCount_reject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserVoteCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserVoteCount_immediate_accept(ctx context.Context, field graphql.CollectedField, obj *UserVoteCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserVoteCount_immediate_accept(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImmediateAccept, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserVoteCount_immediate_accept(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserVoteCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserVoteCount_immediate_reject(ctx context.Context, field graphql.CollectedField, obj *UserVoteCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserVoteCount_immediate_reject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImmediateReject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserVoteCount_immediate_reject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserVoteCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_hash(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_build_time(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_build_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_build_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_build_type(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_build_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_build_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_version(ctx context.Context, field graphql.CollectedField, obj *Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputActivateNewUserInput(ctx context.Context, obj interface{}) (ActivateNewUserInput, error) {
	var it ActivateNewUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "activation_key", "password"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "activation_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("activation_key"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ActivationKey = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputApplyEditInput(ctx context.Context, obj interface{}) (ApplyEditInput, error) {
	var it ApplyEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBodyModificationCriterionInput(ctx context.Context, obj interface{}) (BodyModificationCriterionInput, error) {
	var it BodyModificationCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"location", "description", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBodyModificationInput(ctx context.Context, obj interface{}) (BodyModification, error) {
	var it BodyModification
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"location", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBreastTypeCriterionInput(ctx context.Context, obj interface{}) (BreastTypeCriterionInput, error) {
	var it BreastTypeCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCancelEditInput(ctx context.Context, obj interface{}) (CancelEditInput, error) {
	var it CancelEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDateCriterionInput(ctx context.Context, obj interface{}) (DateCriterionInput, error) {
	var it DateCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNDate2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDraftEntityInput(ctx context.Context, obj interface{}) (DraftEntityInput, error) {
	var it DraftEntityInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditCommentInput(ctx context.Context, obj interface{}) (EditCommentInput, error) {
	var it EditCommentInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditInput(ctx context.Context, obj interface{}) (EditInput, error) {
	var it EditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "operation", "merge_source_ids", "comment", "bot"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "operation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operation"))
			data, err := ec.unmarshalNOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operation = data
		case "merge_source_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merge_source_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.MergeSourceIds = data
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comment = data
		case "bot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bot"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bot = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditQueryInput(ctx context.Context, obj interface{}) (EditQueryInput, error) {
	var it EditQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}
	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "DESC"
	}
	if _, present := asMap["sort"]; !present {
		asMap["sort"] = "CREATED_AT"
	}

	fieldsInOrder := [...]string{"user_id", "status", "operation", "vote_count", "applied", "target_type", "target_id", "is_favorite", "voted", "is_bot", "include_user_submitted", "page", "per_page", "direction", "sort"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOVoteStatusEnum2githubcomstashappstashboxpkgmodelsVoteStatusEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "operation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operation"))
			data, err := ec.unmarshalOOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Operation = data
		case "vote_count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vote_count"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.VoteCount = data
		case "applied":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applied"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Applied = data
		case "target_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_type"))
			data, err := ec.unmarshalOTargetTypeEnum2githubcomstashappstashboxpkgmodelsTargetTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetType = data
		case "target_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetID = data
		case "is_favorite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("is_favorite"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFavorite = data
		case "voted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("voted"))
			data, err := ec.unmarshalOUserVotedFilterEnum2githubcomstashappstashboxpkgmodelsUserVotedFilterEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Voted = data
		case "is_bot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("is_bot"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsBot = data
		case "include_user_submitted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("include_user_submitted"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeUserSubmitted = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNEditSortEnum2githubcomstashappstashboxpkgmodelsEditSortEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditVoteInput(ctx context.Context, obj interface{}) (EditVoteInput, error) {
	var it EditVoteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "vote"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "vote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vote"))
			data, err := ec.unmarshalNVoteTypeEnum2githubcomstashappstashboxpkgmodelsVoteTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vote = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEyeColorCriterionInput(ctx context.Context, obj interface{}) (EyeColorCriterionInput, error) {
	var it EyeColorCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFingerprintEditInput(ctx context.Context, obj interface{}) (FingerprintEditInput, error) {
	var it FingerprintEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user_ids", "hash", "algorithm", "duration", "created", "submissions", "updated"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIds = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "algorithm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("algorithm"))
			data, err := ec.unmarshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx, v)
			if err != nil {
				return it, err
			}
			it.Algorithm = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "created":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("created"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Created = data
		case "submissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("submissions"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Submissions = data
		case "updated":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updated"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Updated = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFingerprintInput(ctx context.Context, obj interface{}) (FingerprintInput, error) {
	var it FingerprintInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user_ids", "hash", "algorithm", "duration"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIds = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "algorithm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("algorithm"))
			data, err := ec.unmarshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx, v)
			if err != nil {
				return it, err
			}
			it.Algorithm = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFingerprintQueryInput(ctx context.Context, obj interface{}) (FingerprintQueryInput, error) {
	var it FingerprintQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hash", "algorithm"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "algorithm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("algorithm"))
			data, err := ec.unmarshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx, v)
			if err != nil {
				return it, err
			}
			it.Algorithm = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFingerprintSubmission(ctx context.Context, obj interface{}) (FingerprintSubmission, error) {
	var it FingerprintSubmission
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["vote"]; !present {
		asMap["vote"] = "VALID"
	}

	fieldsInOrder := [...]string{"scene_id", "fingerprint", "unmatch", "vote"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "scene_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scene_id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SceneID = data
		case "fingerprint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprint"))
			data, err := ec.unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprint = data
		case "unmatch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unmatch"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Unmatch = data
		case "vote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vote"))
			data, err := ec.unmarshalOFingerprintSubmissionType2githubcomstashappstashboxpkgmodelsFingerprintSubmissionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vote = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGenerateInviteCodeInput(ctx context.Context, obj interface{}) (GenerateInviteCodeInput, error) {
	var it GenerateInviteCodeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"keys", "uses", "ttl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "keys":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keys"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Keys = data
		case "uses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uses"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Uses = data
		case "ttl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ttl"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TTL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGrantInviteInput(ctx context.Context, obj interface{}) (GrantInviteInput, error) {
	var it GrantInviteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user_id", "amount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHairColorCriterionInput(ctx context.Context, obj interface{}) (HairColorCriterionInput, error) {
	var it HairColorCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIDCriterionInput(ctx context.Context, obj interface{}) (IDCriterionInput, error) {
	var it IDCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageCreateInput(ctx context.Context, obj interface{}) (ImageCreateInput, error) {
	var it ImageCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "file"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "file":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
			data, err := ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.File = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageDestroyInput(ctx context.Context, obj interface{}) (ImageDestroyInput, error) {
	var it ImageDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageUpdateInput(ctx context.Context, obj interface{}) (ImageUpdateInput, error) {
	var it ImageUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntCriterionInput(ctx context.Context, obj interface{}) (IntCriterionInput, error) {
	var it IntCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMultiIDCriterionInput(ctx context.Context, obj interface{}) (MultiIDCriterionInput, error) {
	var it MultiIDCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMultiStringCriterionInput(ctx context.Context, obj interface{}) (MultiStringCriterionInput, error) {
	var it MultiStringCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNewUserInput(ctx context.Context, obj interface{}) (NewUserInput, error) {
	var it NewUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "invite_key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "invite_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invite_key"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.InviteKey = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerAppearanceInput(ctx context.Context, obj interface{}) (PerformerAppearanceInput, error) {
	var it PerformerAppearanceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"performer_id", "as"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "performer_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performer_id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerformerID = data
		case "as":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("as"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.As = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerCreateInput(ctx context.Context, obj interface{}) (PerformerCreateInput, error) {
	var it PerformerCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "disambiguation", "aliases", "gender", "urls", "birthdate", "deathdate", "ethnicity", "country", "eye_color", "hair_color", "height", "cup_size", "band_size", "waist_size", "hip_size", "breast_type", "career_start_year", "career_end_year", "tattoos", "piercings", "image_ids", "draft_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "disambiguation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disambiguation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disambiguation = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "gender":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "birthdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthdate = data
		case "deathdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deathdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deathdate = data
		case "ethnicity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ethnicity"))
			data, err := ec.unmarshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ethnicity = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "eye_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eye_color"))
			data, err := ec.unmarshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.EyeColor = data
		case "hair_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hair_color"))
			data, err := ec.unmarshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.HairColor = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cup_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cup_size"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CupSize = data
		case "band_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("band_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BandSize = data
		case "waist_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("waist_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.WaistSize = data
		case "hip_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hip_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HipSize = data
		case "breast_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("breast_type"))
			data, err := ec.unmarshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.BreastType = data
		case "career_start_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_start_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerStartYear = data
		case "career_end_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_end_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerEndYear = data
		case "tattoos":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tattoos"))
			data, err := ec.unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tattoos = data
		case "piercings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("piercings"))
			data, err := ec.unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, v)
			if err != nil {
				return it, err
			}
			it.Piercings = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		case "draft_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("draft_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.DraftID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerDestroyInput(ctx context.Context, obj interface{}) (PerformerDestroyInput, error) {
	var it PerformerDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerDraftInput(ctx context.Context, obj interface{}) (PerformerDraftInput, error) {
	var it PerformerDraftInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "disambiguation", "name", "aliases", "gender", "birthdate", "deathdate", "urls", "ethnicity", "country", "eye_color", "hair_color", "height", "measurements", "breast_type", "tattoos", "piercings", "career_start_year", "career_end_year", "image"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "disambiguation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disambiguation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disambiguation = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "gender":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "birthdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthdate = data
		case "deathdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deathdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deathdate = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "ethnicity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ethnicity"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ethnicity = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "eye_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eye_color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EyeColor = data
		case "hair_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hair_color"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HairColor = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "measurements":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("measurements"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Measurements = data
		case "breast_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("breast_type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BreastType = data
		case "tattoos":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tattoos"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tattoos = data
		case "piercings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("piercings"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Piercings = data
		case "career_start_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_start_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerStartYear = data
		case "career_end_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_end_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerEndYear = data
		case "image":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image"))
			data, err := ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Image = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerEditDetailsInput(ctx context.Context, obj interface{}) (PerformerEditDetailsInput, error) {
	var it PerformerEditDetailsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "disambiguation", "aliases", "gender", "urls", "birthdate", "deathdate", "ethnicity", "country", "eye_color", "hair_color", "height", "cup_size", "band_size", "waist_size", "hip_size", "breast_type", "career_start_year", "career_end_year", "tattoos", "piercings", "image_ids", "draft_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "disambiguation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disambiguation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disambiguation = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "gender":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "birthdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthdate = data
		case "deathdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deathdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deathdate = data
		case "ethnicity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ethnicity"))
			data, err := ec.unmarshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ethnicity = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "eye_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eye_color"))
			data, err := ec.unmarshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.EyeColor = data
		case "hair_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hair_color"))
			data, err := ec.unmarshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.HairColor = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cup_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cup_size"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CupSize = data
		case "band_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("band_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BandSize = data
		case "waist_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("waist_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.WaistSize = data
		case "hip_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hip_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HipSize = data
		case "breast_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("breast_type"))
			data, err := ec.unmarshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.BreastType = data
		case "career_start_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_start_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerStartYear = data
		case "career_end_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_end_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerEndYear = data
		case "tattoos":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tattoos"))
			data, err := ec.unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tattoos = data
		case "piercings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("piercings"))
			data, err := ec.unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, v)
			if err != nil {
				return it, err
			}
			it.Piercings = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		case "draft_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("draft_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.DraftID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerEditInput(ctx context.Context, obj interface{}) (PerformerEditInput, error) {
	var it PerformerEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"edit", "details", "options"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "edit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("edit"))
			data, err := ec.unmarshalNEditInput2githubcomstashappstashboxpkgmodelsEditInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Edit = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOPerformerEditDetailsInput2githubcomstashappstashboxpkgmodelsPerformerEditDetailsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		case "options":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			data, err := ec.unmarshalOPerformerEditOptionsInput2githubcomstashappstashboxpkgmodelsPerformerEditOptionsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Options = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerEditOptionsInput(ctx context.Context, obj interface{}) (PerformerEditOptionsInput, error) {
	var it PerformerEditOptionsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["set_modify_aliases"]; !present {
		asMap["set_modify_aliases"] = false
	}
	if _, present := asMap["set_merge_aliases"]; !present {
		asMap["set_merge_aliases"] = true
	}

	fieldsInOrder := [...]string{"set_modify_aliases", "set_merge_aliases"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "set_modify_aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set_modify_aliases"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetModifyAliases = data
		case "set_merge_aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set_merge_aliases"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetMergeAliases = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerQueryInput(ctx context.Context, obj interface{}) (PerformerQueryInput, error) {
	var it PerformerQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}
	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "DESC"
	}
	if _, present := asMap["sort"]; !present {
		asMap["sort"] = "CREATED_AT"
	}

	fieldsInOrder := [...]string{"names", "name", "alias", "disambiguation", "gender", "url", "birthdate", "deathdate", "birth_year", "age", "ethnicity", "country", "eye_color", "hair_color", "height", "cup_size", "band_size", "waist_size", "hip_size", "breast_type", "career_start_year", "career_end_year", "tattoos", "piercings", "is_favorite", "performed_with", "studio_id", "page", "per_page", "direction", "sort"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "names":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("names"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Names = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "disambiguation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disambiguation"))
			data, err := ec.unmarshalOStringCriterionInput2githubcomstashappstashboxpkgmodelsStringCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disambiguation = data
		case "gender":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGenderFilterEnum2githubcomstashappstashboxpkgmodelsGenderFilterEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "birthdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthdate"))
			data, err := ec.unmarshalODateCriterionInput2githubcomstashappstashboxpkgmodelsDateCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthdate = data
		case "deathdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deathdate"))
			data, err := ec.unmarshalODateCriterionInput2githubcomstashappstashboxpkgmodelsDateCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deathdate = data
		case "birth_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birth_year"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthYear = data
		case "age":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("age"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Age = data
		case "ethnicity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ethnicity"))
			data, err := ec.unmarshalOEthnicityFilterEnum2githubcomstashappstashboxpkgmodelsEthnicityFilterEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ethnicity = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOStringCriterionInput2githubcomstashappstashboxpkgmodelsStringCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "eye_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eye_color"))
			data, err := ec.unmarshalOEyeColorCriterionInput2githubcomstashappstashboxpkgmodelsEyeColorCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.EyeColor = data
		case "hair_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hair_color"))
			data, err := ec.unmarshalOHairColorCriterionInput2githubcomstashappstashboxpkgmodelsHairColorCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HairColor = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cup_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cup_size"))
			data, err := ec.unmarshalOStringCriterionInput2githubcomstashappstashboxpkgmodelsStringCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CupSize = data
		case "band_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("band_size"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.BandSize = data
		case "waist_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("waist_size"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.WaistSize = data
		case "hip_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hip_size"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HipSize = data
		case "breast_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("breast_type"))
			data, err := ec.unmarshalOBreastTypeCriterionInput2githubcomstashappstashboxpkgmodelsBreastTypeCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.BreastType = data
		case "career_start_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_start_year"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerStartYear = data
		case "career_end_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_end_year"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerEndYear = data
		case "tattoos":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tattoos"))
			data, err := ec.unmarshalOBodyModificationCriterionInput2githubcomstashappstashboxpkgmodelsBodyModificationCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tattoos = data
		case "piercings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("piercings"))
			data, err := ec.unmarshalOBodyModificationCriterionInput2githubcomstashappstashboxpkgmodelsBodyModificationCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Piercings = data
		case "is_favorite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("is_favorite"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFavorite = data
		case "performed_with":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performed_with"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerformedWith = data
		case "studio_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.StudioID = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNPerformerSortEnum2githubcomstashappstashboxpkgmodelsPerformerSortEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerScenesInput(ctx context.Context, obj interface{}) (PerformerScenesInput, error) {
	var it PerformerScenesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"performed_with", "studio_id", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "performed_with":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performed_with"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerformedWith = data
		case "studio_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.StudioID = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOMultiIDCriterionInput2githubcomstashappstashboxpkgmodelsMultiIDCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPerformerUpdateInput(ctx context.Context, obj interface{}) (PerformerUpdateInput, error) {
	var it PerformerUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "disambiguation", "aliases", "gender", "urls", "birthdate", "deathdate", "ethnicity", "country", "eye_color", "hair_color", "height", "cup_size", "band_size", "waist_size", "hip_size", "breast_type", "career_start_year", "career_end_year", "tattoos", "piercings", "image_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "disambiguation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disambiguation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disambiguation = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "gender":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gender"))
			data, err := ec.unmarshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gender = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "birthdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Birthdate = data
		case "deathdate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deathdate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deathdate = data
		case "ethnicity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ethnicity"))
			data, err := ec.unmarshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ethnicity = data
		case "country":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("country"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Country = data
		case "eye_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eye_color"))
			data, err := ec.unmarshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.EyeColor = data
		case "hair_color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hair_color"))
			data, err := ec.unmarshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.HairColor = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cup_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cup_size"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CupSize = data
		case "band_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("band_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BandSize = data
		case "waist_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("waist_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.WaistSize = data
		case "hip_size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hip_size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HipSize = data
		case "breast_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("breast_type"))
			data, err := ec.unmarshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.BreastType = data
		case "career_start_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_start_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerStartYear = data
		case "career_end_year":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("career_end_year"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CareerEndYear = data
		case "tattoos":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tattoos"))
			data, err := ec.unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tattoos = data
		case "piercings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("piercings"))
			data, err := ec.unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, v)
			if err != nil {
				return it, err
			}
			it.Piercings = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryExistingPerformerInput(ctx context.Context, obj interface{}) (QueryExistingPerformerInput, error) {
	var it QueryExistingPerformerInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "disambiguation", "urls"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "disambiguation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disambiguation"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disambiguation = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryExistingSceneInput(ctx context.Context, obj interface{}) (QueryExistingSceneInput, error) {
	var it QueryExistingSceneInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "studio_id", "fingerprints"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "studio_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.StudioID = data
		case "fingerprints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
			data, err := ec.unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprints = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQueryNotificationsInput(ctx context.Context, obj interface{}) (QueryNotificationsInput, error) {
	var it QueryNotificationsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}

	fieldsInOrder := [...]string{"page", "per_page", "type", "unread_only"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalONotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "unread_only":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unread_only"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnreadOnly = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResetPasswordInput(ctx context.Context, obj interface{}) (ResetPasswordInput, error) {
	var it ResetPasswordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRevokeInviteInput(ctx context.Context, obj interface{}) (RevokeInviteInput, error) {
	var it RevokeInviteInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"user_id", "amount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "user_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user_id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRoleCriterionInput(ctx context.Context, obj interface{}) (RoleCriterionInput, error) {
	var it RoleCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneCreateInput(ctx context.Context, obj interface{}) (SceneCreateInput, error) {
	var it SceneCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "details", "urls", "date", "production_date", "studio_id", "performers", "tag_ids", "image_ids", "fingerprints", "duration", "director", "code"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "production_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("production_date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProductionDate = data
		case "studio_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.StudioID = data
		case "performers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performers"))
			data, err := ec.unmarshalOPerformerAppearanceInput2githubcomstashappstashboxpkgmodelsPerformerAppearanceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Performers = data
		case "tag_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIds = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		case "fingerprints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
			data, err := ec.unmarshalNFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprints = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "director":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("director"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Director = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneDestroyInput(ctx context.Context, obj interface{}) (SceneDestroyInput, error) {
	var it SceneDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneDraftInput(ctx context.Context, obj interface{}) (SceneDraftInput, error) {
	var it SceneDraftInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "title", "code", "details", "director", "url", "urls", "date", "production_date", "studio", "performers", "tags", "image", "fingerprints"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		case "director":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("director"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Director = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "production_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("production_date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProductionDate = data
		case "studio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio"))
			data, err := ec.unmarshalODraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Studio = data
		case "performers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performers"))
			data, err := ec.unmarshalNDraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Performers = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalODraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "image":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image"))
			data, err := ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, v)
			if err != nil {
				return it, err
			}
			it.Image = data
		case "fingerprints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
			data, err := ec.unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprints = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneEditDetailsInput(ctx context.Context, obj interface{}) (SceneEditDetailsInput, error) {
	var it SceneEditDetailsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"title", "details", "urls", "date", "production_date", "studio_id", "performers", "tag_ids", "image_ids", "duration", "director", "code", "fingerprints", "draft_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "production_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("production_date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProductionDate = data
		case "studio_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.StudioID = data
		case "performers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performers"))
			data, err := ec.unmarshalOPerformerAppearanceInput2githubcomstashappstashboxpkgmodelsPerformerAppearanceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Performers = data
		case "tag_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIds = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "director":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("director"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Director = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "fingerprints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
			data, err := ec.unmarshalOFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprints = data
		case "draft_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("draft_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.DraftID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneEditInput(ctx context.Context, obj interface{}) (SceneEditInput, error) {
	var it SceneEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"edit", "details"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "edit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("edit"))
			data, err := ec.unmarshalNEditInput2githubcomstashappstashboxpkgmodelsEditInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Edit = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOSceneEditDetailsInput2githubcomstashappstashboxpkgmodelsSceneEditDetailsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneQueryInput(ctx context.Context, obj interface{}) (SceneQueryInput, error) {
	var it SceneQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["has_fingerprint_submissions"]; !present {
		asMap["has_fingerprint_submissions"] = "False"
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}
	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "DESC"
	}
	if _, present := asMap["sort"]; !present {
		asMap["sort"] = "DATE"
	}

	fieldsInOrder := [...]string{"text", "title", "url", "date", "production_date", "studios", "parentStudio", "tags", "performers", "alias", "fingerprints", "favorites", "has_fingerprint_submissions", "page", "per_page", "direction", "sort"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalODateCriterionInput2githubcomstashappstashboxpkgmodelsDateCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "production_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("production_date"))
			data, err := ec.unmarshalODateCriterionInput2githubcomstashappstashboxpkgmodelsDateCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProductionDate = data
		case "studios":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studios"))
			data, err := ec.unmarshalOMultiIDCriterionInput2githubcomstashappstashboxpkgmodelsMultiIDCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Studios = data
		case "parentStudio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentStudio"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentStudio = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOMultiIDCriterionInput2githubcomstashappstashboxpkgmodelsMultiIDCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "performers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performers"))
			data, err := ec.unmarshalOMultiIDCriterionInput2githubcomstashappstashboxpkgmodelsMultiIDCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Performers = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalOStringCriterionInput2githubcomstashappstashboxpkgmodelsStringCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "fingerprints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
			data, err := ec.unmarshalOMultiStringCriterionInput2githubcomstashappstashboxpkgmodelsMultiStringCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprints = data
		case "favorites":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("favorites"))
			data, err := ec.unmarshalOFavoriteFilter2githubcomstashappstashboxpkgmodelsFavoriteFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Favorites = data
		case "has_fingerprint_submissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has_fingerprint_submissions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasFingerprintSubmissions = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNSceneSortEnum2githubcomstashappstashboxpkgmodelsSceneSortEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSceneUpdateInput(ctx context.Context, obj interface{}) (SceneUpdateInput, error) {
	var it SceneUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "title", "details", "urls", "date", "production_date", "studio_id", "performers", "tag_ids", "image_ids", "fingerprints", "duration", "director", "code"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "production_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("production_date"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProductionDate = data
		case "studio_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("studio_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.StudioID = data
		case "performers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("performers"))
			data, err := ec.unmarshalOPerformerAppearanceInput2githubcomstashappstashboxpkgmodelsPerformerAppearanceInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Performers = data
		case "tag_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIds = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		case "fingerprints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fingerprints"))
			data, err := ec.unmarshalOFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fingerprints = data
		case "duration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("duration"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Duration = data
		case "director":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("director"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Director = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSiteCreateInput(ctx context.Context, obj interface{}) (SiteCreateInput, error) {
	var it SiteCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "url", "regex", "valid_types"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "regex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Regex = data
		case "valid_types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valid_types"))
			data, err := ec.unmarshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSiteDestroyInput(ctx context.Context, obj interface{}) (SiteDestroyInput, error) {
	var it SiteDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSiteUpdateInput(ctx context.Context, obj interface{}) (SiteUpdateInput, error) {
	var it SiteUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "url", "regex", "valid_types"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "regex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Regex = data
		case "valid_types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valid_types"))
			data, err := ec.unmarshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringCriterionInput(ctx context.Context, obj interface{}) (StringCriterionInput, error) {
	var it StringCriterionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value", "modifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudioCreateInput(ctx context.Context, obj interface{}) (StudioCreateInput, error) {
	var it StudioCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "aliases", "urls", "parent_id", "image_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "parent_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudioDestroyInput(ctx context.Context, obj interface{}) (StudioDestroyInput, error) {
	var it StudioDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudioEditDetailsInput(ctx context.Context, obj interface{}) (StudioEditDetailsInput, error) {
	var it StudioEditDetailsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "aliases", "urls", "parent_id", "image_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "parent_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudioEditInput(ctx context.Context, obj interface{}) (StudioEditInput, error) {
	var it StudioEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"edit", "details"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "edit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("edit"))
			data, err := ec.unmarshalNEditInput2githubcomstashappstashboxpkgmodelsEditInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Edit = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOStudioEditDetailsInput2githubcomstashappstashboxpkgmodelsStudioEditDetailsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudioQueryInput(ctx context.Context, obj interface{}) (StudioQueryInput, error) {
	var it StudioQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}
	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}
	if _, present := asMap["sort"]; !present {
		asMap["sort"] = "NAME"
	}

	fieldsInOrder := [...]string{"name", "names", "url", "parent", "has_parent", "is_favorite", "page", "per_page", "direction", "sort"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "names":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("names"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Names = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "parent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			data, err := ec.unmarshalOIDCriterionInput2githubcomstashappstashboxpkgmodelsIDCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parent = data
		case "has_parent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("has_parent"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasParent = data
		case "is_favorite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("is_favorite"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsFavorite = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNStudioSortEnum2githubcomstashappstashboxpkgmodelsStudioSortEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStudioUpdateInput(ctx context.Context, obj interface{}) (StudioUpdateInput, error) {
	var it StudioUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "aliases", "urls", "parent_id", "image_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "urls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urls"))
			data, err := ec.unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Urls = data
		case "parent_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentID = data
		case "image_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image_ids"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagCategoryCreateInput(ctx context.Context, obj interface{}) (TagCategoryCreateInput, error) {
	var it TagCategoryCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "group", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "group":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
			data, err := ec.unmarshalNTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Group = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagCategoryDestroyInput(ctx context.Context, obj interface{}) (TagCategoryDestroyInput, error) {
	var it TagCategoryDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagCategoryUpdateInput(ctx context.Context, obj interface{}) (TagCategoryUpdateInput, error) {
	var it TagCategoryUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "group", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "group":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("group"))
			data, err := ec.unmarshalOTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Group = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagCreateInput(ctx context.Context, obj interface{}) (TagCreateInput, error) {
	var it TagCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "aliases", "category_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "category_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagDestroyInput(ctx context.Context, obj interface{}) (TagDestroyInput, error) {
	var it TagDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagEditDetailsInput(ctx context.Context, obj interface{}) (TagEditDetailsInput, error) {
	var it TagEditDetailsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "aliases", "category_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "category_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagEditInput(ctx context.Context, obj interface{}) (TagEditInput, error) {
	var it TagEditInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"edit", "details"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "edit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("edit"))
			data, err := ec.unmarshalNEditInput2githubcomstashappstashboxpkgmodelsEditInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Edit = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOTagEditDetailsInput2githubcomstashappstashboxpkgmodelsTagEditDetailsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagQueryInput(ctx context.Context, obj interface{}) (TagQueryInput, error) {
	var it TagQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}
	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}
	if _, present := asMap["sort"]; !present {
		asMap["sort"] = "NAME"
	}

	fieldsInOrder := [...]string{"text", "names", "name", "category_id", "page", "per_page", "direction", "sort"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "names":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("names"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Names = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "category_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryID = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNTagSortEnum2githubcomstashappstashboxpkgmodelsTagSortEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagUpdateInput(ctx context.Context, obj interface{}) (TagUpdateInput, error) {
	var it TagUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "aliases", "category_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "category_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CategoryID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputURLInput(ctx context.Context, obj interface{}) (URLInput, error) {
	var it URLInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "site_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "site_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("site_id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SiteID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserChangeEmailInput(ctx context.Context, obj interface{}) (UserChangeEmailInput, error) {
	var it UserChangeEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"existing_email_token", "new_email_token", "new_email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "existing_email_token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("existing_email_token"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExistingEmailToken = data
		case "new_email_token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("new_email_token"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewEmailToken = data
		case "new_email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("new_email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewEmail = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserChangePasswordInput(ctx context.Context, obj interface{}) (UserChangePasswordInput, error) {
	var it UserChangePasswordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"existing_password", "new_password", "reset_key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "existing_password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("existing_password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExistingPassword = data
		case "new_password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("new_password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewPassword = data
		case "reset_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reset_key"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResetKey = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserCreateInput(ctx context.Context, obj interface{}) (UserCreateInput, error) {
	var it UserCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "password", "roles", "email", "invited_by_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "roles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
			data, err := ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roles = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "invited_by_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invited_by_id"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvitedByID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserDestroyInput(ctx context.Context, obj interface{}) (UserDestroyInput, error) {
	var it UserDestroyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserQueryInput(ctx context.Context, obj interface{}) (UserQueryInput, error) {
	var it UserQueryInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["page"]; !present {
		asMap["page"] = 1
	}
	if _, present := asMap["per_page"]; !present {
		asMap["per_page"] = 25
	}

	fieldsInOrder := [...]string{"name", "email", "roles", "apiKey", "successful_edits", "unsuccessful_edits", "successful_votes", "unsuccessful_votes", "api_calls", "invited_by", "page", "per_page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "roles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
			data, err := ec.unmarshalORoleCriterionInput2githubcomstashappstashboxpkgmodelsRoleCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roles = data
		case "apiKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiKey"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIKey = data
		case "successful_edits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("successful_edits"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuccessfulEdits = data
		case "unsuccessful_edits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unsuccessful_edits"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnsuccessfulEdits = data
		case "successful_votes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("successful_votes"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuccessfulVotes = data
		case "unsuccessful_votes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unsuccessful_votes"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnsuccessfulVotes = data
		case "api_calls":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("api_calls"))
			data, err := ec.unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.APICalls = data
		case "invited_by":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("invited_by"))
			data, err := ec.unmarshalOID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.InvitedBy = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "per_page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("per_page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerPage = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdateInput(ctx context.Context, obj interface{}) (UserUpdateInput, error) {
	var it UserUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "password", "roles", "email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "roles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
			data, err := ec.unmarshalORoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, v)
			if err != nil {
				return it, err
			}
			it.Roles = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _DraftData(ctx context.Context, sel ast.SelectionSet, obj DraftData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case SceneDraft:
		return ec._SceneDraft(ctx, sel, &obj)
	case *SceneDraft:
		if obj == nil {
			return graphql.Null
		}
		return ec._SceneDraft(ctx, sel, obj)
	case PerformerDraft:
		return ec._PerformerDraft(ctx, sel, &obj)
	case *PerformerDraft:
		if obj == nil {
			return graphql.Null
		}
		return ec._PerformerDraft(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _EditDetails(ctx context.Context, sel ast.SelectionSet, obj EditDetails) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case PerformerEdit:
		return ec._PerformerEdit(ctx, sel, &obj)
	case *PerformerEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._PerformerEdit(ctx, sel, obj)
	case SceneEdit:
		return ec._SceneEdit(ctx, sel, &obj)
	case *SceneEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._SceneEdit(ctx, sel, obj)
	case StudioEdit:
		return ec._StudioEdit(ctx, sel, &obj)
	case *StudioEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._StudioEdit(ctx, sel, obj)
	case TagEdit:
		return ec._TagEdit(ctx, sel, &obj)
	case *TagEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._TagEdit(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _EditTarget(ctx context.Context, sel ast.SelectionSet, obj EditTarget) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *Performer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Performer(ctx, sel, obj)
	case *Scene:
		if obj == nil {
			return graphql.Null
		}
		return ec._Scene(ctx, sel, obj)
	case *Studio:
		if obj == nil {
			return graphql.Null
		}
		return ec._Studio(ctx, sel, obj)
	case *Tag:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _NotificationData(ctx context.Context, sel ast.SelectionSet, obj NotificationData) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case FavoritePerformerScene:
		return ec._FavoritePerformerScene(ctx, sel, &obj)
	case *FavoritePerformerScene:
		if obj == nil {
			return graphql.Null
		}
		return ec._FavoritePerformerScene(ctx, sel, obj)
	case FavoritePerformerEdit:
		return ec._FavoritePerformerEdit(ctx, sel, &obj)
	case *FavoritePerformerEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._FavoritePerformerEdit(ctx, sel, obj)
	case FavoriteStudioScene:
		return ec._FavoriteStudioScene(ctx, sel, &obj)
	case *FavoriteStudioScene:
		if obj == nil {
			return graphql.Null
		}
		return ec._FavoriteStudioScene(ctx, sel, obj)
	case FavoriteStudioEdit:
		return ec._FavoriteStudioEdit(ctx, sel, &obj)
	case *FavoriteStudioEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._FavoriteStudioEdit(ctx, sel, obj)
	case CommentOwnEdit:
		return ec._CommentOwnEdit(ctx, sel, &obj)
	case *CommentOwnEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._CommentOwnEdit(ctx, sel, obj)
	case CommentCommentedEdit:
		return ec._CommentCommentedEdit(ctx, sel, &obj)
	case *CommentCommentedEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._CommentCommentedEdit(ctx, sel, obj)
	case CommentVotedEdit:
		return ec._CommentVotedEdit(ctx, sel, &obj)
	case *CommentVotedEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._CommentVotedEdit(ctx, sel, obj)
	case DownvoteOwnEdit:
		return ec._DownvoteOwnEdit(ctx, sel, &obj)
	case *DownvoteOwnEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._DownvoteOwnEdit(ctx, sel, obj)
	case FailedOwnEdit:
		return ec._FailedOwnEdit(ctx, sel, &obj)
	case *FailedOwnEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._FailedOwnEdit(ctx, sel, obj)
	case UpdatedEdit:
		return ec._UpdatedEdit(ctx, sel, &obj)
	case *UpdatedEdit:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdatedEdit(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SceneDraftPerformer(ctx context.Context, sel ast.SelectionSet, obj SceneDraftPerformer) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Performer:
		return ec._Performer(ctx, sel, &obj)
	case *Performer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Performer(ctx, sel, obj)
	case DraftEntity:
		return ec._DraftEntity(ctx, sel, &obj)
	case *DraftEntity:
		if obj == nil {
			return graphql.Null
		}
		return ec._DraftEntity(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SceneDraftStudio(ctx context.Context, sel ast.SelectionSet, obj SceneDraftStudio) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Studio:
		return ec._Studio(ctx, sel, &obj)
	case *Studio:
		if obj == nil {
			return graphql.Null
		}
		return ec._Studio(ctx, sel, obj)
	case DraftEntity:
		return ec._DraftEntity(ctx, sel, &obj)
	case *DraftEntity:
		if obj == nil {
			return graphql.Null
		}
		return ec._DraftEntity(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SceneDraftTag(ctx context.Context, sel ast.SelectionSet, obj SceneDraftTag) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case Tag:
		return ec._Tag(ctx, sel, &obj)
	case *Tag:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tag(ctx, sel, obj)
	case DraftEntity:
		return ec._DraftEntity(ctx, sel, &obj)
	case *DraftEntity:
		if obj == nil {
			return graphql.Null
		}
		return ec._DraftEntity(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var bodyModificationImplementors = []string{"BodyModification"}

func (ec *executionContext) _BodyModification(ctx context.Context, sel ast.SelectionSet, obj *BodyModification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bodyModificationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BodyModification")
		case "location":
			out.Values[i] = ec._BodyModification_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._BodyModification_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commentCommentedEditImplementors = []string{"CommentCommentedEdit", "NotificationData"}

func (ec *executionContext) _CommentCommentedEdit(ctx context.Context, sel ast.SelectionSet, obj *CommentCommentedEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commentCommentedEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentCommentedEdit")
		case "comment":
			out.Values[i] = ec._CommentCommentedEdit_comment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commentOwnEditImplementors = []string{"CommentOwnEdit", "NotificationData"}

func (ec *executionContext) _CommentOwnEdit(ctx context.Context, sel ast.SelectionSet, obj *CommentOwnEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commentOwnEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentOwnEdit")
		case "comment":
			out.Values[i] = ec._CommentOwnEdit_comment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commentVotedEditImplementors = []string{"CommentVotedEdit", "NotificationData"}

func (ec *executionContext) _CommentVotedEdit(ctx context.Context, sel ast.SelectionSet, obj *CommentVotedEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commentVotedEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentVotedEdit")
		case "comment":
			out.Values[i] = ec._CommentVotedEdit_comment(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var downvoteOwnEditImplementors = []string{"DownvoteOwnEdit", "NotificationData"}

func (ec *executionContext) _DownvoteOwnEdit(ctx context.Context, sel ast.SelectionSet, obj *DownvoteOwnEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, downvoteOwnEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DownvoteOwnEdit")
		case "edit":
			out.Values[i] = ec._DownvoteOwnEdit_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var draftImplementors = []string{"Draft"}

func (ec *executionContext) _Draft(ctx context.Context, sel ast.SelectionSet, obj *Draft) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, draftImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Draft")
		case "id":
			out.Values[i] = ec._Draft_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Draft_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expires":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Draft_expires(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Draft_data(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var draftEntityImplementors = []string{"DraftEntity", "SceneDraftStudio", "SceneDraftPerformer", "SceneDraftTag"}

func (ec *executionContext) _DraftEntity(ctx context.Context, sel ast.SelectionSet, obj *DraftEntity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, draftEntityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DraftEntity")
		case "name":
			out.Values[i] = ec._DraftEntity_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._DraftEntity_id(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var draftFingerprintImplementors = []string{"DraftFingerprint"}

func (ec *executionContext) _DraftFingerprint(ctx context.Context, sel ast.SelectionSet, obj *DraftFingerprint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, draftFingerprintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DraftFingerprint")
		case "hash":
			out.Values[i] = ec._DraftFingerprint_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "algorithm":
			out.Values[i] = ec._DraftFingerprint_algorithm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._DraftFingerprint_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var draftSubmissionStatusImplementors = []string{"DraftSubmissionStatus"}

func (ec *executionContext) _DraftSubmissionStatus(ctx context.Context, sel ast.SelectionSet, obj *DraftSubmissionStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, draftSubmissionStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DraftSubmissionStatus")
		case "id":
			out.Values[i] = ec._DraftSubmissionStatus_id(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var editImplementors = []string{"Edit"}

func (ec *executionContext) _Edit(ctx context.Context, sel ast.SelectionSet, obj *Edit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, editImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Edit")
		case "id":
			out.Values[i] = ec._Edit_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "target":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_target(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "target_type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_target_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "merge_sources":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_merge_sources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "operation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_operation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bot":
			out.Values[i] = ec._Edit_bot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "details":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_details(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "old_details":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_old_details(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "options":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_options(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "comments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_comments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "votes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_votes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vote_count":
			out.Values[i] = ec._Edit_vote_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "destructive":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_destructive(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "applied":
			out.Values[i] = ec._Edit_applied(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "update_count":
			out.Values[i] = ec._Edit_update_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatable":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_updatable(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_updated(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "closed":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_closed(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expires":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Edit_expires(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var editCommentImplementors = []string{"EditComment"}

func (ec *executionContext) _EditComment(ctx context.Context, sel ast.SelectionSet, obj *EditComment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, editCommentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EditComment")
		case "id":
			out.Values[i] = ec._EditComment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditComment_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "date":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditComment_date(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "comment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditComment_comment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "edit":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditComment_edit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var editVoteImplementors = []string{"EditVote"}

func (ec *executionContext) _EditVote(ctx context.Context, sel ast.SelectionSet, obj *EditVote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, editVoteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EditVote")
		case "user":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditVote_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "date":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditVote_date(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vote":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EditVote_vote(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var failedOwnEditImplementors = []string{"FailedOwnEdit", "NotificationData"}

func (ec *executionContext) _FailedOwnEdit(ctx context.Context, sel ast.SelectionSet, obj *FailedOwnEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, failedOwnEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FailedOwnEdit")
		case "edit":
			out.Values[i] = ec._FailedOwnEdit_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var favoritePerformerEditImplementors = []string{"FavoritePerformerEdit", "NotificationData"}

func (ec *executionContext) _FavoritePerformerEdit(ctx context.Context, sel ast.SelectionSet, obj *FavoritePerformerEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, favoritePerformerEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FavoritePerformerEdit")
		case "edit":
			out.Values[i] = ec._FavoritePerformerEdit_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var favoritePerformerSceneImplementors = []string{"FavoritePerformerScene", "NotificationData"}

func (ec *executionContext) _FavoritePerformerScene(ctx context.Context, sel ast.SelectionSet, obj *FavoritePerformerScene) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, favoritePerformerSceneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FavoritePerformerScene")
		case "scene":
			out.Values[i] = ec._FavoritePerformerScene_scene(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var favoriteStudioEditImplementors = []string{"FavoriteStudioEdit", "NotificationData"}

func (ec *executionContext) _FavoriteStudioEdit(ctx context.Context, sel ast.SelectionSet, obj *FavoriteStudioEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, favoriteStudioEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FavoriteStudioEdit")
		case "edit":
			out.Values[i] = ec._FavoriteStudioEdit_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var favoriteStudioSceneImplementors = []string{"FavoriteStudioScene", "NotificationData"}

func (ec *executionContext) _FavoriteStudioScene(ctx context.Context, sel ast.SelectionSet, obj *FavoriteStudioScene) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, favoriteStudioSceneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FavoriteStudioScene")
		case "scene":
			out.Values[i] = ec._FavoriteStudioScene_scene(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fingerprintImplementors = []string{"Fingerprint"}

func (ec *executionContext) _Fingerprint(ctx context.Context, sel ast.SelectionSet, obj *Fingerprint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fingerprintImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Fingerprint")
		case "hash":
			out.Values[i] = ec._Fingerprint_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "algorithm":
			out.Values[i] = ec._Fingerprint_algorithm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._Fingerprint_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "submissions":
			out.Values[i] = ec._Fingerprint_submissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reports":
			out.Values[i] = ec._Fingerprint_reports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "created":
			out.Values[i] = ec._Fingerprint_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updated":
			out.Values[i] = ec._Fingerprint_updated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user_submitted":
			out.Values[i] = ec._Fingerprint_user_submitted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user_reported":
			out.Values[i] = ec._Fingerprint_user_reported(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fuzzyDateImplementors = []string{"FuzzyDate"}

func (ec *executionContext) _FuzzyDate(ctx context.Context, sel ast.SelectionSet, obj *FuzzyDate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fuzzyDateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FuzzyDate")
		case "date":
			out.Values[i] = ec._FuzzyDate_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "accuracy":
			out.Values[i] = ec._FuzzyDate_accuracy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageImplementors = []string{"Image"}

func (ec *executionContext) _Image(ctx context.Context, sel ast.SelectionSet, obj *Image) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Image")
		case "id":
			out.Values[i] = ec._Image_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "url":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_url(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "width":
			out.Values[i] = ec._Image_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "height":
			out.Values[i] = ec._Image_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var inviteKeyImplementors = []string{"InviteKey"}

func (ec *executionContext) _InviteKey(ctx context.Context, sel ast.SelectionSet, obj *InviteKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, inviteKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InviteKey")
		case "id":
			out.Values[i] = ec._InviteKey_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uses":
			out.Values[i] = ec._InviteKey_uses(ctx, field, obj)
		case "expires":
			out.Values[i] = ec._InviteKey_expires(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var measurementsImplementors = []string{"Measurements"}

func (ec *executionContext) _Measurements(ctx context.Context, sel ast.SelectionSet, obj *Measurements) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, measurementsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Measurements")
		case "cup_size":
			out.Values[i] = ec._Measurements_cup_size(ctx, field, obj)
		case "band_size":
			out.Values[i] = ec._Measurements_band_size(ctx, field, obj)
		case "waist":
			out.Values[i] = ec._Measurements_waist(ctx, field, obj)
		case "hip":
			out.Values[i] = ec._Measurements_hip(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "sceneCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sceneCreate(ctx, field)
			})
		case "sceneUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sceneUpdate(ctx, field)
			})
		case "sceneDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sceneDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "performerCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_performerCreate(ctx, field)
			})
		case "performerUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_performerUpdate(ctx, field)
			})
		case "performerDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_performerDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studioCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_studioCreate(ctx, field)
			})
		case "studioUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_studioUpdate(ctx, field)
			})
		case "studioDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_studioDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tagCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagCreate(ctx, field)
			})
		case "tagUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagUpdate(ctx, field)
			})
		case "tagDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userCreate(ctx, field)
			})
		case "userUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userUpdate(ctx, field)
			})
		case "userDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_imageCreate(ctx, field)
			})
		case "imageDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_imageDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_newUser(ctx, field)
			})
		case "activateNewUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_activateNewUser(ctx, field)
			})
		case "generateInviteCode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_generateInviteCode(ctx, field)
			})
		case "generateInviteCodes":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_generateInviteCodes(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rescindInviteCode":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rescindInviteCode(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "grantInvite":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_grantInvite(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revokeInvite":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeInvite(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tagCategoryCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagCategoryCreate(ctx, field)
			})
		case "tagCategoryUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagCategoryUpdate(ctx, field)
			})
		case "tagCategoryDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagCategoryDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "siteCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_siteCreate(ctx, field)
			})
		case "siteUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_siteUpdate(ctx, field)
			})
		case "siteDestroy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_siteDestroy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regenerateAPIKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_regenerateAPIKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetPassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetPassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "changePassword":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_changePassword(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requestChangeEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_requestChangeEmail(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validateChangeEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_validateChangeEmail(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "confirmChangeEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_confirmChangeEmail(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sceneEdit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sceneEdit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "performerEdit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_performerEdit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studioEdit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_studioEdit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tagEdit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagEdit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sceneEditUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sceneEditUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "performerEditUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_performerEditUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studioEditUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_studioEditUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tagEditUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_tagEditUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editVote":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editVote(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editComment":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editComment(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "applyEdit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_applyEdit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cancelEdit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelEdit(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "submitFingerprint":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_submitFingerprint(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "submitSceneDraft":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_submitSceneDraft(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "submitPerformerDraft":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_submitPerformerDraft(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "destroyDraft":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_destroyDraft(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "favoritePerformer":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_favoritePerformer(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "favoriteStudio":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_favoriteStudio(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "markNotificationsRead":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_markNotificationsRead(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateNotificationSubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNotificationSubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationImplementors = []string{"Notification"}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj *Notification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notification")
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "read":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_read(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Notification_data(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var performerImplementors = []string{"Performer", "EditTarget", "SceneDraftPerformer"}

func (ec *executionContext) _Performer(ctx context.Context, sel ast.SelectionSet, obj *Performer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, performerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Performer")
		case "id":
			out.Values[i] = ec._Performer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Performer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disambiguation":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_disambiguation(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_aliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_gender(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "birthdate":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_birthdate(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "birth_date":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_birth_date(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "death_date":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_death_date(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "age":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_age(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ethnicity":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_ethnicity(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "country":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_country(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eye_color":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_eye_color(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hair_color":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_hair_color(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "height":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_height(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "measurements":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_measurements(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cup_size":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_cup_size(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "band_size":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_band_size(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "waist_size":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_waist_size(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hip_size":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_hip_size(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "breast_type":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_breast_type(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "career_start_year":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_career_start_year(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "career_end_year":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_career_end_year(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tattoos":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_tattoos(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "piercings":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_piercings(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleted":
			out.Values[i] = ec._Performer_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "edits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_edits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "scene_count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_scene_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "scenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_scenes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "merged_ids":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_merged_ids(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "merged_into_id":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_merged_into_id(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "studios":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_studios(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "is_favorite":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_is_favorite(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Performer_updated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var performerAppearanceImplementors = []string{"PerformerAppearance"}

func (ec *executionContext) _PerformerAppearance(ctx context.Context, sel ast.SelectionSet, obj *PerformerAppearance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, performerAppearanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PerformerAppearance")
		case "performer":
			out.Values[i] = ec._PerformerAppearance_performer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "as":
			out.Values[i] = ec._PerformerAppearance_as(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var performerDraftImplementors = []string{"PerformerDraft", "DraftData"}

func (ec *executionContext) _PerformerDraft(ctx context.Context, sel ast.SelectionSet, obj *PerformerDraft) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, performerDraftImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PerformerDraft")
		case "id":
			out.Values[i] = ec._PerformerDraft_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._PerformerDraft_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disambiguation":
			out.Values[i] = ec._PerformerDraft_disambiguation(ctx, field, obj)
		case "aliases":
			out.Values[i] = ec._PerformerDraft_aliases(ctx, field, obj)
		case "gender":
			out.Values[i] = ec._PerformerDraft_gender(ctx, field, obj)
		case "birthdate":
			out.Values[i] = ec._PerformerDraft_birthdate(ctx, field, obj)
		case "deathdate":
			out.Values[i] = ec._PerformerDraft_deathdate(ctx, field, obj)
		case "urls":
			out.Values[i] = ec._PerformerDraft_urls(ctx, field, obj)
		case "ethnicity":
			out.Values[i] = ec._PerformerDraft_ethnicity(ctx, field, obj)
		case "country":
			out.Values[i] = ec._PerformerDraft_country(ctx, field, obj)
		case "eye_color":
			out.Values[i] = ec._PerformerDraft_eye_color(ctx, field, obj)
		case "hair_color":
			out.Values[i] = ec._PerformerDraft_hair_color(ctx, field, obj)
		case "height":
			out.Values[i] = ec._PerformerDraft_height(ctx, field, obj)
		case "measurements":
			out.Values[i] = ec._PerformerDraft_measurements(ctx, field, obj)
		case "breast_type":
			out.Values[i] = ec._PerformerDraft_breast_type(ctx, field, obj)
		case "tattoos":
			out.Values[i] = ec._PerformerDraft_tattoos(ctx, field, obj)
		case "piercings":
			out.Values[i] = ec._PerformerDraft_piercings(ctx, field, obj)
		case "career_start_year":
			out.Values[i] = ec._PerformerDraft_career_start_year(ctx, field, obj)
		case "career_end_year":
			out.Values[i] = ec._PerformerDraft_career_end_year(ctx, field, obj)
		case "image":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerDraft_image(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var performerEditImplementors = []string{"PerformerEdit", "EditDetails"}

func (ec *executionContext) _PerformerEdit(ctx context.Context, sel ast.SelectionSet, obj *PerformerEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, performerEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PerformerEdit")
		case "name":
			out.Values[i] = ec._PerformerEdit_name(ctx, field, obj)
		case "disambiguation":
			out.Values[i] = ec._PerformerEdit_disambiguation(ctx, field, obj)
		case "added_aliases":
			out.Values[i] = ec._PerformerEdit_added_aliases(ctx, field, obj)
		case "removed_aliases":
			out.Values[i] = ec._PerformerEdit_removed_aliases(ctx, field, obj)
		case "gender":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_gender(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_urls":
			out.Values[i] = ec._PerformerEdit_added_urls(ctx, field, obj)
		case "removed_urls":
			out.Values[i] = ec._PerformerEdit_removed_urls(ctx, field, obj)
		case "birthdate":
			out.Values[i] = ec._PerformerEdit_birthdate(ctx, field, obj)
		case "deathdate":
			out.Values[i] = ec._PerformerEdit_deathdate(ctx, field, obj)
		case "ethnicity":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_ethnicity(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "country":
			out.Values[i] = ec._PerformerEdit_country(ctx, field, obj)
		case "eye_color":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_eye_color(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hair_color":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_hair_color(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "height":
			out.Values[i] = ec._PerformerEdit_height(ctx, field, obj)
		case "cup_size":
			out.Values[i] = ec._PerformerEdit_cup_size(ctx, field, obj)
		case "band_size":
			out.Values[i] = ec._PerformerEdit_band_size(ctx, field, obj)
		case "waist_size":
			out.Values[i] = ec._PerformerEdit_waist_size(ctx, field, obj)
		case "hip_size":
			out.Values[i] = ec._PerformerEdit_hip_size(ctx, field, obj)
		case "breast_type":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_breast_type(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "career_start_year":
			out.Values[i] = ec._PerformerEdit_career_start_year(ctx, field, obj)
		case "career_end_year":
			out.Values[i] = ec._PerformerEdit_career_end_year(ctx, field, obj)
		case "added_tattoos":
			out.Values[i] = ec._PerformerEdit_added_tattoos(ctx, field, obj)
		case "removed_tattoos":
			out.Values[i] = ec._PerformerEdit_removed_tattoos(ctx, field, obj)
		case "added_piercings":
			out.Values[i] = ec._PerformerEdit_added_piercings(ctx, field, obj)
		case "removed_piercings":
			out.Values[i] = ec._PerformerEdit_removed_piercings(ctx, field, obj)
		case "added_images":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_added_images(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_images":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_removed_images(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "draft_id":
			out.Values[i] = ec._PerformerEdit_draft_id(ctx, field, obj)
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_aliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tattoos":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_tattoos(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "piercings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PerformerEdit_piercings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var performerEditOptionsImplementors = []string{"PerformerEditOptions"}

func (ec *executionContext) _PerformerEditOptions(ctx context.Context, sel ast.SelectionSet, obj *PerformerEditOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, performerEditOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PerformerEditOptions")
		case "set_modify_aliases":
			out.Values[i] = ec._PerformerEditOptions_set_modify_aliases(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "set_merge_aliases":
			out.Values[i] = ec._PerformerEditOptions_set_merge_aliases(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var performerStudioImplementors = []string{"PerformerStudio"}

func (ec *executionContext) _PerformerStudio(ctx context.Context, sel ast.SelectionSet, obj *PerformerStudio) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, performerStudioImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PerformerStudio")
		case "studio":
			out.Values[i] = ec._PerformerStudio_studio(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scene_count":
			out.Values[i] = ec._PerformerStudio_scene_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "findPerformer":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findPerformer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryPerformers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryPerformers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findStudio":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findStudio(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryStudios":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryStudios(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findTag":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findTagOrAlias":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTagOrAlias(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findTagCategory":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTagCategory(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryTagCategories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryTagCategories(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findScene":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findScene(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findSceneByFingerprint":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findSceneByFingerprint(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findScenesByFingerprints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findScenesByFingerprints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findScenesByFullFingerprints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findScenesByFullFingerprints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findScenesBySceneFingerprints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findScenesBySceneFingerprints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryScenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryScenes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findSite":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findSite(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "querySites":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_querySites(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findEdit":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findEdit(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryEdits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryEdits(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findUser":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchPerformer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchPerformer(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchScene":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchScene(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchTag":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchTag(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchStudio":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchStudio(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findDraft":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findDraft(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findDrafts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findDrafts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryExistingScene":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryExistingScene(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryExistingPerformer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryExistingPerformer(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getConfig(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "queryNotifications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_queryNotifications(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getUnreadNotificationCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUnreadNotificationCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryEditsResultTypeImplementors = []string{"QueryEditsResultType"}

func (ec *executionContext) _QueryEditsResultType(ctx context.Context, sel ast.SelectionSet, obj *EditQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryEditsResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryEditsResultType")
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryEditsResultType_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "edits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryEditsResultType_edits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryExistingPerformerResultImplementors = []string{"QueryExistingPerformerResult"}

func (ec *executionContext) _QueryExistingPerformerResult(ctx context.Context, sel ast.SelectionSet, obj *QueryExistingPerformerResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryExistingPerformerResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryExistingPerformerResult")
		case "edits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryExistingPerformerResult_edits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "performers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryExistingPerformerResult_performers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryExistingSceneResultImplementors = []string{"QueryExistingSceneResult"}

func (ec *executionContext) _QueryExistingSceneResult(ctx context.Context, sel ast.SelectionSet, obj *QueryExistingSceneResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryExistingSceneResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryExistingSceneResult")
		case "edits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryExistingSceneResult_edits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "scenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryExistingSceneResult_scenes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryNotificationsResultImplementors = []string{"QueryNotificationsResult"}

func (ec *executionContext) _QueryNotificationsResult(ctx context.Context, sel ast.SelectionSet, obj *QueryNotificationsResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryNotificationsResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryNotificationsResult")
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryNotificationsResult_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryNotificationsResult_notifications(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryPerformersResultTypeImplementors = []string{"QueryPerformersResultType"}

func (ec *executionContext) _QueryPerformersResultType(ctx context.Context, sel ast.SelectionSet, obj *PerformerQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryPerformersResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryPerformersResultType")
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryPerformersResultType_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "performers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryPerformersResultType_performers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryScenesResultTypeImplementors = []string{"QueryScenesResultType"}

func (ec *executionContext) _QueryScenesResultType(ctx context.Context, sel ast.SelectionSet, obj *SceneQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryScenesResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryScenesResultType")
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryScenesResultType_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "scenes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._QueryScenesResultType_scenes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var querySitesResultTypeImplementors = []string{"QuerySitesResultType"}

func (ec *executionContext) _QuerySitesResultType(ctx context.Context, sel ast.SelectionSet, obj *QuerySitesResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, querySitesResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QuerySitesResultType")
		case "count":
			out.Values[i] = ec._QuerySitesResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sites":
			out.Values[i] = ec._QuerySitesResultType_sites(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryStudiosResultTypeImplementors = []string{"QueryStudiosResultType"}

func (ec *executionContext) _QueryStudiosResultType(ctx context.Context, sel ast.SelectionSet, obj *QueryStudiosResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryStudiosResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryStudiosResultType")
		case "count":
			out.Values[i] = ec._QueryStudiosResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studios":
			out.Values[i] = ec._QueryStudiosResultType_studios(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryTagCategoriesResultTypeImplementors = []string{"QueryTagCategoriesResultType"}

func (ec *executionContext) _QueryTagCategoriesResultType(ctx context.Context, sel ast.SelectionSet, obj *QueryTagCategoriesResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryTagCategoriesResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryTagCategoriesResultType")
		case "count":
			out.Values[i] = ec._QueryTagCategoriesResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tag_categories":
			out.Values[i] = ec._QueryTagCategoriesResultType_tag_categories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryTagsResultTypeImplementors = []string{"QueryTagsResultType"}

func (ec *executionContext) _QueryTagsResultType(ctx context.Context, sel ast.SelectionSet, obj *QueryTagsResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryTagsResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryTagsResultType")
		case "count":
			out.Values[i] = ec._QueryTagsResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tags":
			out.Values[i] = ec._QueryTagsResultType_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryUsersResultTypeImplementors = []string{"QueryUsersResultType"}

func (ec *executionContext) _QueryUsersResultType(ctx context.Context, sel ast.SelectionSet, obj *QueryUsersResultType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryUsersResultTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QueryUsersResultType")
		case "count":
			out.Values[i] = ec._QueryUsersResultType_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "users":
			out.Values[i] = ec._QueryUsersResultType_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneImplementors = []string{"Scene", "EditTarget"}

func (ec *executionContext) _Scene(ctx context.Context, sel ast.SelectionSet, obj *Scene) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Scene")
		case "id":
			out.Values[i] = ec._Scene_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "title":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_title(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "details":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_details(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "date":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_date(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "release_date":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_release_date(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "production_date":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_production_date(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "studio":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_studio(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "performers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_performers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fingerprints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_fingerprints(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "duration":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_duration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "director":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_director(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "code":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_code(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleted":
			out.Values[i] = ec._Scene_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "edits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_edits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Scene_updated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneDraftImplementors = []string{"SceneDraft", "DraftData"}

func (ec *executionContext) _SceneDraft(ctx context.Context, sel ast.SelectionSet, obj *SceneDraft) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneDraftImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneDraft")
		case "id":
			out.Values[i] = ec._SceneDraft_id(ctx, field, obj)
		case "title":
			out.Values[i] = ec._SceneDraft_title(ctx, field, obj)
		case "code":
			out.Values[i] = ec._SceneDraft_code(ctx, field, obj)
		case "details":
			out.Values[i] = ec._SceneDraft_details(ctx, field, obj)
		case "director":
			out.Values[i] = ec._SceneDraft_director(ctx, field, obj)
		case "urls":
			out.Values[i] = ec._SceneDraft_urls(ctx, field, obj)
		case "date":
			out.Values[i] = ec._SceneDraft_date(ctx, field, obj)
		case "production_date":
			out.Values[i] = ec._SceneDraft_production_date(ctx, field, obj)
		case "studio":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneDraft_studio(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "performers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneDraft_performers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneDraft_tags(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "image":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneDraft_image(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fingerprints":
			out.Values[i] = ec._SceneDraft_fingerprints(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sceneEditImplementors = []string{"SceneEdit", "EditDetails"}

func (ec *executionContext) _SceneEdit(ctx context.Context, sel ast.SelectionSet, obj *SceneEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sceneEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SceneEdit")
		case "title":
			out.Values[i] = ec._SceneEdit_title(ctx, field, obj)
		case "details":
			out.Values[i] = ec._SceneEdit_details(ctx, field, obj)
		case "added_urls":
			out.Values[i] = ec._SceneEdit_added_urls(ctx, field, obj)
		case "removed_urls":
			out.Values[i] = ec._SceneEdit_removed_urls(ctx, field, obj)
		case "date":
			out.Values[i] = ec._SceneEdit_date(ctx, field, obj)
		case "production_date":
			out.Values[i] = ec._SceneEdit_production_date(ctx, field, obj)
		case "studio":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_studio(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_performers":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_added_performers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_performers":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_removed_performers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_tags":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_added_tags(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_tags":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_removed_tags(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_images":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_added_images(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_images":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_removed_images(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_fingerprints":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_added_fingerprints(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_fingerprints":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_removed_fingerprints(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "duration":
			out.Values[i] = ec._SceneEdit_duration(ctx, field, obj)
		case "director":
			out.Values[i] = ec._SceneEdit_director(ctx, field, obj)
		case "code":
			out.Values[i] = ec._SceneEdit_code(ctx, field, obj)
		case "draft_id":
			out.Values[i] = ec._SceneEdit_draft_id(ctx, field, obj)
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "performers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_performers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fingerprints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SceneEdit_fingerprints(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var siteImplementors = []string{"Site"}

func (ec *executionContext) _Site(ctx context.Context, sel ast.SelectionSet, obj *Site) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, siteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Site")
		case "id":
			out.Values[i] = ec._Site_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Site_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_description(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "url":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_url(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "regex":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_regex(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "valid_types":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_valid_types(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "icon":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_icon(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Site_updated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stashBoxConfigImplementors = []string{"StashBoxConfig"}

func (ec *executionContext) _StashBoxConfig(ctx context.Context, sel ast.SelectionSet, obj *StashBoxConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stashBoxConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StashBoxConfig")
		case "host_url":
			out.Values[i] = ec._StashBoxConfig_host_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "require_invite":
			out.Values[i] = ec._StashBoxConfig_require_invite(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "require_activation":
			out.Values[i] = ec._StashBoxConfig_require_activation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vote_promotion_threshold":
			out.Values[i] = ec._StashBoxConfig_vote_promotion_threshold(ctx, field, obj)
		case "vote_application_threshold":
			out.Values[i] = ec._StashBoxConfig_vote_application_threshold(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "voting_period":
			out.Values[i] = ec._StashBoxConfig_voting_period(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "min_destructive_voting_period":
			out.Values[i] = ec._StashBoxConfig_min_destructive_voting_period(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "vote_cron_interval":
			out.Values[i] = ec._StashBoxConfig_vote_cron_interval(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "guidelines_url":
			out.Values[i] = ec._StashBoxConfig_guidelines_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "require_scene_draft":
			out.Values[i] = ec._StashBoxConfig_require_scene_draft(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edit_update_limit":
			out.Values[i] = ec._StashBoxConfig_edit_update_limit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studioImplementors = []string{"Studio", "EditTarget", "SceneDraftStudio"}

func (ec *executionContext) _Studio(ctx context.Context, sel ast.SelectionSet, obj *Studio) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studioImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Studio")
		case "id":
			out.Values[i] = ec._Studio_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Studio_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_aliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "parent":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_parent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "child_studios":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_child_studios(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleted":
			out.Values[i] = ec._Studio_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "is_favorite":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_is_favorite(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_updated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "performers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Studio_performers(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studioEditImplementors = []string{"StudioEdit", "EditDetails"}

func (ec *executionContext) _StudioEdit(ctx context.Context, sel ast.SelectionSet, obj *StudioEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studioEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StudioEdit")
		case "name":
			out.Values[i] = ec._StudioEdit_name(ctx, field, obj)
		case "added_urls":
			out.Values[i] = ec._StudioEdit_added_urls(ctx, field, obj)
		case "removed_urls":
			out.Values[i] = ec._StudioEdit_removed_urls(ctx, field, obj)
		case "parent":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StudioEdit_parent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_images":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StudioEdit_added_images(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_images":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StudioEdit_removed_images(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "added_aliases":
			out.Values[i] = ec._StudioEdit_added_aliases(ctx, field, obj)
		case "removed_aliases":
			out.Values[i] = ec._StudioEdit_removed_aliases(ctx, field, obj)
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StudioEdit_images(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StudioEdit_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagImplementors = []string{"Tag", "EditTarget", "SceneDraftTag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			out.Values[i] = ec._Tag_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_description(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_aliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "deleted":
			out.Values[i] = ec._Tag_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "edits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_edits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "category":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_category(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_created(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "updated":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_updated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagCategoryImplementors = []string{"TagCategory"}

func (ec *executionContext) _TagCategory(ctx context.Context, sel ast.SelectionSet, obj *TagCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagCategoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagCategory")
		case "id":
			out.Values[i] = ec._TagCategory_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._TagCategory_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "group":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagCategory_group(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "description":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagCategory_description(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagEditImplementors = []string{"TagEdit", "EditDetails"}

func (ec *executionContext) _TagEdit(ctx context.Context, sel ast.SelectionSet, obj *TagEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagEdit")
		case "name":
			out.Values[i] = ec._TagEdit_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._TagEdit_description(ctx, field, obj)
		case "added_aliases":
			out.Values[i] = ec._TagEdit_added_aliases(ctx, field, obj)
		case "removed_aliases":
			out.Values[i] = ec._TagEdit_removed_aliases(ctx, field, obj)
		case "category":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagEdit_category(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TagEdit_aliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uRLImplementors = []string{"URL"}

func (ec *executionContext) _URL(ctx context.Context, sel ast.SelectionSet, obj *URL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uRLImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("URL")
		case "url":
			out.Values[i] = ec._URL_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._URL_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "site":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._URL_site(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updatedEditImplementors = []string{"UpdatedEdit", "NotificationData"}

func (ec *executionContext) _UpdatedEdit(ctx context.Context, sel ast.SelectionSet, obj *UpdatedEdit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updatedEditImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdatedEdit")
		case "edit":
			out.Values[i] = ec._UpdatedEdit_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._User_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "roles":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_roles(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
		case "api_key":
			out.Values[i] = ec._User_api_key(ctx, field, obj)
		case "notification_subscriptions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_notification_subscriptions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vote_count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_vote_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "edit_count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_edit_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "api_calls":
			out.Values[i] = ec._User_api_calls(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "invited_by":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_invited_by(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "invite_tokens":
			out.Values[i] = ec._User_invite_tokens(ctx, field, obj)
		case "active_invite_codes":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_active_invite_codes(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "invite_codes":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_invite_codes(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userEditCountImplementors = []string{"UserEditCount"}

func (ec *executionContext) _UserEditCount(ctx context.Context, sel ast.SelectionSet, obj *UserEditCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEditCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEditCount")
		case "accepted":
			out.Values[i] = ec._UserEditCount_accepted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rejected":
			out.Values[i] = ec._UserEditCount_rejected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pending":
			out.Values[i] = ec._UserEditCount_pending(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "immediate_accepted":
			out.Values[i] = ec._UserEditCount_immediate_accepted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "immediate_rejected":
			out.Values[i] = ec._UserEditCount_immediate_rejected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failed":
			out.Values[i] = ec._UserEditCount_failed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "canceled":
			out.Values[i] = ec._UserEditCount_canceled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userVoteCountImplementors = []string{"UserVoteCount"}

func (ec *executionContext) _UserVoteCount(ctx context.Context, sel ast.SelectionSet, obj *UserVoteCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userVoteCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserVoteCount")
		case "abstain":
			out.Values[i] = ec._UserVoteCount_abstain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "accept":
			out.Values[i] = ec._UserVoteCount_accept(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reject":
			out.Values[i] = ec._UserVoteCount_reject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "immediate_accept":
			out.Values[i] = ec._UserVoteCount_immediate_accept(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "immediate_reject":
			out.Values[i] = ec._UserVoteCount_immediate_reject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "hash":
			out.Values[i] = ec._Version_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "build_time":
			out.Values[i] = ec._Version_build_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "build_type":
			out.Values[i] = ec._Version_build_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Version_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNActivateNewUserInput2githubcomstashappstashboxpkgmodelsActivateNewUserInput(ctx context.Context, v interface{}) (ActivateNewUserInput, error) {
	res, err := ec.unmarshalInputActivateNewUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNApplyEditInput2githubcomstashappstashboxpkgmodelsApplyEditInput(ctx context.Context, v interface{}) (ApplyEditInput, error) {
	res, err := ec.unmarshalInputApplyEditInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx context.Context, sel ast.SelectionSet, v []*BodyModification) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx context.Context, sel ast.SelectionSet, v *BodyModification) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BodyModification(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx context.Context, v interface{}) (*BodyModification, error) {
	res, err := ec.unmarshalInputBodyModificationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCancelEditInput2githubcomstashappstashboxpkgmodelsCancelEditInput(ctx context.Context, v interface{}) (CancelEditInput, error) {
	res, err := ec.unmarshalInputCancelEditInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx context.Context, v interface{}) (CriterionModifier, error) {
	var res CriterionModifier
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCriterionModifier2githubcomstashappstashboxpkgmodelsCriterionModifier(ctx context.Context, sel ast.SelectionSet, v CriterionModifier) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateAccuracyEnum2githubcomstashappstashboxpkgmodelsDateAccuracyEnum(ctx context.Context, v interface{}) (DateAccuracyEnum, error) {
	var res DateAccuracyEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateAccuracyEnum2githubcomstashappstashboxpkgmodelsDateAccuracyEnum(ctx context.Context, sel ast.SelectionSet, v DateAccuracyEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDraft2githubcomstashappstashboxpkgmodelsDraft(ctx context.Context, sel ast.SelectionSet, v []*Draft) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDraft2githubcomstashappstashboxpkgmodelsDraft(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDraft2githubcomstashappstashboxpkgmodelsDraft(ctx context.Context, sel ast.SelectionSet, v *Draft) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Draft(ctx, sel, v)
}

func (ec *executionContext) marshalNDraftData2githubcomstashappstashboxpkgmodelsDraftData(ctx context.Context, sel ast.SelectionSet, v DraftData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DraftData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx context.Context, v interface{}) ([]*DraftEntityInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DraftEntityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNDraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx context.Context, v interface{}) (*DraftEntityInput, error) {
	res, err := ec.unmarshalInputDraftEntityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDraftFingerprint2githubcomstashappstashboxpkgmodelsDraftFingerprint(ctx context.Context, sel ast.SelectionSet, v DraftFingerprint) graphql.Marshaler {
	return ec._DraftFingerprint(ctx, sel, &v)
}

func (ec *executionContext) marshalNDraftFingerprint2githubcomstashappstashboxpkgmodelsDraftFingerprint(ctx context.Context, sel ast.SelectionSet, v []DraftFingerprint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDraftFingerprint2githubcomstashappstashboxpkgmodelsDraftFingerprint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDraftSubmissionStatus2githubcomstashappstashboxpkgmodelsDraftSubmissionStatus(ctx context.Context, sel ast.SelectionSet, v DraftSubmissionStatus) graphql.Marshaler {
	return ec._DraftSubmissionStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNDraftSubmissionStatus2githubcomstashappstashboxpkgmodelsDraftSubmissionStatus(ctx context.Context, sel ast.SelectionSet, v *DraftSubmissionStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DraftSubmissionStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx context.Context, sel ast.SelectionSet, v Edit) graphql.Marshaler {
	return ec._Edit(ctx, sel, &v)
}

func (ec *executionContext) marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx context.Context, sel ast.SelectionSet, v []*Edit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEdit2githubcomstashappstashboxpkgmodelsEdit(ctx context.Context, sel ast.SelectionSet, v *Edit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Edit(ctx, sel, v)
}

func (ec *executionContext) marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx context.Context, sel ast.SelectionSet, v []*EditComment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEditComment2githubcomstashappstashboxpkgmodelsEditComment(ctx context.Context, sel ast.SelectionSet, v *EditComment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EditComment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEditCommentInput2githubcomstashappstashboxpkgmodelsEditCommentInput(ctx context.Context, v interface{}) (EditCommentInput, error) {
	res, err := ec.unmarshalInputEditCommentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEditInput2githubcomstashappstashboxpkgmodelsEditInput(ctx context.Context, v interface{}) (*EditInput, error) {
	res, err := ec.unmarshalInputEditInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEditQueryInput2githubcomstashappstashboxpkgmodelsEditQueryInput(ctx context.Context, v interface{}) (EditQueryInput, error) {
	res, err := ec.unmarshalInputEditQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEditSortEnum2githubcomstashappstashboxpkgmodelsEditSortEnum(ctx context.Context, v interface{}) (EditSortEnum, error) {
	var res EditSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEditSortEnum2githubcomstashappstashboxpkgmodelsEditSortEnum(ctx context.Context, sel ast.SelectionSet, v EditSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEditTarget2githubcomstashappstashboxpkgmodelsEditTarget(ctx context.Context, sel ast.SelectionSet, v EditTarget) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EditTarget(ctx, sel, v)
}

func (ec *executionContext) marshalNEditTarget2githubcomstashappstashboxpkgmodelsEditTarget(ctx context.Context, sel ast.SelectionSet, v []EditTarget) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEditTarget2githubcomstashappstashboxpkgmodelsEditTarget(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEditVote2githubcomstashappstashboxpkgmodelsEditVote(ctx context.Context, sel ast.SelectionSet, v []*EditVote) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEditVote2githubcomstashappstashboxpkgmodelsEditVote(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEditVote2githubcomstashappstashboxpkgmodelsEditVote(ctx context.Context, sel ast.SelectionSet, v *EditVote) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EditVote(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEditVoteInput2githubcomstashappstashboxpkgmodelsEditVoteInput(ctx context.Context, v interface{}) (EditVoteInput, error) {
	res, err := ec.unmarshalInputEditVoteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx context.Context, sel ast.SelectionSet, v []*Fingerprint) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx context.Context, sel ast.SelectionSet, v *Fingerprint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Fingerprint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx context.Context, v interface{}) (FingerprintAlgorithm, error) {
	var res FingerprintAlgorithm
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFingerprintAlgorithm2githubcomstashappstashboxpkgmodelsFingerprintAlgorithm(ctx context.Context, sel ast.SelectionSet, v FingerprintAlgorithm) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx context.Context, v interface{}) ([]*FingerprintEditInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FingerprintEditInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx context.Context, v interface{}) (*FingerprintEditInput, error) {
	res, err := ec.unmarshalInputFingerprintEditInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx context.Context, v interface{}) ([]*FingerprintInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FingerprintInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx context.Context, v interface{}) (*FingerprintInput, error) {
	res, err := ec.unmarshalInputFingerprintInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx context.Context, v interface{}) (FingerprintQueryInput, error) {
	res, err := ec.unmarshalInputFingerprintQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx context.Context, v interface{}) ([][]*FingerprintQueryInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([][]*FingerprintQueryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx context.Context, v interface{}) ([]*FingerprintQueryInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FingerprintQueryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFingerprintQueryInput2githubcomstashappstashboxpkgmodelsFingerprintQueryInput(ctx context.Context, v interface{}) (*FingerprintQueryInput, error) {
	res, err := ec.unmarshalInputFingerprintQueryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFingerprintSubmission2githubcomstashappstashboxpkgmodelsFingerprintSubmission(ctx context.Context, v interface{}) (FingerprintSubmission, error) {
	res, err := ec.unmarshalInputFingerprintSubmission(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGrantInviteInput2githubcomstashappstashboxpkgmodelsGrantInviteInput(ctx context.Context, v interface{}) (GrantInviteInput, error) {
	res, err := ec.unmarshalInputGrantInviteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2githubcomgofrsuuidUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	res, err := UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubcomgofrsuuidUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2githubcomgofrsuuidUUID(ctx context.Context, v interface{}) ([]uuid.UUID, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]uuid.UUID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2githubcomgofrsuuidUUID(ctx context.Context, sel ast.SelectionSet, v []uuid.UUID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2githubcomgofrsuuidUUID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx context.Context, sel ast.SelectionSet, v []*Image) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImage2githubcomstashappstashboxpkgmodelsImage(ctx context.Context, sel ast.SelectionSet, v *Image) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalNImageCreateInput2githubcomstashappstashboxpkgmodelsImageCreateInput(ctx context.Context, v interface{}) (ImageCreateInput, error) {
	res, err := ec.unmarshalInputImageCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNImageDestroyInput2githubcomstashappstashboxpkgmodelsImageDestroyInput(ctx context.Context, v interface{}) (ImageDestroyInput, error) {
	res, err := ec.unmarshalInputImageDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNInviteKey2githubcomstashappstashboxpkgmodelsInviteKey(ctx context.Context, sel ast.SelectionSet, v *InviteKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._InviteKey(ctx, sel, v)
}

func (ec *executionContext) marshalNMeasurements2githubcomstashappstashboxpkgmodelsMeasurements(ctx context.Context, sel ast.SelectionSet, v Measurements) graphql.Marshaler {
	return ec._Measurements(ctx, sel, &v)
}

func (ec *executionContext) marshalNMeasurements2githubcomstashappstashboxpkgmodelsMeasurements(ctx context.Context, sel ast.SelectionSet, v *Measurements) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Measurements(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNewUserInput2githubcomstashappstashboxpkgmodelsNewUserInput(ctx context.Context, v interface{}) (NewUserInput, error) {
	res, err := ec.unmarshalInputNewUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNotification2githubcomstashappstashboxpkgmodelsNotification(ctx context.Context, sel ast.SelectionSet, v []*Notification) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotification2githubcomstashappstashboxpkgmodelsNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNotification2githubcomstashappstashboxpkgmodelsNotification(ctx context.Context, sel ast.SelectionSet, v *Notification) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalNNotificationData2githubcomstashappstashboxpkgmodelsNotificationData(ctx context.Context, sel ast.SelectionSet, v NotificationData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NotificationData(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx context.Context, v interface{}) (NotificationEnum, error) {
	var res NotificationEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx context.Context, sel ast.SelectionSet, v NotificationEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx context.Context, v interface{}) ([]NotificationEnum, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]NotificationEnum, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx context.Context, sel ast.SelectionSet, v []NotificationEnum) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx context.Context, v interface{}) (OperationEnum, error) {
	var res OperationEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx context.Context, sel ast.SelectionSet, v OperationEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx context.Context, sel ast.SelectionSet, v []*Performer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx context.Context, sel ast.SelectionSet, v *Performer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Performer(ctx, sel, v)
}

func (ec *executionContext) marshalNPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx context.Context, sel ast.SelectionSet, v []*PerformerAppearance) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx context.Context, sel ast.SelectionSet, v *PerformerAppearance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PerformerAppearance(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPerformerAppearanceInput2githubcomstashappstashboxpkgmodelsPerformerAppearanceInput(ctx context.Context, v interface{}) (*PerformerAppearanceInput, error) {
	res, err := ec.unmarshalInputPerformerAppearanceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPerformerCreateInput2githubcomstashappstashboxpkgmodelsPerformerCreateInput(ctx context.Context, v interface{}) (PerformerCreateInput, error) {
	res, err := ec.unmarshalInputPerformerCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPerformerDestroyInput2githubcomstashappstashboxpkgmodelsPerformerDestroyInput(ctx context.Context, v interface{}) (PerformerDestroyInput, error) {
	res, err := ec.unmarshalInputPerformerDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPerformerDraftInput2githubcomstashappstashboxpkgmodelsPerformerDraftInput(ctx context.Context, v interface{}) (PerformerDraftInput, error) {
	res, err := ec.unmarshalInputPerformerDraftInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPerformerEditInput2githubcomstashappstashboxpkgmodelsPerformerEditInput(ctx context.Context, v interface{}) (PerformerEditInput, error) {
	res, err := ec.unmarshalInputPerformerEditInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPerformerQueryInput2githubcomstashappstashboxpkgmodelsPerformerQueryInput(ctx context.Context, v interface{}) (PerformerQueryInput, error) {
	res, err := ec.unmarshalInputPerformerQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPerformerSortEnum2githubcomstashappstashboxpkgmodelsPerformerSortEnum(ctx context.Context, v interface{}) (PerformerSortEnum, error) {
	var res PerformerSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPerformerSortEnum2githubcomstashappstashboxpkgmodelsPerformerSortEnum(ctx context.Context, sel ast.SelectionSet, v PerformerSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPerformerStudio2githubcomstashappstashboxpkgmodelsPerformerStudio(ctx context.Context, sel ast.SelectionSet, v []*PerformerStudio) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPerformerStudio2githubcomstashappstashboxpkgmodelsPerformerStudio(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPerformerStudio2githubcomstashappstashboxpkgmodelsPerformerStudio(ctx context.Context, sel ast.SelectionSet, v *PerformerStudio) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PerformerStudio(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPerformerUpdateInput2githubcomstashappstashboxpkgmodelsPerformerUpdateInput(ctx context.Context, v interface{}) (PerformerUpdateInput, error) {
	res, err := ec.unmarshalInputPerformerUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNQueryEditsResultType2githubcomstashappstashboxpkgmodelsEditQuery(ctx context.Context, sel ast.SelectionSet, v EditQuery) graphql.Marshaler {
	return ec._QueryEditsResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryEditsResultType2githubcomstashappstashboxpkgmodelsEditQuery(ctx context.Context, sel ast.SelectionSet, v *EditQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryEditsResultType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNQueryExistingPerformerInput2githubcomstashappstashboxpkgmodelsQueryExistingPerformerInput(ctx context.Context, v interface{}) (QueryExistingPerformerInput, error) {
	res, err := ec.unmarshalInputQueryExistingPerformerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNQueryExistingPerformerResult2githubcomstashappstashboxpkgmodelsQueryExistingPerformerResult(ctx context.Context, sel ast.SelectionSet, v QueryExistingPerformerResult) graphql.Marshaler {
	return ec._QueryExistingPerformerResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryExistingPerformerResult2githubcomstashappstashboxpkgmodelsQueryExistingPerformerResult(ctx context.Context, sel ast.SelectionSet, v *QueryExistingPerformerResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryExistingPerformerResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNQueryExistingSceneInput2githubcomstashappstashboxpkgmodelsQueryExistingSceneInput(ctx context.Context, v interface{}) (QueryExistingSceneInput, error) {
	res, err := ec.unmarshalInputQueryExistingSceneInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNQueryExistingSceneResult2githubcomstashappstashboxpkgmodelsQueryExistingSceneResult(ctx context.Context, sel ast.SelectionSet, v QueryExistingSceneResult) graphql.Marshaler {
	return ec._QueryExistingSceneResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryExistingSceneResult2githubcomstashappstashboxpkgmodelsQueryExistingSceneResult(ctx context.Context, sel ast.SelectionSet, v *QueryExistingSceneResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryExistingSceneResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNQueryNotificationsInput2githubcomstashappstashboxpkgmodelsQueryNotificationsInput(ctx context.Context, v interface{}) (QueryNotificationsInput, error) {
	res, err := ec.unmarshalInputQueryNotificationsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNQueryNotificationsResult2githubcomstashappstashboxpkgmodelsQueryNotificationsResult(ctx context.Context, sel ast.SelectionSet, v QueryNotificationsResult) graphql.Marshaler {
	return ec._QueryNotificationsResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryNotificationsResult2githubcomstashappstashboxpkgmodelsQueryNotificationsResult(ctx context.Context, sel ast.SelectionSet, v *QueryNotificationsResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryNotificationsResult(ctx, sel, v)
}

func (ec *executionContext) marshalNQueryPerformersResultType2githubcomstashappstashboxpkgmodelsPerformerQuery(ctx context.Context, sel ast.SelectionSet, v PerformerQuery) graphql.Marshaler {
	return ec._QueryPerformersResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryPerformersResultType2githubcomstashappstashboxpkgmodelsPerformerQuery(ctx context.Context, sel ast.SelectionSet, v *PerformerQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryPerformersResultType(ctx, sel, v)
}

func (ec *executionContext) marshalNQueryScenesResultType2githubcomstashappstashboxpkgmodelsSceneQuery(ctx context.Context, sel ast.SelectionSet, v SceneQuery) graphql.Marshaler {
	return ec._QueryScenesResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryScenesResultType2githubcomstashappstashboxpkgmodelsSceneQuery(ctx context.Context, sel ast.SelectionSet, v *SceneQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryScenesResultType(ctx, sel, v)
}

func (ec *executionContext) marshalNQuerySitesResultType2githubcomstashappstashboxpkgmodelsQuerySitesResultType(ctx context.Context, sel ast.SelectionSet, v QuerySitesResultType) graphql.Marshaler {
	return ec._QuerySitesResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQuerySitesResultType2githubcomstashappstashboxpkgmodelsQuerySitesResultType(ctx context.Context, sel ast.SelectionSet, v *QuerySitesResultType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QuerySitesResultType(ctx, sel, v)
}

func (ec *executionContext) marshalNQueryStudiosResultType2githubcomstashappstashboxpkgmodelsQueryStudiosResultType(ctx context.Context, sel ast.SelectionSet, v QueryStudiosResultType) graphql.Marshaler {
	return ec._QueryStudiosResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryStudiosResultType2githubcomstashappstashboxpkgmodelsQueryStudiosResultType(ctx context.Context, sel ast.SelectionSet, v *QueryStudiosResultType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryStudiosResultType(ctx, sel, v)
}

func (ec *executionContext) marshalNQueryTagCategoriesResultType2githubcomstashappstashboxpkgmodelsQueryTagCategoriesResultType(ctx context.Context, sel ast.SelectionSet, v QueryTagCategoriesResultType) graphql.Marshaler {
	return ec._QueryTagCategoriesResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryTagCategoriesResultType2githubcomstashappstashboxpkgmodelsQueryTagCategoriesResultType(ctx context.Context, sel ast.SelectionSet, v *QueryTagCategoriesResultType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryTagCategoriesResultType(ctx, sel, v)
}

func (ec *executionContext) marshalNQueryTagsResultType2githubcomstashappstashboxpkgmodelsQueryTagsResultType(ctx context.Context, sel ast.SelectionSet, v QueryTagsResultType) graphql.Marshaler {
	return ec._QueryTagsResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryTagsResultType2githubcomstashappstashboxpkgmodelsQueryTagsResultType(ctx context.Context, sel ast.SelectionSet, v *QueryTagsResultType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryTagsResultType(ctx, sel, v)
}

func (ec *executionContext) marshalNQueryUsersResultType2githubcomstashappstashboxpkgmodelsQueryUsersResultType(ctx context.Context, sel ast.SelectionSet, v QueryUsersResultType) graphql.Marshaler {
	return ec._QueryUsersResultType(ctx, sel, &v)
}

func (ec *executionContext) marshalNQueryUsersResultType2githubcomstashappstashboxpkgmodelsQueryUsersResultType(ctx context.Context, sel ast.SelectionSet, v *QueryUsersResultType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QueryUsersResultType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNResetPasswordInput2githubcomstashappstashboxpkgmodelsResetPasswordInput(ctx context.Context, v interface{}) (ResetPasswordInput, error) {
	res, err := ec.unmarshalInputResetPasswordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRevokeInviteInput2githubcomstashappstashboxpkgmodelsRevokeInviteInput(ctx context.Context, v interface{}) (RevokeInviteInput, error) {
	res, err := ec.unmarshalInputRevokeInviteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx context.Context, v interface{}) (RoleEnum, error) {
	var res RoleEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx context.Context, sel ast.SelectionSet, v RoleEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx context.Context, v interface{}) ([]RoleEnum, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]RoleEnum, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx context.Context, sel ast.SelectionSet, v []RoleEnum) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx context.Context, sel ast.SelectionSet, v [][]*Scene) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx context.Context, sel ast.SelectionSet, v []*Scene) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScene2githubcomstashappstashboxpkgmodelsScene(ctx context.Context, sel ast.SelectionSet, v *Scene) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Scene(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSceneCreateInput2githubcomstashappstashboxpkgmodelsSceneCreateInput(ctx context.Context, v interface{}) (SceneCreateInput, error) {
	res, err := ec.unmarshalInputSceneCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSceneDestroyInput2githubcomstashappstashboxpkgmodelsSceneDestroyInput(ctx context.Context, v interface{}) (SceneDestroyInput, error) {
	res, err := ec.unmarshalInputSceneDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSceneDraftInput2githubcomstashappstashboxpkgmodelsSceneDraftInput(ctx context.Context, v interface{}) (SceneDraftInput, error) {
	res, err := ec.unmarshalInputSceneDraftInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSceneDraftPerformer2githubcomstashappstashboxpkgmodelsSceneDraftPerformer(ctx context.Context, sel ast.SelectionSet, v SceneDraftPerformer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneDraftPerformer(ctx, sel, v)
}

func (ec *executionContext) marshalNSceneDraftPerformer2githubcomstashappstashboxpkgmodelsSceneDraftPerformer(ctx context.Context, sel ast.SelectionSet, v []SceneDraftPerformer) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneDraftPerformer2githubcomstashappstashboxpkgmodelsSceneDraftPerformer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSceneDraftTag2githubcomstashappstashboxpkgmodelsSceneDraftTag(ctx context.Context, sel ast.SelectionSet, v SceneDraftTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SceneDraftTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSceneEditInput2githubcomstashappstashboxpkgmodelsSceneEditInput(ctx context.Context, v interface{}) (SceneEditInput, error) {
	res, err := ec.unmarshalInputSceneEditInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSceneQueryInput2githubcomstashappstashboxpkgmodelsSceneQueryInput(ctx context.Context, v interface{}) (SceneQueryInput, error) {
	res, err := ec.unmarshalInputSceneQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSceneSortEnum2githubcomstashappstashboxpkgmodelsSceneSortEnum(ctx context.Context, v interface{}) (SceneSortEnum, error) {
	var res SceneSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSceneSortEnum2githubcomstashappstashboxpkgmodelsSceneSortEnum(ctx context.Context, sel ast.SelectionSet, v SceneSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSceneUpdateInput2githubcomstashappstashboxpkgmodelsSceneUpdateInput(ctx context.Context, v interface{}) (SceneUpdateInput, error) {
	res, err := ec.unmarshalInputSceneUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSite2githubcomstashappstashboxpkgmodelsSite(ctx context.Context, sel ast.SelectionSet, v Site) graphql.Marshaler {
	return ec._Site(ctx, sel, &v)
}

func (ec *executionContext) marshalNSite2githubcomstashappstashboxpkgmodelsSite(ctx context.Context, sel ast.SelectionSet, v []*Site) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSite2githubcomstashappstashboxpkgmodelsSite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSite2githubcomstashappstashboxpkgmodelsSite(ctx context.Context, sel ast.SelectionSet, v *Site) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Site(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSiteCreateInput2githubcomstashappstashboxpkgmodelsSiteCreateInput(ctx context.Context, v interface{}) (SiteCreateInput, error) {
	res, err := ec.unmarshalInputSiteCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSiteDestroyInput2githubcomstashappstashboxpkgmodelsSiteDestroyInput(ctx context.Context, v interface{}) (SiteDestroyInput, error) {
	res, err := ec.unmarshalInputSiteDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSiteUpdateInput2githubcomstashappstashboxpkgmodelsSiteUpdateInput(ctx context.Context, v interface{}) (SiteUpdateInput, error) {
	res, err := ec.unmarshalInputSiteUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx context.Context, v interface{}) (SortDirectionEnum, error) {
	var res SortDirectionEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortDirectionEnum2githubcomstashappstashboxpkgmodelsSortDirectionEnum(ctx context.Context, sel ast.SelectionSet, v SortDirectionEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStashBoxConfig2githubcomstashappstashboxpkgmodelsStashBoxConfig(ctx context.Context, sel ast.SelectionSet, v StashBoxConfig) graphql.Marshaler {
	return ec._StashBoxConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNStashBoxConfig2githubcomstashappstashboxpkgmodelsStashBoxConfig(ctx context.Context, sel ast.SelectionSet, v *StashBoxConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StashBoxConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx context.Context, sel ast.SelectionSet, v Studio) graphql.Marshaler {
	return ec._Studio(ctx, sel, &v)
}

func (ec *executionContext) marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx context.Context, sel ast.SelectionSet, v []*Studio) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStudio2githubcomstashappstashboxpkgmodelsStudio(ctx context.Context, sel ast.SelectionSet, v *Studio) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Studio(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStudioCreateInput2githubcomstashappstashboxpkgmodelsStudioCreateInput(ctx context.Context, v interface{}) (StudioCreateInput, error) {
	res, err := ec.unmarshalInputStudioCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStudioDestroyInput2githubcomstashappstashboxpkgmodelsStudioDestroyInput(ctx context.Context, v interface{}) (StudioDestroyInput, error) {
	res, err := ec.unmarshalInputStudioDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStudioEditInput2githubcomstashappstashboxpkgmodelsStudioEditInput(ctx context.Context, v interface{}) (StudioEditInput, error) {
	res, err := ec.unmarshalInputStudioEditInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStudioQueryInput2githubcomstashappstashboxpkgmodelsStudioQueryInput(ctx context.Context, v interface{}) (StudioQueryInput, error) {
	res, err := ec.unmarshalInputStudioQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStudioSortEnum2githubcomstashappstashboxpkgmodelsStudioSortEnum(ctx context.Context, v interface{}) (StudioSortEnum, error) {
	var res StudioSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStudioSortEnum2githubcomstashappstashboxpkgmodelsStudioSortEnum(ctx context.Context, sel ast.SelectionSet, v StudioSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNStudioUpdateInput2githubcomstashappstashboxpkgmodelsStudioUpdateInput(ctx context.Context, v interface{}) (StudioUpdateInput, error) {
	res, err := ec.unmarshalInputStudioUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx context.Context, sel ast.SelectionSet, v []*TagCategory) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx context.Context, sel ast.SelectionSet, v *TagCategory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagCategory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagCategoryCreateInput2githubcomstashappstashboxpkgmodelsTagCategoryCreateInput(ctx context.Context, v interface{}) (TagCategoryCreateInput, error) {
	res, err := ec.unmarshalInputTagCategoryCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagCategoryDestroyInput2githubcomstashappstashboxpkgmodelsTagCategoryDestroyInput(ctx context.Context, v interface{}) (TagCategoryDestroyInput, error) {
	res, err := ec.unmarshalInputTagCategoryDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagCategoryUpdateInput2githubcomstashappstashboxpkgmodelsTagCategoryUpdateInput(ctx context.Context, v interface{}) (TagCategoryUpdateInput, error) {
	res, err := ec.unmarshalInputTagCategoryUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagCreateInput2githubcomstashappstashboxpkgmodelsTagCreateInput(ctx context.Context, v interface{}) (TagCreateInput, error) {
	res, err := ec.unmarshalInputTagCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagDestroyInput2githubcomstashappstashboxpkgmodelsTagDestroyInput(ctx context.Context, v interface{}) (TagDestroyInput, error) {
	res, err := ec.unmarshalInputTagDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagEditInput2githubcomstashappstashboxpkgmodelsTagEditInput(ctx context.Context, v interface{}) (TagEditInput, error) {
	res, err := ec.unmarshalInputTagEditInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx context.Context, v interface{}) (TagGroupEnum, error) {
	var res TagGroupEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx context.Context, sel ast.SelectionSet, v TagGroupEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTagQueryInput2githubcomstashappstashboxpkgmodelsTagQueryInput(ctx context.Context, v interface{}) (TagQueryInput, error) {
	res, err := ec.unmarshalInputTagQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagSortEnum2githubcomstashappstashboxpkgmodelsTagSortEnum(ctx context.Context, v interface{}) (TagSortEnum, error) {
	var res TagSortEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagSortEnum2githubcomstashappstashboxpkgmodelsTagSortEnum(ctx context.Context, sel ast.SelectionSet, v TagSortEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTagUpdateInput2githubcomstashappstashboxpkgmodelsTagUpdateInput(ctx context.Context, v interface{}) (TagUpdateInput, error) {
	res, err := ec.unmarshalInputTagUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTargetTypeEnum2githubcomstashappstashboxpkgmodelsTargetTypeEnum(ctx context.Context, v interface{}) (TargetTypeEnum, error) {
	var res TargetTypeEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTargetTypeEnum2githubcomstashappstashboxpkgmodelsTargetTypeEnum(ctx context.Context, sel ast.SelectionSet, v TargetTypeEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx context.Context, sel ast.SelectionSet, v []*URL) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx context.Context, sel ast.SelectionSet, v *URL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._URL(ctx, sel, v)
}

func (ec *executionContext) unmarshalNURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx context.Context, v interface{}) (*URLInput, error) {
	res, err := ec.unmarshalInputURLInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomstashappstashboxpkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v []*User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcomstashappstashboxpkgmodelsUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcomstashappstashboxpkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserChangeEmailStatus2githubcomstashappstashboxpkgmodelsUserChangeEmailStatus(ctx context.Context, v interface{}) (UserChangeEmailStatus, error) {
	var res UserChangeEmailStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserChangeEmailStatus2githubcomstashappstashboxpkgmodelsUserChangeEmailStatus(ctx context.Context, sel ast.SelectionSet, v UserChangeEmailStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserChangePasswordInput2githubcomstashappstashboxpkgmodelsUserChangePasswordInput(ctx context.Context, v interface{}) (UserChangePasswordInput, error) {
	res, err := ec.unmarshalInputUserChangePasswordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserCreateInput2githubcomstashappstashboxpkgmodelsUserCreateInput(ctx context.Context, v interface{}) (UserCreateInput, error) {
	res, err := ec.unmarshalInputUserCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserDestroyInput2githubcomstashappstashboxpkgmodelsUserDestroyInput(ctx context.Context, v interface{}) (UserDestroyInput, error) {
	res, err := ec.unmarshalInputUserDestroyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserEditCount2githubcomstashappstashboxpkgmodelsUserEditCount(ctx context.Context, sel ast.SelectionSet, v UserEditCount) graphql.Marshaler {
	return ec._UserEditCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserEditCount2githubcomstashappstashboxpkgmodelsUserEditCount(ctx context.Context, sel ast.SelectionSet, v *UserEditCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserEditCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserQueryInput2githubcomstashappstashboxpkgmodelsUserQueryInput(ctx context.Context, v interface{}) (UserQueryInput, error) {
	res, err := ec.unmarshalInputUserQueryInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserUpdateInput2githubcomstashappstashboxpkgmodelsUserUpdateInput(ctx context.Context, v interface{}) (UserUpdateInput, error) {
	res, err := ec.unmarshalInputUserUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserVoteCount2githubcomstashappstashboxpkgmodelsUserVoteCount(ctx context.Context, sel ast.SelectionSet, v UserVoteCount) graphql.Marshaler {
	return ec._UserVoteCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserVoteCount2githubcomstashappstashboxpkgmodelsUserVoteCount(ctx context.Context, sel ast.SelectionSet, v *UserVoteCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserVoteCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx context.Context, v interface{}) (ValidSiteTypeEnum, error) {
	var res ValidSiteTypeEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx context.Context, sel ast.SelectionSet, v ValidSiteTypeEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx context.Context, v interface{}) ([]ValidSiteTypeEnum, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]ValidSiteTypeEnum, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx context.Context, sel ast.SelectionSet, v []ValidSiteTypeEnum) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidSiteTypeEnum2githubcomstashappstashboxpkgmodelsValidSiteTypeEnum(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2githubcomstashappstashboxpkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2githubcomstashappstashboxpkgmodelsVersion(ctx context.Context, sel ast.SelectionSet, v *Version) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVoteStatusEnum2githubcomstashappstashboxpkgmodelsVoteStatusEnum(ctx context.Context, v interface{}) (VoteStatusEnum, error) {
	var res VoteStatusEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVoteStatusEnum2githubcomstashappstashboxpkgmodelsVoteStatusEnum(ctx context.Context, sel ast.SelectionSet, v VoteStatusEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNVoteTypeEnum2githubcomstashappstashboxpkgmodelsVoteTypeEnum(ctx context.Context, v interface{}) (VoteTypeEnum, error) {
	var res VoteTypeEnum
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVoteTypeEnum2githubcomstashappstashboxpkgmodelsVoteTypeEnum(ctx context.Context, sel ast.SelectionSet, v VoteTypeEnum) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx context.Context, sel ast.SelectionSet, v []*BodyModification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBodyModification2githubcomstashappstashboxpkgmodelsBodyModification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBodyModificationCriterionInput2githubcomstashappstashboxpkgmodelsBodyModificationCriterionInput(ctx context.Context, v interface{}) (*BodyModificationCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBodyModificationCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx context.Context, v interface{}) ([]*BodyModification, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*BodyModification, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyModificationInput2githubcomstashappstashboxpkgmodelsBodyModification(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBreastTypeCriterionInput2githubcomstashappstashboxpkgmodelsBreastTypeCriterionInput(ctx context.Context, v interface{}) (*BreastTypeCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBreastTypeCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx context.Context, v interface{}) (*BreastTypeEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(BreastTypeEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBreastTypeEnum2githubcomstashappstashboxpkgmodelsBreastTypeEnum(ctx context.Context, sel ast.SelectionSet, v *BreastTypeEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODateCriterionInput2githubcomstashappstashboxpkgmodelsDateCriterionInput(ctx context.Context, v interface{}) (*DateCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDateCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODraft2githubcomstashappstashboxpkgmodelsDraft(ctx context.Context, sel ast.SelectionSet, v *Draft) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Draft(ctx, sel, v)
}

func (ec *executionContext) unmarshalODraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx context.Context, v interface{}) ([]*DraftEntityInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DraftEntityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODraftEntityInput2githubcomstashappstashboxpkgmodelsDraftEntityInput(ctx context.Context, v interface{}) (*DraftEntityInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDraftEntityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEdit2githubcomstashappstashboxpkgmodelsEdit(ctx context.Context, sel ast.SelectionSet, v *Edit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Edit(ctx, sel, v)
}

func (ec *executionContext) marshalOEditDetails2githubcomstashappstashboxpkgmodelsEditDetails(ctx context.Context, sel ast.SelectionSet, v EditDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EditDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOEditTarget2githubcomstashappstashboxpkgmodelsEditTarget(ctx context.Context, sel ast.SelectionSet, v EditTarget) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EditTarget(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx context.Context, v interface{}) (*EthnicityEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(EthnicityEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEthnicityEnum2githubcomstashappstashboxpkgmodelsEthnicityEnum(ctx context.Context, sel ast.SelectionSet, v *EthnicityEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEthnicityFilterEnum2githubcomstashappstashboxpkgmodelsEthnicityFilterEnum(ctx context.Context, v interface{}) (*EthnicityFilterEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(EthnicityFilterEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEthnicityFilterEnum2githubcomstashappstashboxpkgmodelsEthnicityFilterEnum(ctx context.Context, sel ast.SelectionSet, v *EthnicityFilterEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEyeColorCriterionInput2githubcomstashappstashboxpkgmodelsEyeColorCriterionInput(ctx context.Context, v interface{}) (*EyeColorCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEyeColorCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx context.Context, v interface{}) (*EyeColorEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(EyeColorEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEyeColorEnum2githubcomstashappstashboxpkgmodelsEyeColorEnum(ctx context.Context, sel ast.SelectionSet, v *EyeColorEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFavoriteFilter2githubcomstashappstashboxpkgmodelsFavoriteFilter(ctx context.Context, v interface{}) (*FavoriteFilter, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FavoriteFilter)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFavoriteFilter2githubcomstashappstashboxpkgmodelsFavoriteFilter(ctx context.Context, sel ast.SelectionSet, v *FavoriteFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx context.Context, sel ast.SelectionSet, v []*Fingerprint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFingerprint2githubcomstashappstashboxpkgmodelsFingerprint(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx context.Context, v interface{}) ([]*FingerprintEditInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FingerprintEditInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFingerprintEditInput2githubcomstashappstashboxpkgmodelsFingerprintEditInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx context.Context, v interface{}) ([]*FingerprintInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*FingerprintInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFingerprintInput2githubcomstashappstashboxpkgmodelsFingerprintInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFingerprintSubmissionType2githubcomstashappstashboxpkgmodelsFingerprintSubmissionType(ctx context.Context, v interface{}) (*FingerprintSubmissionType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(FingerprintSubmissionType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFingerprintSubmissionType2githubcomstashappstashboxpkgmodelsFingerprintSubmissionType(ctx context.Context, sel ast.SelectionSet, v *FingerprintSubmissionType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFuzzyDate2githubcomstashappstashboxpkgmodelsFuzzyDate(ctx context.Context, sel ast.SelectionSet, v *FuzzyDate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FuzzyDate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx context.Context, v interface{}) (*GenderEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(GenderEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGenderEnum2githubcomstashappstashboxpkgmodelsGenderEnum(ctx context.Context, sel ast.SelectionSet, v *GenderEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGenderFilterEnum2githubcomstashappstashboxpkgmodelsGenderFilterEnum(ctx context.Context, v interface{}) (*GenderFilterEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(GenderFilterEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGenderFilterEnum2githubcomstashappstashboxpkgmodelsGenderFilterEnum(ctx context.Context, sel ast.SelectionSet, v *GenderFilterEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGenerateInviteCodeInput2githubcomstashappstashboxpkgmodelsGenerateInviteCodeInput(ctx context.Context, v interface{}) (*GenerateInviteCodeInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGenerateInviteCodeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHairColorCriterionInput2githubcomstashappstashboxpkgmodelsHairColorCriterionInput(ctx context.Context, v interface{}) (*HairColorCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHairColorCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx context.Context, v interface{}) (*HairColorEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(HairColorEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHairColorEnum2githubcomstashappstashboxpkgmodelsHairColorEnum(ctx context.Context, sel ast.SelectionSet, v *HairColorEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2githubcomgofrsuuidUUID(ctx context.Context, v interface{}) ([]uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]uuid.UUID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2githubcomgofrsuuidUUID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2githubcomgofrsuuidUUID(ctx context.Context, sel ast.SelectionSet, v []uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2githubcomgofrsuuidUUID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2githubcomgofrsuuidUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2githubcomgofrsuuidUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOIDCriterionInput2githubcomstashappstashboxpkgmodelsIDCriterionInput(ctx context.Context, v interface{}) (*IDCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIDCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx context.Context, sel ast.SelectionSet, v []*Image) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOImage2githubcomstashappstashboxpkgmodelsImage(ctx context.Context, sel ast.SelectionSet, v *Image) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) unmarshalOIntCriterionInput2githubcomstashappstashboxpkgmodelsIntCriterionInput(ctx context.Context, v interface{}) (*IntCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInviteKey2githubcomstashappstashboxpkgmodelsInviteKey(ctx context.Context, sel ast.SelectionSet, v []*InviteKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInviteKey2githubcomstashappstashboxpkgmodelsInviteKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMultiIDCriterionInput2githubcomstashappstashboxpkgmodelsMultiIDCriterionInput(ctx context.Context, v interface{}) (*MultiIDCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMultiIDCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMultiStringCriterionInput2githubcomstashappstashboxpkgmodelsMultiStringCriterionInput(ctx context.Context, v interface{}) (*MultiStringCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMultiStringCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx context.Context, v interface{}) (*NotificationEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(NotificationEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotificationEnum2githubcomstashappstashboxpkgmodelsNotificationEnum(ctx context.Context, sel ast.SelectionSet, v *NotificationEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx context.Context, v interface{}) (*OperationEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(OperationEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOperationEnum2githubcomstashappstashboxpkgmodelsOperationEnum(ctx context.Context, sel ast.SelectionSet, v *OperationEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOPerformer2githubcomstashappstashboxpkgmodelsPerformer(ctx context.Context, sel ast.SelectionSet, v *Performer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Performer(ctx, sel, v)
}

func (ec *executionContext) marshalOPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx context.Context, sel ast.SelectionSet, v []*PerformerAppearance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPerformerAppearance2githubcomstashappstashboxpkgmodelsPerformerAppearance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPerformerAppearanceInput2githubcomstashappstashboxpkgmodelsPerformerAppearanceInput(ctx context.Context, v interface{}) ([]*PerformerAppearanceInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*PerformerAppearanceInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPerformerAppearanceInput2githubcomstashappstashboxpkgmodelsPerformerAppearanceInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPerformerEditDetailsInput2githubcomstashappstashboxpkgmodelsPerformerEditDetailsInput(ctx context.Context, v interface{}) (*PerformerEditDetailsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPerformerEditDetailsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPerformerEditOptions2githubcomstashappstashboxpkgmodelsPerformerEditOptions(ctx context.Context, sel ast.SelectionSet, v *PerformerEditOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PerformerEditOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPerformerEditOptionsInput2githubcomstashappstashboxpkgmodelsPerformerEditOptionsInput(ctx context.Context, v interface{}) (*PerformerEditOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPerformerEditOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPerformerScenesInput2githubcomstashappstashboxpkgmodelsPerformerScenesInput(ctx context.Context, v interface{}) (*PerformerScenesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPerformerScenesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORoleCriterionInput2githubcomstashappstashboxpkgmodelsRoleCriterionInput(ctx context.Context, v interface{}) (*RoleCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRoleCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx context.Context, v interface{}) ([]RoleEnum, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]RoleEnum, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx context.Context, sel ast.SelectionSet, v []RoleEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoleEnum2githubcomstashappstashboxpkgmodelsRoleEnum(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOScene2githubcomstashappstashboxpkgmodelsScene(ctx context.Context, sel ast.SelectionSet, v *Scene) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Scene(ctx, sel, v)
}

func (ec *executionContext) marshalOSceneDraftStudio2githubcomstashappstashboxpkgmodelsSceneDraftStudio(ctx context.Context, sel ast.SelectionSet, v SceneDraftStudio) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SceneDraftStudio(ctx, sel, v)
}

func (ec *executionContext) marshalOSceneDraftTag2githubcomstashappstashboxpkgmodelsSceneDraftTag(ctx context.Context, sel ast.SelectionSet, v []SceneDraftTag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSceneDraftTag2githubcomstashappstashboxpkgmodelsSceneDraftTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSceneEditDetailsInput2githubcomstashappstashboxpkgmodelsSceneEditDetailsInput(ctx context.Context, v interface{}) (*SceneEditDetailsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSceneEditDetailsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSite2githubcomstashappstashboxpkgmodelsSite(ctx context.Context, sel ast.SelectionSet, v *Site) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Site(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringCriterionInput2githubcomstashappstashboxpkgmodelsStringCriterionInput(ctx context.Context, v interface{}) (*StringCriterionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStringCriterionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStudio2githubcomstashappstashboxpkgmodelsStudio(ctx context.Context, sel ast.SelectionSet, v *Studio) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Studio(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStudioEditDetailsInput2githubcomstashappstashboxpkgmodelsStudioEditDetailsInput(ctx context.Context, v interface{}) (*StudioEditDetailsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStudioEditDetailsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx context.Context, sel ast.SelectionSet, v []*Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2githubcomstashappstashboxpkgmodelsTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTag2githubcomstashappstashboxpkgmodelsTag(ctx context.Context, sel ast.SelectionSet, v *Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOTagCategory2githubcomstashappstashboxpkgmodelsTagCategory(ctx context.Context, sel ast.SelectionSet, v *TagCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TagCategory(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTagEditDetailsInput2githubcomstashappstashboxpkgmodelsTagEditDetailsInput(ctx context.Context, v interface{}) (*TagEditDetailsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTagEditDetailsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx context.Context, v interface{}) (*TagGroupEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(TagGroupEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTagGroupEnum2githubcomstashappstashboxpkgmodelsTagGroupEnum(ctx context.Context, sel ast.SelectionSet, v *TagGroupEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTargetTypeEnum2githubcomstashappstashboxpkgmodelsTargetTypeEnum(ctx context.Context, v interface{}) (*TargetTypeEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(TargetTypeEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTargetTypeEnum2githubcomstashappstashboxpkgmodelsTargetTypeEnum(ctx context.Context, sel ast.SelectionSet, v *TargetTypeEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOURL2githubcomstashappstashboxpkgmodelsURL(ctx context.Context, sel ast.SelectionSet, v []*URL) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNURL2githubcomstashappstashboxpkgmodelsURL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx context.Context, v interface{}) ([]*URLInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*URLInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNURLInput2githubcomstashappstashboxpkgmodelsURLInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, v interface{}) (*graphql.Upload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUpload(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, sel ast.SelectionSet, v *graphql.Upload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUpload(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomstashappstashboxpkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v *User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserVotedFilterEnum2githubcomstashappstashboxpkgmodelsUserVotedFilterEnum(ctx context.Context, v interface{}) (*UserVotedFilterEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(UserVotedFilterEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserVotedFilterEnum2githubcomstashappstashboxpkgmodelsUserVotedFilterEnum(ctx context.Context, sel ast.SelectionSet, v *UserVotedFilterEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVoteStatusEnum2githubcomstashappstashboxpkgmodelsVoteStatusEnum(ctx context.Context, v interface{}) (*VoteStatusEnum, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(VoteStatusEnum)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVoteStatusEnum2githubcomstashappstashboxpkgmodelsVoteStatusEnum(ctx context.Context, sel ast.SelectionSet, v *VoteStatusEnum) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
