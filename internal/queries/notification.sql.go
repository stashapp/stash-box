// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notification.sql

package queries

import (
	"context"

	"github.com/gofrs/uuid"
)

const countNotificationsByUser = `-- name: CountNotificationsByUser :one
SELECT COUNT(*) FROM notifications WHERE user_id = $1 AND ($2::boolean = FALSE OR read_at IS NULL)
`

type CountNotificationsByUserParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	UnreadOnly bool      `db:"unread_only" json:"unread_only"`
}

func (q *Queries) CountNotificationsByUser(ctx context.Context, arg CountNotificationsByUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNotificationsByUser, arg.UserID, arg.UnreadOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

type CreateUserNotificationSubscriptionsParams struct {
	UserID uuid.UUID        `db:"user_id" json:"user_id"`
	Type   NotificationType `db:"type" json:"type"`
}

const deleteUserNotificationSubscriptions = `-- name: DeleteUserNotificationSubscriptions :exec
DELETE FROM user_notifications WHERE user_id = $1
`

func (q *Queries) DeleteUserNotificationSubscriptions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserNotificationSubscriptions, userID)
	return err
}

const destroyExpiredNotifications = `-- name: DestroyExpiredNotifications :exec
DELETE FROM notifications
WHERE read_at < CURRENT_DATE - INTERVAL '1 day'
   OR created_at < CURRENT_DATE - INTERVAL '14 day'
`

func (q *Queries) DestroyExpiredNotifications(ctx context.Context) error {
	_, err := q.db.Exec(ctx, destroyExpiredNotifications)
	return err
}

const findNotificationsByUser = `-- name: FindNotificationsByUser :many

SELECT user_id, type, id, created_at, read_at FROM notifications WHERE user_id = $1 ORDER BY created_at DESC
`

// Notification queries
func (q *Queries) FindNotificationsByUser(ctx context.Context, userID uuid.UUID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, findNotificationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.UserID,
			&i.Type,
			&i.ID,
			&i.CreatedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUnreadNotificationsByUser = `-- name: FindUnreadNotificationsByUser :many
SELECT user_id, type, id, created_at, read_at FROM notifications WHERE user_id = $1 AND read_at IS NULL ORDER BY created_at DESC
`

func (q *Queries) FindUnreadNotificationsByUser(ctx context.Context, userID uuid.UUID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, findUnreadNotificationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.UserID,
			&i.Type,
			&i.ID,
			&i.CreatedAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsRead = `-- name: MarkAllNotificationsRead :exec
UPDATE notifications SET read_at = NOW() WHERE user_id = $1 AND read_at IS NULL
`

func (q *Queries) MarkAllNotificationsRead(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markAllNotificationsRead, userID)
	return err
}

const markNotificationRead = `-- name: MarkNotificationRead :exec
UPDATE notifications SET read_at = NOW() WHERE user_id = $1 AND type = $2 AND id = $3 AND read_at IS NULL
`

type MarkNotificationReadParams struct {
	UserID uuid.UUID        `db:"user_id" json:"user_id"`
	Type   NotificationType `db:"type" json:"type"`
	ID     uuid.UUID        `db:"id" json:"id"`
}

func (q *Queries) MarkNotificationRead(ctx context.Context, arg MarkNotificationReadParams) error {
	_, err := q.db.Exec(ctx, markNotificationRead, arg.UserID, arg.Type, arg.ID)
	return err
}

const triggerDownvoteEditNotifications = `-- name: TriggerDownvoteEditNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT N.user_id, N.type, $1
FROM edits E
JOIN user_notifications N ON E.user_id = N.user_id AND N.type = 'DOWNVOTE_OWN_EDIT'
WHERE E.id = $1
`

func (q *Queries) TriggerDownvoteEditNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerDownvoteEditNotifications, id)
	return err
}

const triggerEditCommentNotifications = `-- name: TriggerEditCommentNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT DISTINCT ON (user_id) user_id, type, $1 FROM (
    SELECT N.user_id, N.type, 1 as ordering
    FROM edit_comments EC
    JOIN edits E ON EC.edit_id = E.id
    JOIN user_notifications N ON E.user_id = N.user_id AND N.type = 'COMMENT_OWN_EDIT'
    WHERE E.user_id != EC.user_id
    AND EC.id = $1
    UNION
    SELECT N.user_id, N.type, 2 as ordering
    FROM edit_comments EC
    JOIN edits E ON EC.edit_id = E.id
    JOIN edit_comments EO ON EO.edit_id = E.id
    JOIN user_notifications N ON EO.user_id = N.user_id AND N.type = 'COMMENT_COMMENTED_EDIT'
    WHERE EO.user_id != E.user_id
    AND EO.user_id != EC.user_id
    AND EC.id = $1
    UNION
    SELECT N.user_id, N.type, 3 as ordering
    FROM edit_comments EC
    JOIN edits E ON EC.edit_id = E.id
    JOIN edit_votes EV ON EV.edit_id = E.id
    JOIN user_notifications N ON EV.user_id = N.user_id AND N.type = 'COMMENT_VOTED_EDIT'
    WHERE EV.vote != 'ABSTAIN'
    AND EV.user_id != E.user_id
    AND EV.user_id != EC.user_id
    AND EC.id = $1
) notifications
ORDER BY user_id, ordering ASC
`

func (q *Queries) TriggerEditCommentNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerEditCommentNotifications, id)
	return err
}

const triggerFailedEditNotifications = `-- name: TriggerFailedEditNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT N.user_id, N.type, $1
FROM edits E
JOIN user_notifications N ON E.user_id = N.user_id AND N.type = 'FAILED_OWN_EDIT'
WHERE E.id = $1
`

func (q *Queries) TriggerFailedEditNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerFailedEditNotifications, id)
	return err
}

const triggerPerformerEditNotifications = `-- name: TriggerPerformerEditNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT N.user_id, N.type, $1
FROM performer_edits PE
JOIN edits E ON PE.edit_id = E.id
JOIN performer_favorites PF ON PE.performer_id = PF.performer_id
JOIN user_notifications N ON PF.user_id = N.user_id AND N.type = 'FAVORITE_PERFORMER_EDIT' AND N.user_id != E.user_id
WHERE PE.edit_id = $1
`

func (q *Queries) TriggerPerformerEditNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerPerformerEditNotifications, id)
	return err
}

const triggerSceneCreationNotifications = `-- name: TriggerSceneCreationNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT N.user_id, N.type, $1 as id
FROM scenes S
JOIN scene_edits SE ON S.id = SE.scene_id
JOIN edits E ON SE.edit_id = E.id AND E.operation = 'CREATE'
JOIN studio_favorites SF ON S.studio_id = SF.studio_id
JOIN user_notifications N ON SF.user_id = N.user_id AND N.type = 'FAVORITE_STUDIO_SCENE' AND E.user_id != N.user_id
WHERE S.id = $1
UNION
SELECT N.user_id, N.type, $1 as id
FROM scene_performers SP
JOIN scene_edits SE ON SP.scene_id = SE.scene_id
JOIN edits E ON SE.edit_id = E.id AND E.operation = 'CREATE'
JOIN performer_favorites PF ON SP.performer_id = PF.performer_id
JOIN user_notifications N ON PF.user_id = N.user_id AND N.type = 'FAVORITE_PERFORMER_SCENE' AND E.user_id != N.user_id
WHERE SP.scene_id = $1
`

func (q *Queries) TriggerSceneCreationNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerSceneCreationNotifications, id)
	return err
}

const triggerSceneEditNotifications = `-- name: TriggerSceneEditNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT DISTINCT ON (user_id) user_id, type, $1 FROM (
    SELECT N.user_id, N.type
    FROM edits E JOIN studio_favorites SF ON (E.data->'new_data'->>'studio_id')::uuid = SF.studio_id
    JOIN user_notifications N ON SF.user_id = N.user_id AND N.type = 'FAVORITE_STUDIO_EDIT' AND N.user_id != E.user_id
    WHERE E.id = $1
    UNION
    SELECT N.user_id, N.type
    FROM edits E
    JOIN scene_edits SE ON E.id = SE.edit_id
    JOIN scenes S ON SE.scene_id = S.id
    JOIN studio_favorites SF ON S.studio_id = SF.studio_id
    JOIN user_notifications N ON SF.user_id = N.user_id AND N.type = 'FAVORITE_STUDIO_EDIT' AND N.user_id != E.user_id
    WHERE E.id = $1
    UNION
    SELECT N.user_id, N.type
    FROM (
        SELECT id, (jsonb_array_elements(edits.data->'new_data'->'added_performers')->>'performer_id')::uuid AS performer_id, user_id
        FROM edits
    ) E JOIN performer_favorites PF ON E.performer_id = PF.performer_id
    JOIN user_notifications N ON PF.user_id = N.user_id AND N.type = 'FAVORITE_PERFORMER_EDIT' AND N.user_id != E.user_id
    WHERE E.id = $1
    UNION
    SELECT N.user_id, N.type
    FROM edits E
    JOIN scene_edits SE ON E.id = SE.edit_id
    JOIN scene_performers SP ON SP.scene_id = SE.scene_id
    JOIN performer_favorites PF ON PF.performer_id = SP.performer_id
    JOIN user_notifications N ON PF.user_id = N.user_id AND N.type = 'FAVORITE_PERFORMER_EDIT' AND N.user_id != E.user_id
    WHERE E.id = $1
    UNION
    SELECT N.user_id, N.type
    FROM edits E
    JOIN scene_edits SE ON E.id = SE.edit_id
    JOIN scene_fingerprints SF ON SE.scene_id = SF.scene_id
    JOIN user_notifications N ON SF.user_id = N.user_id AND N.type = 'FINGERPRINTED_SCENE_EDIT' AND N.user_id != E.user_id
    WHERE E.id = $1
) notifications
`

func (q *Queries) TriggerSceneEditNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerSceneEditNotifications, id)
	return err
}

const triggerStudioEditNotifications = `-- name: TriggerStudioEditNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT N.user_id, N.type, $1
FROM studio_edits SE
JOIN edits E ON SE.edit_id = E.id
JOIN studio_favorites SF ON SE.studio_id = SF.studio_id
JOIN user_notifications N ON SF.user_id = N.user_id AND N.type = 'FAVORITE_STUDIO_EDIT' AND N.user_id != E.user_id
WHERE SE.edit_id = $1
`

func (q *Queries) TriggerStudioEditNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerStudioEditNotifications, id)
	return err
}

const triggerUpdatedEditNotifications = `-- name: TriggerUpdatedEditNotifications :exec
INSERT INTO notifications (user_id, type, id)
SELECT N.user_id, N.type, $1
FROM edits E
JOIN edit_votes EV ON E.id = EV.edit_id
JOIN user_notifications N ON EV.user_id = N.user_id AND N.type = 'UPDATED_EDIT'
WHERE E.id = $1
`

func (q *Queries) TriggerUpdatedEditNotifications(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerUpdatedEditNotifications, id)
	return err
}
