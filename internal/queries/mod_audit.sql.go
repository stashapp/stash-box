// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mod_audit.sql

package queries

import (
	"context"
	"encoding/json"

	"github.com/gofrs/uuid"
)

const createModAudit = `-- name: CreateModAudit :one
INSERT INTO mod_audit (
    id, action, user_id, target_id, target_type, data, reason, created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
RETURNING id, action, user_id, target_id, target_type, data, reason, created_at
`

type CreateModAuditParams struct {
	ID         uuid.UUID       `db:"id" json:"id"`
	Action     ModAuditAction  `db:"action" json:"action"`
	UserID     uuid.NullUUID   `db:"user_id" json:"user_id"`
	TargetID   uuid.UUID       `db:"target_id" json:"target_id"`
	TargetType string          `db:"target_type" json:"target_type"`
	Data       json.RawMessage `db:"data" json:"data"`
	Reason     *string         `db:"reason" json:"reason"`
}

func (q *Queries) CreateModAudit(ctx context.Context, arg CreateModAuditParams) (ModAudit, error) {
	row := q.db.QueryRow(ctx, createModAudit,
		arg.ID,
		arg.Action,
		arg.UserID,
		arg.TargetID,
		arg.TargetType,
		arg.Data,
		arg.Reason,
	)
	var i ModAudit
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.UserID,
		&i.TargetID,
		&i.TargetType,
		&i.Data,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredModAudits = `-- name: DeleteExpiredModAudits :exec
DELETE FROM mod_audit
WHERE created_at < NOW() - INTERVAL '1 day' * $1
`

func (q *Queries) DeleteExpiredModAudits(ctx context.Context, dollar_1 interface{}) error {
	_, err := q.db.Exec(ctx, deleteExpiredModAudits, dollar_1)
	return err
}

const getModAuditByAction = `-- name: GetModAuditByAction :many
SELECT id, action, user_id, target_id, target_type, data, reason, created_at FROM mod_audit
WHERE action = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetModAuditByActionParams struct {
	Action ModAuditAction `db:"action" json:"action"`
	Limit  int32          `db:"limit" json:"limit"`
	Offset int32          `db:"offset" json:"offset"`
}

func (q *Queries) GetModAuditByAction(ctx context.Context, arg GetModAuditByActionParams) ([]ModAudit, error) {
	rows, err := q.db.Query(ctx, getModAuditByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModAudit{}
	for rows.Next() {
		var i ModAudit
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.UserID,
			&i.TargetID,
			&i.TargetType,
			&i.Data,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModAuditByID = `-- name: GetModAuditByID :one
SELECT id, action, user_id, target_id, target_type, data, reason, created_at FROM mod_audit WHERE id = $1
`

func (q *Queries) GetModAuditByID(ctx context.Context, id uuid.UUID) (ModAudit, error) {
	row := q.db.QueryRow(ctx, getModAuditByID, id)
	var i ModAudit
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.UserID,
		&i.TargetID,
		&i.TargetType,
		&i.Data,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const getModAuditByTargetID = `-- name: GetModAuditByTargetID :many
SELECT id, action, user_id, target_id, target_type, data, reason, created_at FROM mod_audit WHERE target_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetModAuditByTargetID(ctx context.Context, targetID uuid.UUID) ([]ModAudit, error) {
	rows, err := q.db.Query(ctx, getModAuditByTargetID, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModAudit{}
	for rows.Next() {
		var i ModAudit
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.UserID,
			&i.TargetID,
			&i.TargetType,
			&i.Data,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModAuditByUser = `-- name: GetModAuditByUser :many
SELECT id, action, user_id, target_id, target_type, data, reason, created_at FROM mod_audit
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetModAuditByUserParams struct {
	UserID uuid.NullUUID `db:"user_id" json:"user_id"`
	Limit  int32         `db:"limit" json:"limit"`
	Offset int32         `db:"offset" json:"offset"`
}

func (q *Queries) GetModAuditByUser(ctx context.Context, arg GetModAuditByUserParams) ([]ModAudit, error) {
	rows, err := q.db.Query(ctx, getModAuditByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModAudit{}
	for rows.Next() {
		var i ModAudit
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.UserID,
			&i.TargetID,
			&i.TargetType,
			&i.Data,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModAuditCount = `-- name: GetModAuditCount :one
SELECT COUNT(*) FROM mod_audit
WHERE ($1::mod_audit_action IS NULL OR action = $1)
  AND ($2::uuid IS NULL OR user_id = $2)
`

type GetModAuditCountParams struct {
	Action NullModAuditAction `db:"action" json:"action"`
	UserID uuid.NullUUID      `db:"user_id" json:"user_id"`
}

func (q *Queries) GetModAuditCount(ctx context.Context, arg GetModAuditCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getModAuditCount, arg.Action, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const queryModAudits = `-- name: QueryModAudits :many
SELECT id, action, user_id, target_id, target_type, data, reason, created_at FROM mod_audit
WHERE ($3::mod_audit_action IS NULL OR action = $3)
  AND ($4::uuid IS NULL OR user_id = $4)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type QueryModAuditsParams struct {
	Limit  int32              `db:"limit" json:"limit"`
	Offset int32              `db:"offset" json:"offset"`
	Action NullModAuditAction `db:"action" json:"action"`
	UserID uuid.NullUUID      `db:"user_id" json:"user_id"`
}

func (q *Queries) QueryModAudits(ctx context.Context, arg QueryModAuditsParams) ([]ModAudit, error) {
	rows, err := q.db.Query(ctx, queryModAudits,
		arg.Limit,
		arg.Offset,
		arg.Action,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModAudit{}
	for rows.Next() {
		var i ModAudit
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.UserID,
			&i.TargetID,
			&i.TargetType,
			&i.Data,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
