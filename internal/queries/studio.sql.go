// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: studio.sql

package queries

import (
	"context"

	"github.com/gofrs/uuid"
)

const createStudio = `-- name: CreateStudio :one

INSERT INTO studios (id, name, parent_studio_id, created_at, updated_at)
VALUES ($1, $2, $3, now(), now())
RETURNING id, name, parent_studio_id, created_at, updated_at, deleted
`

type CreateStudioParams struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	Name           string        `db:"name" json:"name"`
	ParentStudioID uuid.NullUUID `db:"parent_studio_id" json:"parent_studio_id"`
}

// Studio queries
func (q *Queries) CreateStudio(ctx context.Context, arg CreateStudioParams) (Studio, error) {
	row := q.db.QueryRow(ctx, createStudio, arg.ID, arg.Name, arg.ParentStudioID)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

type CreateStudioAliasesParams struct {
	StudioID uuid.UUID `db:"studio_id" json:"studio_id"`
	Alias    string    `db:"alias" json:"alias"`
}

const createStudioFavorite = `-- name: CreateStudioFavorite :exec

INSERT INTO studio_favorites (studio_id, user_id, created_at) VALUES ($1, $2, NOW())
`

type CreateStudioFavoriteParams struct {
	StudioID uuid.UUID `db:"studio_id" json:"studio_id"`
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
}

// Studio favorites
func (q *Queries) CreateStudioFavorite(ctx context.Context, arg CreateStudioFavoriteParams) error {
	_, err := q.db.Exec(ctx, createStudioFavorite, arg.StudioID, arg.UserID)
	return err
}

type CreateStudioImagesParams struct {
	StudioID uuid.UUID `db:"studio_id" json:"studio_id"`
	ImageID  uuid.UUID `db:"image_id" json:"image_id"`
}

const createStudioRedirect = `-- name: CreateStudioRedirect :exec

INSERT INTO studio_redirects (source_id, target_id) VALUES ($1, $2)
`

type CreateStudioRedirectParams struct {
	SourceID uuid.UUID `db:"source_id" json:"source_id"`
	TargetID uuid.UUID `db:"target_id" json:"target_id"`
}

// Studio redirects
func (q *Queries) CreateStudioRedirect(ctx context.Context, arg CreateStudioRedirectParams) error {
	_, err := q.db.Exec(ctx, createStudioRedirect, arg.SourceID, arg.TargetID)
	return err
}

type CreateStudioURLsParams struct {
	StudioID uuid.UUID `db:"studio_id" json:"studio_id"`
	Url      string    `db:"url" json:"url"`
	SiteID   uuid.UUID `db:"site_id" json:"site_id"`
}

const deleteStudio = `-- name: DeleteStudio :exec
DELETE FROM studios WHERE id = $1
`

func (q *Queries) DeleteStudio(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteStudio, id)
	return err
}

const deleteStudioAliases = `-- name: DeleteStudioAliases :exec
DELETE FROM studio_aliases WHERE studio_id = $1
`

func (q *Queries) DeleteStudioAliases(ctx context.Context, studioID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteStudioAliases, studioID)
	return err
}

const deleteStudioFavorite = `-- name: DeleteStudioFavorite :exec
DELETE FROM studio_favorites WHERE studio_id = $1 AND user_id = $2
`

type DeleteStudioFavoriteParams struct {
	StudioID uuid.UUID `db:"studio_id" json:"studio_id"`
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteStudioFavorite(ctx context.Context, arg DeleteStudioFavoriteParams) error {
	_, err := q.db.Exec(ctx, deleteStudioFavorite, arg.StudioID, arg.UserID)
	return err
}

const deleteStudioFavorites = `-- name: DeleteStudioFavorites :exec
DELETE FROM studio_favorites WHERE studio_id = $1
`

func (q *Queries) DeleteStudioFavorites(ctx context.Context, studioID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteStudioFavorites, studioID)
	return err
}

const deleteStudioImages = `-- name: DeleteStudioImages :exec
DELETE FROM studio_images WHERE studio_id = $1
`

func (q *Queries) DeleteStudioImages(ctx context.Context, studioID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteStudioImages, studioID)
	return err
}

const deleteStudioURLs = `-- name: DeleteStudioURLs :exec
DELETE FROM studio_urls WHERE studio_id = $1
`

func (q *Queries) DeleteStudioURLs(ctx context.Context, studioID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteStudioURLs, studioID)
	return err
}

const findStudio = `-- name: FindStudio :one
SELECT id, name, parent_studio_id, created_at, updated_at, deleted FROM studios WHERE id = $1
`

func (q *Queries) FindStudio(ctx context.Context, id uuid.UUID) (Studio, error) {
	row := q.db.QueryRow(ctx, findStudio, id)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const findStudioAliasesByIds = `-- name: FindStudioAliasesByIds :many
SELECT studio_id, alias FROM studio_aliases WHERE studio_id = ANY($1::UUID[])
`

// Get aliases for multiple studios
func (q *Queries) FindStudioAliasesByIds(ctx context.Context, studioIds []uuid.UUID) ([]StudioAlias, error) {
	rows, err := q.db.Query(ctx, findStudioAliasesByIds, studioIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StudioAlias{}
	for rows.Next() {
		var i StudioAlias
		if err := rows.Scan(&i.StudioID, &i.Alias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findStudioByAlias = `-- name: FindStudioByAlias :one
SELECT s.id, s.name, s.parent_studio_id, s.created_at, s.updated_at, s.deleted FROM studios s
JOIN studio_aliases sa ON s.id = sa.studio_id
WHERE UPPER(sa.alias) = UPPER($1) AND s.deleted = false
`

func (q *Queries) FindStudioByAlias(ctx context.Context, upper interface{}) (Studio, error) {
	row := q.db.QueryRow(ctx, findStudioByAlias, upper)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const findStudioByName = `-- name: FindStudioByName :one
SELECT id, name, parent_studio_id, created_at, updated_at, deleted FROM studios WHERE UPPER(name) = UPPER($1) AND deleted = false
`

func (q *Queries) FindStudioByName(ctx context.Context, upper interface{}) (Studio, error) {
	row := q.db.QueryRow(ctx, findStudioByName, upper)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const findStudioFavoritesByIds = `-- name: FindStudioFavoritesByIds :many
SELECT studio_id, (studio_id IS NOT NULL)::BOOLEAN as is_favorite
FROM studio_favorites
WHERE studio_id = ANY($1::UUID[]) AND user_id = $2
`

type FindStudioFavoritesByIdsParams struct {
	StudioIds []uuid.UUID `db:"studio_ids" json:"studio_ids"`
	UserID    uuid.UUID   `db:"user_id" json:"user_id"`
}

type FindStudioFavoritesByIdsRow struct {
	StudioID   uuid.UUID `db:"studio_id" json:"studio_id"`
	IsFavorite bool      `db:"is_favorite" json:"is_favorite"`
}

// Check favorite status for multiple studios for a specific user
func (q *Queries) FindStudioFavoritesByIds(ctx context.Context, arg FindStudioFavoritesByIdsParams) ([]FindStudioFavoritesByIdsRow, error) {
	rows, err := q.db.Query(ctx, findStudioFavoritesByIds, arg.StudioIds, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindStudioFavoritesByIdsRow{}
	for rows.Next() {
		var i FindStudioFavoritesByIdsRow
		if err := rows.Scan(&i.StudioID, &i.IsFavorite); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findStudioUrlsByIds = `-- name: FindStudioUrlsByIds :many
SELECT studio_id, url, site_id FROM studio_urls WHERE studio_id = ANY($1::UUID[])
`

// Get URLs for multiple studios
func (q *Queries) FindStudioUrlsByIds(ctx context.Context, studioIds []uuid.UUID) ([]StudioUrl, error) {
	rows, err := q.db.Query(ctx, findStudioUrlsByIds, studioIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StudioUrl{}
	for rows.Next() {
		var i StudioUrl
		if err := rows.Scan(&i.StudioID, &i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findStudioWithRedirect = `-- name: FindStudioWithRedirect :one
SELECT s.id, s.name, s.parent_studio_id, s.created_at, s.updated_at, s.deleted FROM studios S
WHERE S.id = $1 AND S.deleted = FALSE
UNION
SELECT ss.id, ss.name, ss.parent_studio_id, ss.created_at, ss.updated_at, ss.deleted FROM studio_redirects R
JOIN studios SS ON SS.id = R.target_id
WHERE R.source_id = $1 AND SS.deleted = FALSE
`

func (q *Queries) FindStudioWithRedirect(ctx context.Context, id uuid.UUID) (Studio, error) {
	row := q.db.QueryRow(ctx, findStudioWithRedirect, id)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const getChildStudios = `-- name: GetChildStudios :many
SELECT id, name, parent_studio_id, created_at, updated_at, deleted FROM studios WHERE parent_studio_id = $1 AND deleted = false ORDER BY name
`

func (q *Queries) GetChildStudios(ctx context.Context, parentStudioID uuid.NullUUID) ([]Studio, error) {
	rows, err := q.db.Query(ctx, getChildStudios, parentStudioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Studio{}
	for rows.Next() {
		var i Studio
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentStudioID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudioAliases = `-- name: GetStudioAliases :many
SELECT alias FROM studio_aliases WHERE studio_id = $1
`

func (q *Queries) GetStudioAliases(ctx context.Context, studioID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getStudioAliases, studioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var alias string
		if err := rows.Scan(&alias); err != nil {
			return nil, err
		}
		items = append(items, alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudioImages = `-- name: GetStudioImages :many
SELECT image_id FROM studio_images WHERE studio_id = $1
`

func (q *Queries) GetStudioImages(ctx context.Context, studioID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getStudioImages, studioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var image_id uuid.UUID
		if err := rows.Scan(&image_id); err != nil {
			return nil, err
		}
		items = append(items, image_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudioURLs = `-- name: GetStudioURLs :many
SELECT studio_id, url, site_id FROM studio_urls WHERE studio_id = $1
`

func (q *Queries) GetStudioURLs(ctx context.Context, studioID uuid.UUID) ([]StudioUrl, error) {
	rows, err := q.db.Query(ctx, getStudioURLs, studioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StudioUrl{}
	for rows.Next() {
		var i StudioUrl
		if err := rows.Scan(&i.StudioID, &i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudios = `-- name: GetStudios :many
SELECT id, name, parent_studio_id, created_at, updated_at, deleted FROM studios WHERE id = ANY($1::UUID[]) ORDER BY name
`

func (q *Queries) GetStudios(ctx context.Context, dollar_1 []uuid.UUID) ([]Studio, error) {
	rows, err := q.db.Query(ctx, getStudios, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Studio{}
	for rows.Next() {
		var i Studio
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentStudioID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudiosByPerformer = `-- name: GetStudiosByPerformer :many
SELECT
    studios.id, studios.name, studios.parent_studio_id, studios.created_at, studios.updated_at, studios.deleted,
    COUNT(scenes.id) as scene_count
FROM studios
JOIN scenes ON studios.id = scenes.studio_id
JOIN scene_performers SP ON scenes.id = SP.scene_id
WHERE SP.performer_id = $1
GROUP BY studios.id
`

type GetStudiosByPerformerRow struct {
	Studio     Studio `db:"studio" json:"studio"`
	SceneCount int64  `db:"scene_count" json:"scene_count"`
}

func (q *Queries) GetStudiosByPerformer(ctx context.Context, performerID uuid.UUID) ([]GetStudiosByPerformerRow, error) {
	rows, err := q.db.Query(ctx, getStudiosByPerformer, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudiosByPerformerRow{}
	for rows.Next() {
		var i GetStudiosByPerformerRow
		if err := rows.Scan(
			&i.Studio.ID,
			&i.Studio.Name,
			&i.Studio.ParentStudioID,
			&i.Studio.CreatedAt,
			&i.Studio.UpdatedAt,
			&i.Studio.Deleted,
			&i.SceneCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudiosByPerformerAndNetwork = `-- name: GetStudiosByPerformerAndNetwork :many
WITH studio_network AS (
    -- The studio itself
    SELECT $2::uuid AS id
    UNION
    -- Parent studio (if exists)
    SELECT parent_studio_id AS id FROM studios WHERE id = $2 AND parent_studio_id IS NOT NULL
    UNION
    -- Child studios
    SELECT id FROM studios WHERE parent_studio_id = $2 AND deleted = FALSE
)
SELECT
    studios.id, studios.name, studios.parent_studio_id, studios.created_at, studios.updated_at, studios.deleted,
    COUNT(scenes.id) as scene_count
FROM studios
JOIN scenes ON studios.id = scenes.studio_id
JOIN scene_performers SP ON scenes.id = SP.scene_id
WHERE SP.performer_id = $1
  AND studios.id IN (SELECT id FROM studio_network WHERE id IS NOT NULL)
GROUP BY studios.id
`

type GetStudiosByPerformerAndNetworkParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	StudioID    uuid.UUID `db:"studio_id" json:"studio_id"`
}

type GetStudiosByPerformerAndNetworkRow struct {
	Studio     Studio `db:"studio" json:"studio"`
	SceneCount int64  `db:"scene_count" json:"scene_count"`
}

// Get studios where performer has scenes, filtered to a studio network (the studio, its parent, and children)
func (q *Queries) GetStudiosByPerformerAndNetwork(ctx context.Context, arg GetStudiosByPerformerAndNetworkParams) ([]GetStudiosByPerformerAndNetworkRow, error) {
	rows, err := q.db.Query(ctx, getStudiosByPerformerAndNetwork, arg.PerformerID, arg.StudioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudiosByPerformerAndNetworkRow{}
	for rows.Next() {
		var i GetStudiosByPerformerAndNetworkRow
		if err := rows.Scan(
			&i.Studio.ID,
			&i.Studio.Name,
			&i.Studio.ParentStudioID,
			&i.Studio.CreatedAt,
			&i.Studio.UpdatedAt,
			&i.Studio.Deleted,
			&i.SceneCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reassignStudioFavorites = `-- name: ReassignStudioFavorites :exec
UPDATE studio_favorites
   SET studio_id = $1
   WHERE studio_favorites.studio_id = $2
   AND user_id NOT IN (
    SELECT user_id
    FROM studio_favorites SF
    WHERE SF.studio_id = $1
  )
`

type ReassignStudioFavoritesParams struct {
	NewStudioID uuid.UUID `db:"new_studio_id" json:"new_studio_id"`
	OldStudioID uuid.UUID `db:"old_studio_id" json:"old_studio_id"`
}

func (q *Queries) ReassignStudioFavorites(ctx context.Context, arg ReassignStudioFavoritesParams) error {
	_, err := q.db.Exec(ctx, reassignStudioFavorites, arg.NewStudioID, arg.OldStudioID)
	return err
}

const searchStudios = `-- name: SearchStudios :many
SELECT
    studio_id,
    pdb.agg('{"value_count": {"field": "studio_id"}}') OVER () as total_count
FROM studio_search
WHERE studio_id @@@ paradedb.boolean(
    should => ARRAY[
        paradedb.boost(factor => 2, query => paradedb.match(field => 'name', value => $1::TEXT)),
        paradedb.match(field => 'network', value => $1::TEXT),
        paradedb.match(field => 'aliases', value => $1::TEXT)
    ]
)
ORDER BY pdb.score(studio_id) DESC
LIMIT $2
`

type SearchStudiosParams struct {
	Term  *string `db:"term" json:"term"`
	Limit int32   `db:"limit" json:"limit"`
}

type SearchStudiosRow struct {
	StudioID   uuid.UUID   `db:"studio_id" json:"studio_id"`
	TotalCount interface{} `db:"total_count" json:"total_count"`
}

func (q *Queries) SearchStudios(ctx context.Context, arg SearchStudiosParams) ([]SearchStudiosRow, error) {
	rows, err := q.db.Query(ctx, searchStudios, arg.Term, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchStudiosRow{}
	for rows.Next() {
		var i SearchStudiosRow
		if err := rows.Scan(&i.StudioID, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteStudio = `-- name: SoftDeleteStudio :one
UPDATE studios SET deleted = true, updated_at = NOW() WHERE id = $1
RETURNING id, name, parent_studio_id, created_at, updated_at, deleted
`

func (q *Queries) SoftDeleteStudio(ctx context.Context, id uuid.UUID) (Studio, error) {
	row := q.db.QueryRow(ctx, softDeleteStudio, id)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const updateStudio = `-- name: UpdateStudio :one
UPDATE studios 
SET name = $2, parent_studio_id = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, name, parent_studio_id, created_at, updated_at, deleted
`

type UpdateStudioParams struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	Name           string        `db:"name" json:"name"`
	ParentStudioID uuid.NullUUID `db:"parent_studio_id" json:"parent_studio_id"`
}

func (q *Queries) UpdateStudio(ctx context.Context, arg UpdateStudioParams) (Studio, error) {
	row := q.db.QueryRow(ctx, updateStudio, arg.ID, arg.Name, arg.ParentStudioID)
	var i Studio
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentStudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const updateStudioRedirects = `-- name: UpdateStudioRedirects :exec
UPDATE studio_redirects SET target_id = $1 WHERE target_id = $2
`

type UpdateStudioRedirectsParams struct {
	NewTargetID uuid.UUID `db:"new_target_id" json:"new_target_id"`
	OldTargetID uuid.UUID `db:"old_target_id" json:"old_target_id"`
}

func (q *Queries) UpdateStudioRedirects(ctx context.Context, arg UpdateStudioRedirectsParams) error {
	_, err := q.db.Exec(ctx, updateStudioRedirects, arg.NewTargetID, arg.OldTargetID)
	return err
}
