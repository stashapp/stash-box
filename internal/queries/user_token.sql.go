// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_token.sql

package queries

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
)

const createUserToken = `-- name: CreateUserToken :one

INSERT INTO user_tokens (id, data, type, created_at, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, data, type, created_at, expires_at
`

type CreateUserTokenParams struct {
	ID        uuid.UUID `db:"id" json:"id"`
	Data      []byte    `db:"data" json:"data"`
	Type      string    `db:"type" json:"type"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	ExpiresAt time.Time `db:"expires_at" json:"expires_at"`
}

// User token queries
func (q *Queries) CreateUserToken(ctx context.Context, arg CreateUserTokenParams) (UserToken, error) {
	row := q.db.QueryRow(ctx, createUserToken,
		arg.ID,
		arg.Data,
		arg.Type,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.Data,
		&i.Type,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteExpiredUserTokens = `-- name: DeleteExpiredUserTokens :exec
DELETE FROM user_tokens WHERE expires_at <= now()
`

func (q *Queries) DeleteExpiredUserTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredUserTokens)
	return err
}

const deleteUserToken = `-- name: DeleteUserToken :exec
DELETE FROM user_tokens WHERE id = $1
`

func (q *Queries) DeleteUserToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserToken, id)
	return err
}

const findUserToken = `-- name: FindUserToken :one
SELECT id, data, type, created_at, expires_at FROM user_tokens WHERE id = $1
`

func (q *Queries) FindUserToken(ctx context.Context, id uuid.UUID) (UserToken, error) {
	row := q.db.QueryRow(ctx, findUserToken, id)
	var i UserToken
	err := row.Scan(
		&i.ID,
		&i.Data,
		&i.Type,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const findUserTokensByEmail = `-- name: FindUserTokensByEmail :many
SELECT id, data, type, created_at, expires_at FROM user_tokens WHERE data->>'email' = $1::text
`

func (q *Queries) FindUserTokensByEmail(ctx context.Context, dollar_1 string) ([]UserToken, error) {
	rows, err := q.db.Query(ctx, findUserTokensByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserToken{}
	for rows.Next() {
		var i UserToken
		if err := rows.Scan(
			&i.ID,
			&i.Data,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserTokensByInviteKey = `-- name: FindUserTokensByInviteKey :many
SELECT id, data, type, created_at, expires_at FROM user_tokens WHERE (data->>'invite_key')::UUID = $1::UUID
`

func (q *Queries) FindUserTokensByInviteKey(ctx context.Context, dollar_1 uuid.UUID) ([]UserToken, error) {
	rows, err := q.db.Query(ctx, findUserTokensByInviteKey, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserToken{}
	for rows.Next() {
		var i UserToken
		if err := rows.Scan(
			&i.ID,
			&i.Data,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
