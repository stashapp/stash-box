// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scene.sql

package queries

import (
	"context"

	"github.com/gofrs/uuid"
)

const countScenesByPerformer = `-- name: CountScenesByPerformer :one
SELECT COUNT(*) FROM scene_performers WHERE performer_id = $1
`

func (q *Queries) CountScenesByPerformer(ctx context.Context, performerID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countScenesByPerformer, performerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createScene = `-- name: CreateScene :one

INSERT INTO scenes (id, title, details, date, production_date, studio_id, duration, director, code, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now())
RETURNING id, title, details, studio_id, created_at, updated_at, duration, director, deleted, code, date, production_date
`

type CreateSceneParams struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	Title          *string       `db:"title" json:"title"`
	Details        *string       `db:"details" json:"details"`
	Date           *string       `db:"date" json:"date"`
	ProductionDate *string       `db:"production_date" json:"production_date"`
	StudioID       uuid.NullUUID `db:"studio_id" json:"studio_id"`
	Duration       *int          `db:"duration" json:"duration"`
	Director       *string       `db:"director" json:"director"`
	Code           *string       `db:"code" json:"code"`
}

// Scene queries
func (q *Queries) CreateScene(ctx context.Context, arg CreateSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, createScene,
		arg.ID,
		arg.Title,
		arg.Details,
		arg.Date,
		arg.ProductionDate,
		arg.StudioID,
		arg.Duration,
		arg.Director,
		arg.Code,
	)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Details,
		&i.StudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
		&i.Director,
		&i.Deleted,
		&i.Code,
		&i.Date,
		&i.ProductionDate,
	)
	return i, err
}

type CreateSceneImagesParams struct {
	SceneID uuid.UUID `db:"scene_id" json:"scene_id"`
	ImageID uuid.UUID `db:"image_id" json:"image_id"`
}

type CreateScenePerformersParams struct {
	SceneID     uuid.UUID `db:"scene_id" json:"scene_id"`
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	As          *string   `db:"as" json:"as"`
}

const createSceneRedirect = `-- name: CreateSceneRedirect :exec

INSERT INTO scene_redirects (source_id, target_id) VALUES ($1, $2)
`

type CreateSceneRedirectParams struct {
	SourceID uuid.UUID `db:"source_id" json:"source_id"`
	TargetID uuid.UUID `db:"target_id" json:"target_id"`
}

// Scene redirects
func (q *Queries) CreateSceneRedirect(ctx context.Context, arg CreateSceneRedirectParams) error {
	_, err := q.db.Exec(ctx, createSceneRedirect, arg.SourceID, arg.TargetID)
	return err
}

type CreateSceneURLsParams struct {
	SceneID uuid.UUID `db:"scene_id" json:"scene_id"`
	Url     string    `db:"url" json:"url"`
	SiteID  uuid.UUID `db:"site_id" json:"site_id"`
}

const deleteScene = `-- name: DeleteScene :exec
DELETE FROM scenes WHERE id = $1
`

func (q *Queries) DeleteScene(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteScene, id)
	return err
}

const deleteSceneImages = `-- name: DeleteSceneImages :exec

DELETE FROM scene_images WHERE scene_id = $1
`

// Scene images
func (q *Queries) DeleteSceneImages(ctx context.Context, sceneID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSceneImages, sceneID)
	return err
}

const deleteScenePerformers = `-- name: DeleteScenePerformers :exec
DELETE FROM scene_performers WHERE scene_id = $1
`

func (q *Queries) DeleteScenePerformers(ctx context.Context, sceneID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteScenePerformers, sceneID)
	return err
}

const deleteSceneStudios = `-- name: DeleteSceneStudios :exec
UPDATE scenes SET studio_id = NULL WHERE studio_id = $1
`

func (q *Queries) DeleteSceneStudios(ctx context.Context, studioID uuid.NullUUID) error {
	_, err := q.db.Exec(ctx, deleteSceneStudios, studioID)
	return err
}

const deleteSceneURLs = `-- name: DeleteSceneURLs :exec
DELETE FROM scene_urls WHERE scene_id = $1
`

func (q *Queries) DeleteSceneURLs(ctx context.Context, sceneID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSceneURLs, sceneID)
	return err
}

const findExistingScenes = `-- name: FindExistingScenes :many
SELECT id, title, details, studio_id, created_at, updated_at, duration, director, deleted, code, date, production_date FROM scenes WHERE (
    ($1::text IS NOT NULL AND $2::uuid IS NOT NULL
     AND TRIM(LOWER(title)) = TRIM(LOWER($1))
     AND studio_id = $2)
    OR
    ($3::text[] IS NOT NULL AND array_length($3::text[], 1) > 0
     AND id IN (
        SELECT scene_id
        FROM scene_fingerprints SFP
        JOIN fingerprints FP ON SFP.fingerprint_id = FP.id
        WHERE FP.hash = ANY($3::text[])
        GROUP BY scene_id
    ))
)
AND deleted = FALSE
`

type FindExistingScenesParams struct {
	Title    *string       `db:"title" json:"title"`
	StudioID uuid.NullUUID `db:"studio_id" json:"studio_id"`
	Hashes   []string      `db:"hashes" json:"hashes"`
}

func (q *Queries) FindExistingScenes(ctx context.Context, arg FindExistingScenesParams) ([]Scene, error) {
	rows, err := q.db.Query(ctx, findExistingScenes, arg.Title, arg.StudioID, arg.Hashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scene{}
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Details,
			&i.StudioID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Duration,
			&i.Director,
			&i.Deleted,
			&i.Code,
			&i.Date,
			&i.ProductionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findScene = `-- name: FindScene :one
SELECT id, title, details, studio_id, created_at, updated_at, duration, director, deleted, code, date, production_date FROM scenes WHERE id = $1
`

func (q *Queries) FindScene(ctx context.Context, id uuid.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, findScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Details,
		&i.StudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
		&i.Director,
		&i.Deleted,
		&i.Code,
		&i.Date,
		&i.ProductionDate,
	)
	return i, err
}

const findSceneAppearancesByIds = `-- name: FindSceneAppearancesByIds :many
SELECT scene_id, performer_id, "as" FROM scene_performers WHERE scene_id = ANY($1::UUID[])
`

type FindSceneAppearancesByIdsRow struct {
	SceneID     uuid.UUID `db:"scene_id" json:"scene_id"`
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	As          *string   `db:"as" json:"as"`
}

// Get performer appearances for multiple scenes
func (q *Queries) FindSceneAppearancesByIds(ctx context.Context, sceneIds []uuid.UUID) ([]FindSceneAppearancesByIdsRow, error) {
	rows, err := q.db.Query(ctx, findSceneAppearancesByIds, sceneIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindSceneAppearancesByIdsRow{}
	for rows.Next() {
		var i FindSceneAppearancesByIdsRow
		if err := rows.Scan(&i.SceneID, &i.PerformerID, &i.As); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSceneByURL = `-- name: FindSceneByURL :many
SELECT s.id, s.title, s.details, s.studio_id, s.created_at, s.updated_at, s.duration, s.director, s.deleted, s.code, s.date, s.production_date
FROM scenes S
JOIN scene_urls SU ON SU.scene_id = S.id
WHERE LOWER(SU.url) = LOWER($1)
AND S.deleted = FALSE
LIMIT $2
`

type FindSceneByURLParams struct {
	Url   *string `db:"url" json:"url"`
	Limit int32   `db:"limit" json:"limit"`
}

func (q *Queries) FindSceneByURL(ctx context.Context, arg FindSceneByURLParams) ([]Scene, error) {
	rows, err := q.db.Query(ctx, findSceneByURL, arg.Url, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scene{}
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Details,
			&i.StudioID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Duration,
			&i.Director,
			&i.Deleted,
			&i.Code,
			&i.Date,
			&i.ProductionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSceneUrlsByIds = `-- name: FindSceneUrlsByIds :many
SELECT scene_id, url, site_id FROM scene_urls WHERE scene_id = ANY($1::UUID[])
`

// Get URLs for multiple scenes
func (q *Queries) FindSceneUrlsByIds(ctx context.Context, sceneIds []uuid.UUID) ([]SceneUrl, error) {
	rows, err := q.db.Query(ctx, findSceneUrlsByIds, sceneIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SceneUrl{}
	for rows.Next() {
		var i SceneUrl
		if err := rows.Scan(&i.SceneID, &i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findScenesByFullFingerprintsWithHash = `-- name: FindScenesByFullFingerprintsWithHash :many

SELECT scenes.id, scenes.title, scenes.details, scenes.studio_id, scenes.created_at, scenes.updated_at, scenes.duration, scenes.director, scenes.deleted, scenes.code, scenes.date, scenes.production_date, matches.hash FROM (
    SELECT SFP.scene_id AS id, FP.hash
    FROM UNNEST($1::BIGINT[]) phash
    JOIN fingerprints FP ON ('x' || FP.hash)::bit(64)::bigint <@ (phash::BIGINT, $2::INTEGER)
        AND FP.algorithm = 'PHASH'
    JOIN scene_fingerprints SFP ON SFP.fingerprint_id = FP.id
    WHERE $1::BIGINT[] IS NOT NULL AND array_length($1::BIGINT[], 1) > 0
    GROUP BY SFP.scene_id, FP.hash

    UNION

    SELECT SFP.scene_id AS id, FP.hash
    FROM scene_fingerprints SFP
    JOIN fingerprints FP ON SFP.fingerprint_id = FP.id
    WHERE FP.hash = ANY($3::TEXT[])
        AND $3::TEXT[] IS NOT NULL AND array_length($3::TEXT[], 1) > 0
    GROUP BY SFP.scene_id, FP.hash
) matches
JOIN scenes ON scenes.id = matches.id AND scenes.deleted = FALSE
`

type FindScenesByFullFingerprintsWithHashParams struct {
	Phashes  []int64  `db:"phashes" json:"phashes"`
	Distance int      `db:"distance" json:"distance"`
	Hashes   []string `db:"hashes" json:"hashes"`
}

type FindScenesByFullFingerprintsWithHashRow struct {
	Scene Scene  `db:"scene" json:"scene"`
	Hash  string `db:"hash" json:"hash"`
}

// Scene fingerprints (use fingerprint.sql for most fingerprint operations)
func (q *Queries) FindScenesByFullFingerprintsWithHash(ctx context.Context, arg FindScenesByFullFingerprintsWithHashParams) ([]FindScenesByFullFingerprintsWithHashRow, error) {
	rows, err := q.db.Query(ctx, findScenesByFullFingerprintsWithHash, arg.Phashes, arg.Distance, arg.Hashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindScenesByFullFingerprintsWithHashRow{}
	for rows.Next() {
		var i FindScenesByFullFingerprintsWithHashRow
		if err := rows.Scan(
			&i.Scene.ID,
			&i.Scene.Title,
			&i.Scene.Details,
			&i.Scene.StudioID,
			&i.Scene.CreatedAt,
			&i.Scene.UpdatedAt,
			&i.Scene.Duration,
			&i.Scene.Director,
			&i.Scene.Deleted,
			&i.Scene.Code,
			&i.Scene.Date,
			&i.Scene.ProductionDate,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScenePerformers = `-- name: GetScenePerformers :many
SELECT p.id, p.name, p.disambiguation, p.gender, p.ethnicity, p.country, p.eye_color, p.hair_color, p.height, p.cup_size, p.band_size, p.hip_size, p.waist_size, p.breast_type, p.career_start_year, p.career_end_year, p.created_at, p.updated_at, p.deleted, p.birthdate, p.deathdate, "as" FROM scene_performers SP JOIN performers P ON SP.performer_id = P.id WHERE scene_id = $1
`

type GetScenePerformersRow struct {
	Performer Performer `db:"performer" json:"performer"`
	As        *string   `db:"as" json:"as"`
}

func (q *Queries) GetScenePerformers(ctx context.Context, sceneID uuid.UUID) ([]GetScenePerformersRow, error) {
	rows, err := q.db.Query(ctx, getScenePerformers, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScenePerformersRow{}
	for rows.Next() {
		var i GetScenePerformersRow
		if err := rows.Scan(
			&i.Performer.ID,
			&i.Performer.Name,
			&i.Performer.Disambiguation,
			&i.Performer.Gender,
			&i.Performer.Ethnicity,
			&i.Performer.Country,
			&i.Performer.EyeColor,
			&i.Performer.HairColor,
			&i.Performer.Height,
			&i.Performer.CupSize,
			&i.Performer.BandSize,
			&i.Performer.HipSize,
			&i.Performer.WaistSize,
			&i.Performer.BreastType,
			&i.Performer.CareerStartYear,
			&i.Performer.CareerEndYear,
			&i.Performer.CreatedAt,
			&i.Performer.UpdatedAt,
			&i.Performer.Deleted,
			&i.Performer.Birthdate,
			&i.Performer.Deathdate,
			&i.As,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSceneURLs = `-- name: GetSceneURLs :many
SELECT url, site_id FROM scene_urls WHERE scene_id = $1
`

type GetSceneURLsRow struct {
	Url    string    `db:"url" json:"url"`
	SiteID uuid.UUID `db:"site_id" json:"site_id"`
}

func (q *Queries) GetSceneURLs(ctx context.Context, sceneID uuid.UUID) ([]GetSceneURLsRow, error) {
	rows, err := q.db.Query(ctx, getSceneURLs, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSceneURLsRow{}
	for rows.Next() {
		var i GetSceneURLsRow
		if err := rows.Scan(&i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScenes = `-- name: GetScenes :many
SELECT id, title, details, studio_id, created_at, updated_at, duration, director, deleted, code, date, production_date FROM scenes WHERE id = ANY($1::UUID[]) ORDER BY title
`

func (q *Queries) GetScenes(ctx context.Context, dollar_1 []uuid.UUID) ([]Scene, error) {
	rows, err := q.db.Query(ctx, getScenes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scene{}
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Details,
			&i.StudioID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Duration,
			&i.Director,
			&i.Deleted,
			&i.Code,
			&i.Date,
			&i.ProductionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchScenes = `-- name: SearchScenes :many
SELECT s.id, s.title, s.details, s.studio_id, s.created_at, s.updated_at, s.duration, s.director, s.deleted, s.code, s.date, s.production_date FROM scenes S
LEFT JOIN scene_search SS ON SS.scene_id = S.id
WHERE (
    to_tsvector('english', COALESCE(scene_date, '')) ||
    to_tsvector('english', studio_name) ||
    to_tsvector('english', COALESCE(performer_names, '')) ||
    to_tsvector('english', scene_title) ||
    to_tsvector('english', COALESCE(scene_code, ''))
) @@ websearch_to_tsquery('english', $1)
AND S.deleted = FALSE
LIMIT $2
`

type SearchScenesParams struct {
	Term  *string `db:"term" json:"term"`
	Limit int32   `db:"limit" json:"limit"`
}

func (q *Queries) SearchScenes(ctx context.Context, arg SearchScenesParams) ([]Scene, error) {
	rows, err := q.db.Query(ctx, searchScenes, arg.Term, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scene{}
	for rows.Next() {
		var i Scene
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Details,
			&i.StudioID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Duration,
			&i.Director,
			&i.Deleted,
			&i.Code,
			&i.Date,
			&i.ProductionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteScene = `-- name: SoftDeleteScene :one
UPDATE scenes SET deleted = true, updated_at = NOW() WHERE id = $1
RETURNING id, title, details, studio_id, created_at, updated_at, duration, director, deleted, code, date, production_date
`

func (q *Queries) SoftDeleteScene(ctx context.Context, id uuid.UUID) (Scene, error) {
	row := q.db.QueryRow(ctx, softDeleteScene, id)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Details,
		&i.StudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
		&i.Director,
		&i.Deleted,
		&i.Code,
		&i.Date,
		&i.ProductionDate,
	)
	return i, err
}

const updateScene = `-- name: UpdateScene :one
UPDATE scenes 
SET title = $2, details = $3, date = $4, production_date = $5, studio_id = $6, 
    duration = $7, director = $8, code = $9, updated_at = now()
WHERE id = $1
RETURNING id, title, details, studio_id, created_at, updated_at, duration, director, deleted, code, date, production_date
`

type UpdateSceneParams struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	Title          *string       `db:"title" json:"title"`
	Details        *string       `db:"details" json:"details"`
	Date           *string       `db:"date" json:"date"`
	ProductionDate *string       `db:"production_date" json:"production_date"`
	StudioID       uuid.NullUUID `db:"studio_id" json:"studio_id"`
	Duration       *int          `db:"duration" json:"duration"`
	Director       *string       `db:"director" json:"director"`
	Code           *string       `db:"code" json:"code"`
}

func (q *Queries) UpdateScene(ctx context.Context, arg UpdateSceneParams) (Scene, error) {
	row := q.db.QueryRow(ctx, updateScene,
		arg.ID,
		arg.Title,
		arg.Details,
		arg.Date,
		arg.ProductionDate,
		arg.StudioID,
		arg.Duration,
		arg.Director,
		arg.Code,
	)
	var i Scene
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Details,
		&i.StudioID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Duration,
		&i.Director,
		&i.Deleted,
		&i.Code,
		&i.Date,
		&i.ProductionDate,
	)
	return i, err
}

const updateSceneRedirects = `-- name: UpdateSceneRedirects :exec
UPDATE scene_redirects SET target_id = $1 WHERE target_id = $2
`

type UpdateSceneRedirectsParams struct {
	NewTargetID uuid.UUID `db:"new_target_id" json:"new_target_id"`
	OldTargetID uuid.UUID `db:"old_target_id" json:"old_target_id"`
}

func (q *Queries) UpdateSceneRedirects(ctx context.Context, arg UpdateSceneRedirectsParams) error {
	_, err := q.db.Exec(ctx, updateSceneRedirects, arg.NewTargetID, arg.OldTargetID)
	return err
}

const updateSceneStudios = `-- name: UpdateSceneStudios :exec
UPDATE scenes SET studio_id = $1 WHERE studio_id = $2
`

type UpdateSceneStudiosParams struct {
	TargetID uuid.NullUUID `db:"target_id" json:"target_id"`
	SourceID uuid.NullUUID `db:"source_id" json:"source_id"`
}

func (q *Queries) UpdateSceneStudios(ctx context.Context, arg UpdateSceneStudiosParams) error {
	_, err := q.db.Exec(ctx, updateSceneStudios, arg.TargetID, arg.SourceID)
	return err
}
