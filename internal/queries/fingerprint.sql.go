// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: fingerprint.sql

package queries

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
)

const createFingerprint = `-- name: CreateFingerprint :one

INSERT INTO fingerprints (hash, algorithm) VALUES ($1, $2)
ON CONFLICT (hash, algorithm) DO UPDATE SET hash = EXCLUDED.hash
RETURNING id, hash, algorithm
`

type CreateFingerprintParams struct {
	Hash      string `db:"hash" json:"hash"`
	Algorithm string `db:"algorithm" json:"algorithm"`
}

// Fingerprint queries (normalized schema)
func (q *Queries) CreateFingerprint(ctx context.Context, arg CreateFingerprintParams) (Fingerprint, error) {
	row := q.db.QueryRow(ctx, createFingerprint, arg.Hash, arg.Algorithm)
	var i Fingerprint
	err := row.Scan(&i.ID, &i.Hash, &i.Algorithm)
	return i, err
}

const createOrReplaceFingerprint = `-- name: CreateOrReplaceFingerprint :exec
INSERT INTO scene_fingerprints (fingerprint_id, scene_id, user_id, duration, vote) 
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT ON CONSTRAINT scene_fingerprints_scene_id_fingerprint_id_user_id_key
DO UPDATE SET 
    duration = EXCLUDED.duration,
    vote = EXCLUDED.vote
`

type CreateOrReplaceFingerprintParams struct {
	FingerprintID int       `db:"fingerprint_id" json:"fingerprint_id"`
	SceneID       uuid.UUID `db:"scene_id" json:"scene_id"`
	UserID        uuid.UUID `db:"user_id" json:"user_id"`
	Duration      int       `db:"duration" json:"duration"`
	Vote          int16     `db:"vote" json:"vote"`
}

func (q *Queries) CreateOrReplaceFingerprint(ctx context.Context, arg CreateOrReplaceFingerprintParams) error {
	_, err := q.db.Exec(ctx, createOrReplaceFingerprint,
		arg.FingerprintID,
		arg.SceneID,
		arg.UserID,
		arg.Duration,
		arg.Vote,
	)
	return err
}

type CreateSceneFingerprintsParams struct {
	FingerprintID int       `db:"fingerprint_id" json:"fingerprint_id"`
	SceneID       uuid.UUID `db:"scene_id" json:"scene_id"`
	UserID        uuid.UUID `db:"user_id" json:"user_id"`
	Duration      int       `db:"duration" json:"duration"`
}

const deleteSceneFingerprint = `-- name: DeleteSceneFingerprint :exec
DELETE FROM scene_fingerprints SFP
USING fingerprints FP
WHERE SFP.fingerprint_id = FP.id
AND FP.hash = $1
AND FP.algorithm = $2
AND user_id = $3
AND scene_id = $4
`

type DeleteSceneFingerprintParams struct {
	Hash      string    `db:"hash" json:"hash"`
	Algorithm string    `db:"algorithm" json:"algorithm"`
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
	SceneID   uuid.UUID `db:"scene_id" json:"scene_id"`
}

func (q *Queries) DeleteSceneFingerprint(ctx context.Context, arg DeleteSceneFingerprintParams) error {
	_, err := q.db.Exec(ctx, deleteSceneFingerprint,
		arg.Hash,
		arg.Algorithm,
		arg.UserID,
		arg.SceneID,
	)
	return err
}

const deleteSceneFingerprintsByScene = `-- name: DeleteSceneFingerprintsByScene :exec
DELETE FROM scene_fingerprints WHERE scene_id = $1
`

func (q *Queries) DeleteSceneFingerprintsByScene(ctx context.Context, sceneID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSceneFingerprintsByScene, sceneID)
	return err
}

const getAllFingerprints = `-- name: GetAllFingerprints :many
SELECT
    SFP.scene_id,
    FP.hash,
    FP.algorithm,
    mode() WITHIN GROUP (ORDER BY SFP.duration)::INTEGER as duration,
    COUNT(CASE WHEN SFP.vote = 1 THEN 1 END) as submissions,
    COUNT(CASE WHEN SFP.vote = -1 THEN 1 END) as reports,
    SUM(SFP.vote) as net_submissions,
    MIN(SFP.created_at)::TIMESTAMP as created_at,
    MAX(SFP.created_at)::TIMESTAMP as updated_at,
    bool_or(SFP.user_id = $1 AND SFP.vote = 1) as user_submitted,
    bool_or(SFP.user_id = $1 AND SFP.vote = -1) as user_reported
FROM scene_fingerprints SFP
JOIN fingerprints FP ON SFP.fingerprint_id = FP.id
WHERE SFP.scene_id = ANY($2::UUID[])
  AND ($3::uuid IS NULL OR SFP.user_id = $3)
GROUP BY SFP.scene_id, FP.algorithm, FP.hash
ORDER BY net_submissions DESC
`

type GetAllFingerprintsParams struct {
	CurrentUserID uuid.UUID     `db:"current_user_id" json:"current_user_id"`
	SceneIds      []uuid.UUID   `db:"scene_ids" json:"scene_ids"`
	FilterUserID  uuid.NullUUID `db:"filter_user_id" json:"filter_user_id"`
}

type GetAllFingerprintsRow struct {
	SceneID        uuid.UUID `db:"scene_id" json:"scene_id"`
	Hash           string    `db:"hash" json:"hash"`
	Algorithm      string    `db:"algorithm" json:"algorithm"`
	Duration       int       `db:"duration" json:"duration"`
	Submissions    int64     `db:"submissions" json:"submissions"`
	Reports        int64     `db:"reports" json:"reports"`
	NetSubmissions int64     `db:"net_submissions" json:"net_submissions"`
	CreatedAt      time.Time `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
	UserSubmitted  bool      `db:"user_submitted" json:"user_submitted"`
	UserReported   bool      `db:"user_reported" json:"user_reported"`
}

// Get all fingerprints for multiple scenes with aggregated vote data
// When onlySubmitted is true, pass the actual user ID, when false pass NULL
func (q *Queries) GetAllFingerprints(ctx context.Context, arg GetAllFingerprintsParams) ([]GetAllFingerprintsRow, error) {
	rows, err := q.db.Query(ctx, getAllFingerprints, arg.CurrentUserID, arg.SceneIds, arg.FilterUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllFingerprintsRow{}
	for rows.Next() {
		var i GetAllFingerprintsRow
		if err := rows.Scan(
			&i.SceneID,
			&i.Hash,
			&i.Algorithm,
			&i.Duration,
			&i.Submissions,
			&i.Reports,
			&i.NetSubmissions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserSubmitted,
			&i.UserReported,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSceneFingerprints = `-- name: GetAllSceneFingerprints :many
SELECT f.algorithm, f.hash, sf.duration, sf.created_at, sf.user_id
FROM scene_fingerprints sf
JOIN fingerprints f ON sf.fingerprint_id = f.id
WHERE sf.scene_id = $1
ORDER BY f.algorithm, sf.created_at
`

type GetAllSceneFingerprintsRow struct {
	Algorithm string    `db:"algorithm" json:"algorithm"`
	Hash      string    `db:"hash" json:"hash"`
	Duration  int       `db:"duration" json:"duration"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) GetAllSceneFingerprints(ctx context.Context, sceneID uuid.UUID) ([]GetAllSceneFingerprintsRow, error) {
	rows, err := q.db.Query(ctx, getAllSceneFingerprints, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllSceneFingerprintsRow{}
	for rows.Next() {
		var i GetAllSceneFingerprintsRow
		if err := rows.Scan(
			&i.Algorithm,
			&i.Hash,
			&i.Duration,
			&i.CreatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFingerprint = `-- name: GetFingerprint :one
SELECT id, hash, algorithm FROM fingerprints WHERE hash = $1 AND algorithm = $2
`

type GetFingerprintParams struct {
	Hash      string `db:"hash" json:"hash"`
	Algorithm string `db:"algorithm" json:"algorithm"`
}

func (q *Queries) GetFingerprint(ctx context.Context, arg GetFingerprintParams) (Fingerprint, error) {
	row := q.db.QueryRow(ctx, getFingerprint, arg.Hash, arg.Algorithm)
	var i Fingerprint
	err := row.Scan(&i.ID, &i.Hash, &i.Algorithm)
	return i, err
}

const submittedHashExists = `-- name: SubmittedHashExists :one
SELECT EXISTS(
		SELECT
			1
		FROM scene_fingerprints f
		JOIN fingerprints fp ON f.fingerprint_id = fp.id
		WHERE f.scene_id = $1 AND fp.hash = $2 AND fp.algorithm = $3 AND f.vote = 1
) AS exists
`

type SubmittedHashExistsParams struct {
	SceneID   uuid.UUID `db:"scene_id" json:"scene_id"`
	Hash      string    `db:"hash" json:"hash"`
	Algorithm string    `db:"algorithm" json:"algorithm"`
}

func (q *Queries) SubmittedHashExists(ctx context.Context, arg SubmittedHashExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, submittedHashExists, arg.SceneID, arg.Hash, arg.Algorithm)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
