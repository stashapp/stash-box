// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: performer.sql

package queries

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/stashapp/stash-box/internal/models"
)

const clearScenePerformerAlias = `-- name: ClearScenePerformerAlias :exec
UPDATE scene_performers
SET "as" = NULL
WHERE performer_id = $1
AND "as" = $2
`

type ClearScenePerformerAliasParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	As          *string   `db:"as" json:"as"`
}

func (q *Queries) ClearScenePerformerAlias(ctx context.Context, arg ClearScenePerformerAliasParams) error {
	_, err := q.db.Exec(ctx, clearScenePerformerAlias, arg.PerformerID, arg.As)
	return err
}

const createPerformer = `-- name: CreatePerformer :one

INSERT INTO performers (
    id, name, disambiguation, gender, birthdate, 
    ethnicity, country, eye_color, hair_color, height, cup_size, 
    band_size, hip_size, waist_size, breast_type, career_start_year, 
    career_end_year, deathdate, created_at, updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 
    $13, $14, $15, $16, $17, $18, now(), now()
)
RETURNING id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate
`

type CreatePerformerParams struct {
	ID              uuid.UUID              `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	Disambiguation  *string                `db:"disambiguation" json:"disambiguation"`
	Gender          *models.GenderEnum     `db:"gender" json:"gender"`
	Birthdate       *string                `db:"birthdate" json:"birthdate"`
	Ethnicity       *models.EthnicityEnum  `db:"ethnicity" json:"ethnicity"`
	Country         *string                `db:"country" json:"country"`
	EyeColor        *models.EyeColorEnum   `db:"eye_color" json:"eye_color"`
	HairColor       *models.HairColorEnum  `db:"hair_color" json:"hair_color"`
	Height          *int                   `db:"height" json:"height"`
	CupSize         *string                `db:"cup_size" json:"cup_size"`
	BandSize        *int                   `db:"band_size" json:"band_size"`
	HipSize         *int                   `db:"hip_size" json:"hip_size"`
	WaistSize       *int                   `db:"waist_size" json:"waist_size"`
	BreastType      *models.BreastTypeEnum `db:"breast_type" json:"breast_type"`
	CareerStartYear *int                   `db:"career_start_year" json:"career_start_year"`
	CareerEndYear   *int                   `db:"career_end_year" json:"career_end_year"`
	Deathdate       *string                `db:"deathdate" json:"deathdate"`
}

// Performer queries
func (q *Queries) CreatePerformer(ctx context.Context, arg CreatePerformerParams) (Performer, error) {
	row := q.db.QueryRow(ctx, createPerformer,
		arg.ID,
		arg.Name,
		arg.Disambiguation,
		arg.Gender,
		arg.Birthdate,
		arg.Ethnicity,
		arg.Country,
		arg.EyeColor,
		arg.HairColor,
		arg.Height,
		arg.CupSize,
		arg.BandSize,
		arg.HipSize,
		arg.WaistSize,
		arg.BreastType,
		arg.CareerStartYear,
		arg.CareerEndYear,
		arg.Deathdate,
	)
	var i Performer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Disambiguation,
		&i.Gender,
		&i.Ethnicity,
		&i.Country,
		&i.EyeColor,
		&i.HairColor,
		&i.Height,
		&i.CupSize,
		&i.BandSize,
		&i.HipSize,
		&i.WaistSize,
		&i.BreastType,
		&i.CareerStartYear,
		&i.CareerEndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.Birthdate,
		&i.Deathdate,
	)
	return i, err
}

type CreatePerformerAliasesParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	Alias       string    `db:"alias" json:"alias"`
}

const createPerformerFavorite = `-- name: CreatePerformerFavorite :exec
INSERT INTO performer_favorites (performer_id, user_id, created_at) VALUES ($1, $2, now())
`

type CreatePerformerFavoriteParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	UserID      uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) CreatePerformerFavorite(ctx context.Context, arg CreatePerformerFavoriteParams) error {
	_, err := q.db.Exec(ctx, createPerformerFavorite, arg.PerformerID, arg.UserID)
	return err
}

type CreatePerformerImagesParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	ImageID     uuid.UUID `db:"image_id" json:"image_id"`
}

type CreatePerformerPiercingsParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	Location    *string   `db:"location" json:"location"`
	Description *string   `db:"description" json:"description"`
}

const createPerformerRedirect = `-- name: CreatePerformerRedirect :exec

INSERT INTO performer_redirects (source_id, target_id) VALUES ($1, $2)
`

type CreatePerformerRedirectParams struct {
	SourceID uuid.UUID `db:"source_id" json:"source_id"`
	TargetID uuid.UUID `db:"target_id" json:"target_id"`
}

// Performer redirects
func (q *Queries) CreatePerformerRedirect(ctx context.Context, arg CreatePerformerRedirectParams) error {
	_, err := q.db.Exec(ctx, createPerformerRedirect, arg.SourceID, arg.TargetID)
	return err
}

type CreatePerformerTattoosParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	Location    *string   `db:"location" json:"location"`
	Description *string   `db:"description" json:"description"`
}

type CreatePerformerURLsParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	Url         string    `db:"url" json:"url"`
	SiteID      uuid.UUID `db:"site_id" json:"site_id"`
}

const deletePerformer = `-- name: DeletePerformer :exec
DELETE FROM performers WHERE id = $1
`

func (q *Queries) DeletePerformer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformer, id)
	return err
}

const deletePerformerAliases = `-- name: DeletePerformerAliases :exec

DELETE FROM performer_aliases WHERE performer_id = $1
`

// Performer aliases
func (q *Queries) DeletePerformerAliases(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerAliases, performerID)
	return err
}

const deletePerformerFavorite = `-- name: DeletePerformerFavorite :exec
DELETE FROM performer_favorites WHERE performer_id = $1 AND user_id = $2
`

type DeletePerformerFavoriteParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	UserID      uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeletePerformerFavorite(ctx context.Context, arg DeletePerformerFavoriteParams) error {
	_, err := q.db.Exec(ctx, deletePerformerFavorite, arg.PerformerID, arg.UserID)
	return err
}

const deletePerformerFavorites = `-- name: DeletePerformerFavorites :exec

DELETE FROM performer_favorites WHERE performer_id = $1
`

// Performer favorites
func (q *Queries) DeletePerformerFavorites(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerFavorites, performerID)
	return err
}

const deletePerformerImages = `-- name: DeletePerformerImages :exec
DELETE FROM performer_images WHERE performer_id = $1
`

func (q *Queries) DeletePerformerImages(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerImages, performerID)
	return err
}

const deletePerformerPiercings = `-- name: DeletePerformerPiercings :exec

DELETE FROM performer_piercings WHERE performer_id = $1
`

// Performer piercings
func (q *Queries) DeletePerformerPiercings(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerPiercings, performerID)
	return err
}

const deletePerformerScenes = `-- name: DeletePerformerScenes :exec
DELETE FROM scene_performers WHERE performer_id = $1
`

func (q *Queries) DeletePerformerScenes(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerScenes, performerID)
	return err
}

const deletePerformerTattoos = `-- name: DeletePerformerTattoos :exec

DELETE FROM performer_tattoos WHERE performer_id = $1
`

// Performer tattoos
func (q *Queries) DeletePerformerTattoos(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerTattoos, performerID)
	return err
}

const deletePerformerURLs = `-- name: DeletePerformerURLs :exec

DELETE FROM performer_urls WHERE performer_id = $1
`

// Performer URLs
func (q *Queries) DeletePerformerURLs(ctx context.Context, performerID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePerformerURLs, performerID)
	return err
}

const findExistingPerformers = `-- name: FindExistingPerformers :many
SELECT id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate FROM performers
WHERE (
    ($1::text IS NOT NULL AND TRIM(LOWER(name)) = TRIM(LOWER($1)) AND
     CASE
       WHEN $2::text IS NOT NULL
       THEN TRIM(LOWER(disambiguation)) = TRIM(LOWER($2))
       ELSE (disambiguation IS NULL OR disambiguation = '')
     END)
    OR
    ($3::text[] IS NOT NULL AND
     id IN (
       SELECT performer_id
       FROM performer_urls
       WHERE url = ANY($3)
       GROUP BY performer_id
     ))
)
`

type FindExistingPerformersParams struct {
	Name           *string  `db:"name" json:"name"`
	Disambiguation *string  `db:"disambiguation" json:"disambiguation"`
	Urls           []string `db:"urls" json:"urls"`
}

func (q *Queries) FindExistingPerformers(ctx context.Context, arg FindExistingPerformersParams) ([]Performer, error) {
	rows, err := q.db.Query(ctx, findExistingPerformers, arg.Name, arg.Disambiguation, arg.Urls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Performer{}
	for rows.Next() {
		var i Performer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Disambiguation,
			&i.Gender,
			&i.Ethnicity,
			&i.Country,
			&i.EyeColor,
			&i.HairColor,
			&i.Height,
			&i.CupSize,
			&i.BandSize,
			&i.HipSize,
			&i.WaistSize,
			&i.BreastType,
			&i.CareerStartYear,
			&i.CareerEndYear,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.Birthdate,
			&i.Deathdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMergeIDsByPerformerIds = `-- name: FindMergeIDsByPerformerIds :many
SELECT source_id as performer_id, target_id as merge_id FROM performer_redirects WHERE source_id = ANY($1::UUID[])
`

type FindMergeIDsByPerformerIdsRow struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	MergeID     uuid.UUID `db:"merge_id" json:"merge_id"`
}

// Find merge target IDs for performers (for merges where these are sources)
func (q *Queries) FindMergeIDsByPerformerIds(ctx context.Context, performerIds []uuid.UUID) ([]FindMergeIDsByPerformerIdsRow, error) {
	rows, err := q.db.Query(ctx, findMergeIDsByPerformerIds, performerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindMergeIDsByPerformerIdsRow{}
	for rows.Next() {
		var i FindMergeIDsByPerformerIdsRow
		if err := rows.Scan(&i.PerformerID, &i.MergeID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMergeIDsBySourcePerformerIds = `-- name: FindMergeIDsBySourcePerformerIds :many
SELECT target_id as performer_id, source_id as merge_id FROM performer_redirects WHERE target_id = ANY($1::UUID[])
`

type FindMergeIDsBySourcePerformerIdsRow struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	MergeID     uuid.UUID `db:"merge_id" json:"merge_id"`
}

// Find merge source IDs for performers (for merges where these are targets)
func (q *Queries) FindMergeIDsBySourcePerformerIds(ctx context.Context, performerIds []uuid.UUID) ([]FindMergeIDsBySourcePerformerIdsRow, error) {
	rows, err := q.db.Query(ctx, findMergeIDsBySourcePerformerIds, performerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindMergeIDsBySourcePerformerIdsRow{}
	for rows.Next() {
		var i FindMergeIDsBySourcePerformerIdsRow
		if err := rows.Scan(&i.PerformerID, &i.MergeID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformer = `-- name: FindPerformer :one
SELECT id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate FROM performers WHERE id = $1
`

func (q *Queries) FindPerformer(ctx context.Context, id uuid.UUID) (Performer, error) {
	row := q.db.QueryRow(ctx, findPerformer, id)
	var i Performer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Disambiguation,
		&i.Gender,
		&i.Ethnicity,
		&i.Country,
		&i.EyeColor,
		&i.HairColor,
		&i.Height,
		&i.CupSize,
		&i.BandSize,
		&i.HipSize,
		&i.WaistSize,
		&i.BreastType,
		&i.CareerStartYear,
		&i.CareerEndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.Birthdate,
		&i.Deathdate,
	)
	return i, err
}

const findPerformerAliasesByIds = `-- name: FindPerformerAliasesByIds :many
SELECT performer_id, alias FROM performer_aliases WHERE performer_id = ANY($1::UUID[])
`

// Get aliases for multiple performers
func (q *Queries) FindPerformerAliasesByIds(ctx context.Context, performerIds []uuid.UUID) ([]PerformerAlias, error) {
	rows, err := q.db.Query(ctx, findPerformerAliasesByIds, performerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformerAlias{}
	for rows.Next() {
		var i PerformerAlias
		if err := rows.Scan(&i.PerformerID, &i.Alias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformerByAlias = `-- name: FindPerformerByAlias :one
SELECT p.id, p.name, p.disambiguation, p.gender, p.ethnicity, p.country, p.eye_color, p.hair_color, p.height, p.cup_size, p.band_size, p.hip_size, p.waist_size, p.breast_type, p.career_start_year, p.career_end_year, p.created_at, p.updated_at, p.deleted, p.birthdate, p.deathdate FROM performers p
JOIN performer_aliases pa ON p.id = pa.performer_id
WHERE UPPER(pa.alias) = UPPER($1) AND p.deleted = false
`

func (q *Queries) FindPerformerByAlias(ctx context.Context, upper interface{}) (Performer, error) {
	row := q.db.QueryRow(ctx, findPerformerByAlias, upper)
	var i Performer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Disambiguation,
		&i.Gender,
		&i.Ethnicity,
		&i.Country,
		&i.EyeColor,
		&i.HairColor,
		&i.Height,
		&i.CupSize,
		&i.BandSize,
		&i.HipSize,
		&i.WaistSize,
		&i.BreastType,
		&i.CareerStartYear,
		&i.CareerEndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.Birthdate,
		&i.Deathdate,
	)
	return i, err
}

const findPerformerByName = `-- name: FindPerformerByName :one
SELECT id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate FROM performers WHERE UPPER(name) = UPPER($1) AND deleted = false
`

func (q *Queries) FindPerformerByName(ctx context.Context, upper interface{}) (Performer, error) {
	row := q.db.QueryRow(ctx, findPerformerByName, upper)
	var i Performer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Disambiguation,
		&i.Gender,
		&i.Ethnicity,
		&i.Country,
		&i.EyeColor,
		&i.HairColor,
		&i.Height,
		&i.CupSize,
		&i.BandSize,
		&i.HipSize,
		&i.WaistSize,
		&i.BreastType,
		&i.CareerStartYear,
		&i.CareerEndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.Birthdate,
		&i.Deathdate,
	)
	return i, err
}

const findPerformerFavoritesByIds = `-- name: FindPerformerFavoritesByIds :many
SELECT performer_id, (performer_id IS NOT NULL)::BOOLEAN as is_favorite
FROM performer_favorites
WHERE performer_id = ANY($1::UUID[]) AND user_id = $2
`

type FindPerformerFavoritesByIdsParams struct {
	PerformerIds []uuid.UUID `db:"performer_ids" json:"performer_ids"`
	UserID       uuid.UUID   `db:"user_id" json:"user_id"`
}

type FindPerformerFavoritesByIdsRow struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	IsFavorite  bool      `db:"is_favorite" json:"is_favorite"`
}

// Check favorite status for multiple performers for a specific user
func (q *Queries) FindPerformerFavoritesByIds(ctx context.Context, arg FindPerformerFavoritesByIdsParams) ([]FindPerformerFavoritesByIdsRow, error) {
	rows, err := q.db.Query(ctx, findPerformerFavoritesByIds, arg.PerformerIds, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPerformerFavoritesByIdsRow{}
	for rows.Next() {
		var i FindPerformerFavoritesByIdsRow
		if err := rows.Scan(&i.PerformerID, &i.IsFavorite); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformerPiercingsByIds = `-- name: FindPerformerPiercingsByIds :many
SELECT performer_id, location, description FROM performer_piercings WHERE performer_id = ANY($1::UUID[])
`

// Get piercings for multiple performers
func (q *Queries) FindPerformerPiercingsByIds(ctx context.Context, performerIds []uuid.UUID) ([]PerformerPiercing, error) {
	rows, err := q.db.Query(ctx, findPerformerPiercingsByIds, performerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformerPiercing{}
	for rows.Next() {
		var i PerformerPiercing
		if err := rows.Scan(&i.PerformerID, &i.Location, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformerTattoosByIds = `-- name: FindPerformerTattoosByIds :many
SELECT performer_id, location, description FROM performer_tattoos WHERE performer_id = ANY($1::UUID[])
`

// Get tattoos for multiple performers
func (q *Queries) FindPerformerTattoosByIds(ctx context.Context, performerIds []uuid.UUID) ([]PerformerTattoo, error) {
	rows, err := q.db.Query(ctx, findPerformerTattoosByIds, performerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformerTattoo{}
	for rows.Next() {
		var i PerformerTattoo
		if err := rows.Scan(&i.PerformerID, &i.Location, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformerUrlsByIds = `-- name: FindPerformerUrlsByIds :many
SELECT performer_id, url, site_id FROM performer_urls WHERE performer_id = ANY($1::UUID[])
`

// Get URLs for multiple performers
func (q *Queries) FindPerformerUrlsByIds(ctx context.Context, performerIds []uuid.UUID) ([]PerformerUrl, error) {
	rows, err := q.db.Query(ctx, findPerformerUrlsByIds, performerIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PerformerUrl{}
	for rows.Next() {
		var i PerformerUrl
		if err := rows.Scan(&i.PerformerID, &i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformerWithRedirect = `-- name: FindPerformerWithRedirect :many
SELECT p.id, p.name, p.disambiguation, p.gender, p.ethnicity, p.country, p.eye_color, p.hair_color, p.height, p.cup_size, p.band_size, p.hip_size, p.waist_size, p.breast_type, p.career_start_year, p.career_end_year, p.created_at, p.updated_at, p.deleted, p.birthdate, p.deathdate FROM performers P
WHERE P.id = $1 AND P.deleted = FALSE
UNION
SELECT t.id, t.name, t.disambiguation, t.gender, t.ethnicity, t.country, t.eye_color, t.hair_color, t.height, t.cup_size, t.band_size, t.hip_size, t.waist_size, t.breast_type, t.career_start_year, t.career_end_year, t.created_at, t.updated_at, t.deleted, t.birthdate, t.deathdate FROM performer_redirects R
JOIN performers T ON T.id = R.target_id
WHERE R.source_id = $1 AND T.deleted = FALSE
`

func (q *Queries) FindPerformerWithRedirect(ctx context.Context, id uuid.UUID) ([]Performer, error) {
	rows, err := q.db.Query(ctx, findPerformerWithRedirect, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Performer{}
	for rows.Next() {
		var i Performer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Disambiguation,
			&i.Gender,
			&i.Ethnicity,
			&i.Country,
			&i.EyeColor,
			&i.HairColor,
			&i.Height,
			&i.CupSize,
			&i.BandSize,
			&i.HipSize,
			&i.WaistSize,
			&i.BreastType,
			&i.CareerStartYear,
			&i.CareerEndYear,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.Birthdate,
			&i.Deathdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformersByIds = `-- name: FindPerformersByIds :many
SELECT id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate FROM performers WHERE id = ANY($1::UUID[])
`

func (q *Queries) FindPerformersByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]Performer, error) {
	rows, err := q.db.Query(ctx, findPerformersByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Performer{}
	for rows.Next() {
		var i Performer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Disambiguation,
			&i.Gender,
			&i.Ethnicity,
			&i.Country,
			&i.EyeColor,
			&i.HairColor,
			&i.Height,
			&i.CupSize,
			&i.BandSize,
			&i.HipSize,
			&i.WaistSize,
			&i.BreastType,
			&i.CareerStartYear,
			&i.CareerEndYear,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.Birthdate,
			&i.Deathdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPerformersByURL = `-- name: FindPerformersByURL :many
SELECT p.id, p.name, p.disambiguation, p.gender, p.ethnicity, p.country, p.eye_color, p.hair_color, p.height, p.cup_size, p.band_size, p.hip_size, p.waist_size, p.breast_type, p.career_start_year, p.career_end_year, p.created_at, p.updated_at, p.deleted, p.birthdate, p.deathdate
FROM performers P
JOIN performer_urls PU ON PU.performer_id = P.id
WHERE LOWER(PU.url) = LOWER($1)
LIMIT $2
`

type FindPerformersByURLParams struct {
	Url   *string `db:"url" json:"url"`
	Limit int32   `db:"limit" json:"limit"`
}

func (q *Queries) FindPerformersByURL(ctx context.Context, arg FindPerformersByURLParams) ([]Performer, error) {
	rows, err := q.db.Query(ctx, findPerformersByURL, arg.Url, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Performer{}
	for rows.Next() {
		var i Performer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Disambiguation,
			&i.Gender,
			&i.Ethnicity,
			&i.Country,
			&i.EyeColor,
			&i.HairColor,
			&i.Height,
			&i.CupSize,
			&i.BandSize,
			&i.HipSize,
			&i.WaistSize,
			&i.BreastType,
			&i.CareerStartYear,
			&i.CareerEndYear,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.Birthdate,
			&i.Deathdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformerAliases = `-- name: GetPerformerAliases :many
SELECT alias FROM performer_aliases WHERE performer_id = $1
`

func (q *Queries) GetPerformerAliases(ctx context.Context, performerID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getPerformerAliases, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var alias string
		if err := rows.Scan(&alias); err != nil {
			return nil, err
		}
		items = append(items, alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformerImages = `-- name: GetPerformerImages :many

SELECT images.id, images.url, images.width, images.height, images.checksum FROM images
JOIN performer_images ON performer_images.image_id = images.id
WHERE performer_images.performer_id = $1
`

// Performer images
func (q *Queries) GetPerformerImages(ctx context.Context, performerID uuid.UUID) ([]Image, error) {
	rows, err := q.db.Query(ctx, getPerformerImages, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Width,
			&i.Height,
			&i.Checksum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformerPiercings = `-- name: GetPerformerPiercings :many
SELECT location, description FROM performer_piercings WHERE performer_id = $1
`

type GetPerformerPiercingsRow struct {
	Location    *string `db:"location" json:"location"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) GetPerformerPiercings(ctx context.Context, performerID uuid.UUID) ([]GetPerformerPiercingsRow, error) {
	rows, err := q.db.Query(ctx, getPerformerPiercings, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPerformerPiercingsRow{}
	for rows.Next() {
		var i GetPerformerPiercingsRow
		if err := rows.Scan(&i.Location, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformerTattoos = `-- name: GetPerformerTattoos :many
SELECT location, description FROM performer_tattoos WHERE performer_id = $1
`

type GetPerformerTattoosRow struct {
	Location    *string `db:"location" json:"location"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) GetPerformerTattoos(ctx context.Context, performerID uuid.UUID) ([]GetPerformerTattoosRow, error) {
	rows, err := q.db.Query(ctx, getPerformerTattoos, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPerformerTattoosRow{}
	for rows.Next() {
		var i GetPerformerTattoosRow
		if err := rows.Scan(&i.Location, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPerformerURLs = `-- name: GetPerformerURLs :many
SELECT url, site_id FROM performer_urls WHERE performer_id = $1
`

type GetPerformerURLsRow struct {
	Url    string    `db:"url" json:"url"`
	SiteID uuid.UUID `db:"site_id" json:"site_id"`
}

func (q *Queries) GetPerformerURLs(ctx context.Context, performerID uuid.UUID) ([]GetPerformerURLsRow, error) {
	rows, err := q.db.Query(ctx, getPerformerURLs, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPerformerURLsRow{}
	for rows.Next() {
		var i GetPerformerURLsRow
		if err := rows.Scan(&i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reassignPerformerAliases = `-- name: ReassignPerformerAliases :exec
UPDATE scene_performers
SET performer_id = $1
WHERE scene_performers.performer_id = $2
AND scene_id NOT IN (SELECT scene_id from scene_performers sp WHERE sp.performer_id = $1)
`

type ReassignPerformerAliasesParams struct {
	NewPerformerID uuid.UUID `db:"new_performer_id" json:"new_performer_id"`
	OldPerformerID uuid.UUID `db:"old_performer_id" json:"old_performer_id"`
}

func (q *Queries) ReassignPerformerAliases(ctx context.Context, arg ReassignPerformerAliasesParams) error {
	_, err := q.db.Exec(ctx, reassignPerformerAliases, arg.NewPerformerID, arg.OldPerformerID)
	return err
}

const reassignPerformerFavorites = `-- name: ReassignPerformerFavorites :exec
UPDATE performer_favorites
   SET performer_id = $1
   WHERE performer_favorites.performer_id = $2
   AND user_id NOT IN (
    SELECT user_id
    FROM performer_favorites PF
    WHERE PF.performer_id = $1
  )
`

type ReassignPerformerFavoritesParams struct {
	NewPerformerID uuid.UUID `db:"new_performer_id" json:"new_performer_id"`
	OldPerformerID uuid.UUID `db:"old_performer_id" json:"old_performer_id"`
}

func (q *Queries) ReassignPerformerFavorites(ctx context.Context, arg ReassignPerformerFavoritesParams) error {
	_, err := q.db.Exec(ctx, reassignPerformerFavorites, arg.NewPerformerID, arg.OldPerformerID)
	return err
}

const searchPerformersWithFacets = `-- name: SearchPerformersWithFacets :many
SELECT
    performer_id,
    pdb.agg('{"terms": {"field": "gender"}}') OVER () as gender_facets,
    pdb.agg('{"value_count": {"field": "performer_id"}}') OVER () as total_count
FROM performer_search
WHERE performer_id @@@ paradedb.disjunction_max(disjuncts => ARRAY[
    paradedb.boolean(
        should => ARRAY[
            paradedb.boost(factor => 1.5, query => paradedb.match(field => 'name', value => $1::TEXT)),
            paradedb.match(field => 'disambiguation', value => $1::TEXT)
        ]
    ),
    paradedb.match(field => 'aliases', value => $1::TEXT)
])
AND ($2::TEXT IS NULL OR gender = $2::TEXT)
ORDER BY pdb.score(performer_id) DESC
LIMIT $4 OFFSET $3
`

type SearchPerformersWithFacetsParams struct {
	Term         *string `db:"term" json:"term"`
	FilterGender *string `db:"filter_gender" json:"filter_gender"`
	Offset       int32   `db:"offset" json:"offset"`
	Limit        int32   `db:"limit" json:"limit"`
}

type SearchPerformersWithFacetsRow struct {
	PerformerID  uuid.UUID   `db:"performer_id" json:"performer_id"`
	GenderFacets interface{} `db:"gender_facets" json:"gender_facets"`
	TotalCount   interface{} `db:"total_count" json:"total_count"`
}

func (q *Queries) SearchPerformersWithFacets(ctx context.Context, arg SearchPerformersWithFacetsParams) ([]SearchPerformersWithFacetsRow, error) {
	rows, err := q.db.Query(ctx, searchPerformersWithFacets,
		arg.Term,
		arg.FilterGender,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPerformersWithFacetsRow{}
	for rows.Next() {
		var i SearchPerformersWithFacetsRow
		if err := rows.Scan(&i.PerformerID, &i.GenderFacets, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setScenePerformerAlias = `-- name: SetScenePerformerAlias :exec
UPDATE scene_performers
SET "as" = $2
WHERE performer_id = $1
AND "as" IS NULL
`

type SetScenePerformerAliasParams struct {
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
	As          *string   `db:"as" json:"as"`
}

func (q *Queries) SetScenePerformerAlias(ctx context.Context, arg SetScenePerformerAliasParams) error {
	_, err := q.db.Exec(ctx, setScenePerformerAlias, arg.PerformerID, arg.As)
	return err
}

const softDeletePerformer = `-- name: SoftDeletePerformer :one
UPDATE performers SET deleted = true, updated_at = NOW() WHERE id = $1
RETURNING id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate
`

func (q *Queries) SoftDeletePerformer(ctx context.Context, id uuid.UUID) (Performer, error) {
	row := q.db.QueryRow(ctx, softDeletePerformer, id)
	var i Performer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Disambiguation,
		&i.Gender,
		&i.Ethnicity,
		&i.Country,
		&i.EyeColor,
		&i.HairColor,
		&i.Height,
		&i.CupSize,
		&i.BandSize,
		&i.HipSize,
		&i.WaistSize,
		&i.BreastType,
		&i.CareerStartYear,
		&i.CareerEndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.Birthdate,
		&i.Deathdate,
	)
	return i, err
}

const updatePerformer = `-- name: UpdatePerformer :one
UPDATE performers 
SET name = $2, disambiguation = $3, gender = $4, birthdate = $5, 
    ethnicity = $6, country = $7, eye_color = $8, hair_color = $9, 
    height = $10, cup_size = $11, band_size = $12, hip_size = $13, 
    waist_size = $14, breast_type = $15, career_start_year = $16, 
    career_end_year = $17, deathdate = $18, updated_at = now()
WHERE id = $1
RETURNING id, name, disambiguation, gender, ethnicity, country, eye_color, hair_color, height, cup_size, band_size, hip_size, waist_size, breast_type, career_start_year, career_end_year, created_at, updated_at, deleted, birthdate, deathdate
`

type UpdatePerformerParams struct {
	ID              uuid.UUID              `db:"id" json:"id"`
	Name            string                 `db:"name" json:"name"`
	Disambiguation  *string                `db:"disambiguation" json:"disambiguation"`
	Gender          *models.GenderEnum     `db:"gender" json:"gender"`
	Birthdate       *string                `db:"birthdate" json:"birthdate"`
	Ethnicity       *models.EthnicityEnum  `db:"ethnicity" json:"ethnicity"`
	Country         *string                `db:"country" json:"country"`
	EyeColor        *models.EyeColorEnum   `db:"eye_color" json:"eye_color"`
	HairColor       *models.HairColorEnum  `db:"hair_color" json:"hair_color"`
	Height          *int                   `db:"height" json:"height"`
	CupSize         *string                `db:"cup_size" json:"cup_size"`
	BandSize        *int                   `db:"band_size" json:"band_size"`
	HipSize         *int                   `db:"hip_size" json:"hip_size"`
	WaistSize       *int                   `db:"waist_size" json:"waist_size"`
	BreastType      *models.BreastTypeEnum `db:"breast_type" json:"breast_type"`
	CareerStartYear *int                   `db:"career_start_year" json:"career_start_year"`
	CareerEndYear   *int                   `db:"career_end_year" json:"career_end_year"`
	Deathdate       *string                `db:"deathdate" json:"deathdate"`
}

func (q *Queries) UpdatePerformer(ctx context.Context, arg UpdatePerformerParams) (Performer, error) {
	row := q.db.QueryRow(ctx, updatePerformer,
		arg.ID,
		arg.Name,
		arg.Disambiguation,
		arg.Gender,
		arg.Birthdate,
		arg.Ethnicity,
		arg.Country,
		arg.EyeColor,
		arg.HairColor,
		arg.Height,
		arg.CupSize,
		arg.BandSize,
		arg.HipSize,
		arg.WaistSize,
		arg.BreastType,
		arg.CareerStartYear,
		arg.CareerEndYear,
		arg.Deathdate,
	)
	var i Performer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Disambiguation,
		&i.Gender,
		&i.Ethnicity,
		&i.Country,
		&i.EyeColor,
		&i.HairColor,
		&i.Height,
		&i.CupSize,
		&i.BandSize,
		&i.HipSize,
		&i.WaistSize,
		&i.BreastType,
		&i.CareerStartYear,
		&i.CareerEndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.Birthdate,
		&i.Deathdate,
	)
	return i, err
}

const updatePerformerRedirects = `-- name: UpdatePerformerRedirects :exec
UPDATE performer_redirects SET target_id = $1 WHERE target_id = $2
`

type UpdatePerformerRedirectsParams struct {
	NewPerformerID uuid.UUID `db:"new_performer_id" json:"new_performer_id"`
	OldPerformerID uuid.UUID `db:"old_performer_id" json:"old_performer_id"`
}

func (q *Queries) UpdatePerformerRedirects(ctx context.Context, arg UpdatePerformerRedirectsParams) error {
	_, err := q.db.Exec(ctx, updatePerformerRedirects, arg.NewPerformerID, arg.OldPerformerID)
	return err
}
