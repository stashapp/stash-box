// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tag.sql

package queries

import (
	"context"

	"github.com/gofrs/uuid"
)

type CreateSceneTagsParams struct {
	SceneID uuid.UUID `db:"scene_id" json:"scene_id"`
	TagID   uuid.UUID `db:"tag_id" json:"tag_id"`
}

const createTag = `-- name: CreateTag :one

INSERT INTO tags (id, name, category_id, description, created_at, updated_at)
VALUES ($1, $2, $3, $4, now(), now())
RETURNING id, name, description, created_at, updated_at, deleted, category_id
`

type CreateTagParams struct {
	ID          uuid.UUID     `db:"id" json:"id"`
	Name        string        `db:"name" json:"name"`
	CategoryID  uuid.NullUUID `db:"category_id" json:"category_id"`
	Description *string       `db:"description" json:"description"`
}

// Tag queries
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag,
		arg.ID,
		arg.Name,
		arg.CategoryID,
		arg.Description,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

type CreateTagAliasesParams struct {
	TagID uuid.UUID `db:"tag_id" json:"tag_id"`
	Alias string    `db:"alias" json:"alias"`
}

const createTagRedirect = `-- name: CreateTagRedirect :exec

INSERT INTO tag_redirects (source_id, target_id) VALUES ($1, $2)
`

type CreateTagRedirectParams struct {
	SourceID uuid.UUID `db:"source_id" json:"source_id"`
	TargetID uuid.UUID `db:"target_id" json:"target_id"`
}

// Tag redirects
func (q *Queries) CreateTagRedirect(ctx context.Context, arg CreateTagRedirectParams) error {
	_, err := q.db.Exec(ctx, createTagRedirect, arg.SourceID, arg.TargetID)
	return err
}

const deleteSceneTagsByScene = `-- name: DeleteSceneTagsByScene :exec
DELETE FROM scene_tags WHERE scene_id = $1
`

func (q *Queries) DeleteSceneTagsByScene(ctx context.Context, sceneID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSceneTagsByScene, sceneID)
	return err
}

const deleteSceneTagsByTag = `-- name: DeleteSceneTagsByTag :exec
DELETE FROM scene_tags WHERE tag_id = $1
`

func (q *Queries) DeleteSceneTagsByTag(ctx context.Context, tagID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSceneTagsByTag, tagID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const deleteTagAliases = `-- name: DeleteTagAliases :exec
DELETE FROM tag_aliases WHERE tag_id = $1
`

func (q *Queries) DeleteTagAliases(ctx context.Context, tagID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTagAliases, tagID)
	return err
}

const deleteTagAliasesByNames = `-- name: DeleteTagAliasesByNames :exec
DELETE FROM tag_aliases WHERE tag_id = $1 AND alias = ANY($2::TEXT[])
`

type DeleteTagAliasesByNamesParams struct {
	TagID   uuid.UUID `db:"tag_id" json:"tag_id"`
	Column2 []string  `db:"column_2" json:"column_2"`
}

func (q *Queries) DeleteTagAliasesByNames(ctx context.Context, arg DeleteTagAliasesByNamesParams) error {
	_, err := q.db.Exec(ctx, deleteTagAliasesByNames, arg.TagID, arg.Column2)
	return err
}

const findTag = `-- name: FindTag :one
SELECT id, name, description, created_at, updated_at, deleted, category_id FROM tags WHERE id = $1
`

func (q *Queries) FindTag(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, findTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

const findTagByAlias = `-- name: FindTagByAlias :one
SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM tags t
JOIN tag_aliases ta ON t.id = ta.tag_id
WHERE UPPER(ta.alias) = UPPER($1) AND t.deleted = false
`

func (q *Queries) FindTagByAlias(ctx context.Context, upper interface{}) (Tag, error) {
	row := q.db.QueryRow(ctx, findTagByAlias, upper)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

const findTagByName = `-- name: FindTagByName :one
SELECT id, name, description, created_at, updated_at, deleted, category_id FROM tags WHERE UPPER(name) = UPPER($1) AND deleted = false
`

func (q *Queries) FindTagByName(ctx context.Context, upper interface{}) (Tag, error) {
	row := q.db.QueryRow(ctx, findTagByName, upper)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

const findTagByNameOrAlias = `-- name: FindTagByNameOrAlias :one
SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM tags T
LEFT JOIN tag_aliases TA ON T.id = TA.tag_id
WHERE (
  LOWER(TA.alias) = LOWER($1)
  OR LOWER(T.name) = LOWER($1)
) AND T.deleted = FALSE
`

func (q *Queries) FindTagByNameOrAlias(ctx context.Context, lower string) (Tag, error) {
	row := q.db.QueryRow(ctx, findTagByNameOrAlias, lower)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

const findTagIdsBySceneIds = `-- name: FindTagIdsBySceneIds :many
SELECT scene_id, tag_id FROM scene_tags WHERE scene_id = ANY($1::UUID[])
`

// Bulk query to find tag IDs for multiple scene IDs
func (q *Queries) FindTagIdsBySceneIds(ctx context.Context, sceneIds []uuid.UUID) ([]SceneTag, error) {
	rows, err := q.db.Query(ctx, findTagIdsBySceneIds, sceneIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SceneTag{}
	for rows.Next() {
		var i SceneTag
		if err := rows.Scan(&i.SceneID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTagsByIds = `-- name: FindTagsByIds :many
SELECT id, name, description, created_at, updated_at, deleted, category_id FROM tags WHERE id = ANY($1::UUID[])
`

func (q *Queries) FindTagsByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, findTagsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTagsBySceneID = `-- name: FindTagsBySceneID :many
SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM tags t
INNER JOIN scene_tags st ON st.tag_id = t.id
WHERE st.scene_id = $1 AND t.deleted = false
`

func (q *Queries) FindTagsBySceneID(ctx context.Context, sceneID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, findTagsBySceneID, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTagsWithRedirects = `-- name: FindTagsWithRedirects :many
SELECT DISTINCT id, name, description, created_at, updated_at, deleted, category_id FROM (
    SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM tags T
    WHERE T.id = ANY($1::UUID[]) AND T.deleted = FALSE
    UNION
    SELECT tt.id, tt.name, tt.description, tt.created_at, tt.updated_at, tt.deleted, tt.category_id FROM tag_redirects R
    JOIN tags TT ON TT.id = R.target_id
    WHERE R.source_id = ANY($1::UUID[]) AND TT.deleted = FALSE
) AS combined_tags
`

func (q *Queries) FindTagsWithRedirects(ctx context.Context, dollar_1 []uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, findTagsWithRedirects, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSceneTags = `-- name: GetSceneTags :many
SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM scene_tags ST JOIN tags T ON ST.tag_id = T.id WHERE scene_id = $1
`

func (q *Queries) GetSceneTags(ctx context.Context, sceneID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getSceneTags, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagAliases = `-- name: GetTagAliases :many
SELECT alias FROM tag_aliases WHERE tag_id = $1
`

func (q *Queries) GetTagAliases(ctx context.Context, tagID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getTagAliases, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var alias string
		if err := rows.Scan(&alias); err != nil {
			return nil, err
		}
		items = append(items, alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTags = `-- name: SearchTags :many
SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM tags T
LEFT JOIN tag_aliases TA ON TA.tag_id = T.id
WHERE (
    to_tsvector('english', T.name) ||
    to_tsvector('english', COALESCE(TA.alias, ''))
) @@ plainto_tsquery($1)
AND T.deleted = FALSE
GROUP BY T.id
ORDER BY T.name ASC
LIMIT $2
`

type SearchTagsParams struct {
	Term  *string `db:"term" json:"term"`
	Limit int32   `db:"limit" json:"limit"`
}

func (q *Queries) SearchTags(ctx context.Context, arg SearchTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, searchTags, arg.Term, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTag = `-- name: SoftDeleteTag :one
UPDATE tags SET deleted = true, updated_at = NOW() WHERE id = $1
RETURNING id, name, description, created_at, updated_at, deleted, category_id
`

func (q *Queries) SoftDeleteTag(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, softDeleteTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

const updateSceneTagsForMerge = `-- name: UpdateSceneTagsForMerge :exec
UPDATE scene_tags
SET tag_id = $1
WHERE scene_tags.tag_id = $2
AND scene_id NOT IN (SELECT scene_id from scene_tags st WHERE st.tag_id = $1)
`

type UpdateSceneTagsForMergeParams struct {
	NewTagID uuid.UUID `db:"new_tag_id" json:"new_tag_id"`
	OldTagID uuid.UUID `db:"old_tag_id" json:"old_tag_id"`
}

func (q *Queries) UpdateSceneTagsForMerge(ctx context.Context, arg UpdateSceneTagsForMergeParams) error {
	_, err := q.db.Exec(ctx, updateSceneTagsForMerge, arg.NewTagID, arg.OldTagID)
	return err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags 
SET name = $2, category_id = $3, description = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, created_at, updated_at, deleted, category_id
`

type UpdateTagParams struct {
	ID          uuid.UUID     `db:"id" json:"id"`
	Name        string        `db:"name" json:"name"`
	CategoryID  uuid.NullUUID `db:"category_id" json:"category_id"`
	Description *string       `db:"description" json:"description"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, updateTag,
		arg.ID,
		arg.Name,
		arg.CategoryID,
		arg.Description,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.CategoryID,
	)
	return i, err
}

const updateTagRedirects = `-- name: UpdateTagRedirects :exec
UPDATE tag_redirects SET target_id = $1 WHERE target_id = $2
`

type UpdateTagRedirectsParams struct {
	NewTargetID uuid.UUID `db:"new_target_id" json:"new_target_id"`
	OldTargetID uuid.UUID `db:"old_target_id" json:"old_target_id"`
}

func (q *Queries) UpdateTagRedirects(ctx context.Context, arg UpdateTagRedirectsParams) error {
	_, err := q.db.Exec(ctx, updateTagRedirects, arg.NewTargetID, arg.OldTargetID)
	return err
}
