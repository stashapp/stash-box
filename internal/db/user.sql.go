// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package db

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUserEditsByStatus = `-- name: CountUserEditsByStatus :many
SELECT status, COUNT(*) as count FROM edits WHERE user_id = $1 GROUP BY status
`

type CountUserEditsByStatusRow struct {
	Status string `db:"status" json:"status"`
	Count  int64  `db:"count" json:"count"`
}

func (q *Queries) CountUserEditsByStatus(ctx context.Context, userID uuid.NullUUID) ([]CountUserEditsByStatusRow, error) {
	rows, err := q.db.Query(ctx, countUserEditsByStatus, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountUserEditsByStatusRow{}
	for rows.Next() {
		var i CountUserEditsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVotesByType = `-- name: CountVotesByType :many
SELECT vote, COUNT(*) as count FROM edit_votes WHERE user_id = $1 GROUP BY vote
`

type CountVotesByTypeRow struct {
	Vote  string `db:"vote" json:"vote"`
	Count int64  `db:"count" json:"count"`
}

func (q *Queries) CountVotesByType(ctx context.Context, userID uuid.UUID) ([]CountVotesByTypeRow, error) {
	rows, err := q.db.Query(ctx, countVotesByType, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountVotesByTypeRow{}
	for rows.Next() {
		var i CountVotesByTypeRow
		if err := rows.Scan(&i.Vote, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (id, name, password_hash, email, api_key, api_calls, invite_tokens, invited_by, last_api_call, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW(), NOW())
RETURNING id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens
`

type CreateUserParams struct {
	ID           uuid.UUID     `db:"id" json:"id"`
	Name         string        `db:"name" json:"name"`
	PasswordHash string        `db:"password_hash" json:"password_hash"`
	Email        string        `db:"email" json:"email"`
	ApiKey       string        `db:"api_key" json:"api_key"`
	ApiCalls     pgtype.Int4   `db:"api_calls" json:"api_calls"`
	InviteTokens int32         `db:"invite_tokens" json:"invite_tokens"`
	InvitedBy    uuid.NullUUID `db:"invited_by" json:"invited_by"`
}

// User queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.Email,
		arg.ApiKey,
		arg.ApiCalls,
		arg.InviteTokens,
		arg.InvitedBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

type CreateUserRolesParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Role   string    `db:"role" json:"role"`
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
DELETE FROM user_roles WHERE user_id = $1
`

func (q *Queries) DeleteUserRoles(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, userID)
	return err
}

const findUser = `-- name: FindUser :one
SELECT id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens FROM users WHERE id = $1
`

func (q *Queries) FindUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, findUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

const findUserByAPIKey = `-- name: FindUserByAPIKey :one
SELECT id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens FROM users WHERE api_key = $1
`

func (q *Queries) FindUserByAPIKey(ctx context.Context, apiKey string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByAPIKey, apiKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens FROM users WHERE UPPER(email) = UPPER($1)
`

func (q *Queries) FindUserByEmail(ctx context.Context, upper interface{}) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, upper)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

const findUserByName = `-- name: FindUserByName :one
SELECT id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens FROM users WHERE UPPER(name) = UPPER($1::text)
`

func (q *Queries) FindUserByName(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByName, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

const getUserNotificationSubscriptions = `-- name: GetUserNotificationSubscriptions :many
SELECT type FROM user_notifications WHERE user_id = $1
`

func (q *Queries) GetUserNotificationSubscriptions(ctx context.Context, userID uuid.UUID) ([]NotificationType, error) {
	rows, err := q.db.Query(ctx, getUserNotificationSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationType{}
	for rows.Next() {
		var type_ NotificationType
		if err := rows.Scan(&type_); err != nil {
			return nil, err
		}
		items = append(items, type_)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT role FROM user_roles WHERE user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var role string
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET name = $2, password_hash = $3, email = $4, api_key = $5, api_calls = $6, 
    invite_tokens = $7, invited_by = $8, last_api_call = $9, updated_at = NOW()
WHERE id = $1
RETURNING id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens
`

type UpdateUserParams struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	Name         string           `db:"name" json:"name"`
	PasswordHash string           `db:"password_hash" json:"password_hash"`
	Email        string           `db:"email" json:"email"`
	ApiKey       string           `db:"api_key" json:"api_key"`
	ApiCalls     pgtype.Int4      `db:"api_calls" json:"api_calls"`
	InviteTokens int32            `db:"invite_tokens" json:"invite_tokens"`
	InvitedBy    uuid.NullUUID    `db:"invited_by" json:"invited_by"`
	LastApiCall  pgtype.Timestamp `db:"last_api_call" json:"last_api_call"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.Email,
		arg.ApiKey,
		arg.ApiCalls,
		arg.InviteTokens,
		arg.InvitedBy,
		arg.LastApiCall,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

const updateUserAPIKey = `-- name: UpdateUserAPIKey :exec
UPDATE users
SET api_key = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserAPIKeyParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	ApiKey string    `db:"api_key" json:"api_key"`
}

func (q *Queries) UpdateUserAPIKey(ctx context.Context, arg UpdateUserAPIKeyParams) error {
	_, err := q.db.Exec(ctx, updateUserAPIKey, arg.ID, arg.ApiKey)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users
SET email = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserEmailParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Email string    `db:"email" json:"email"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserEmail, arg.ID, arg.Email)
	return err
}

const updateUserInviteTokenCount = `-- name: UpdateUserInviteTokenCount :exec
UPDATE users
SET invite_tokens = $2
WHERE id = $1
`

type UpdateUserInviteTokenCountParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	InviteTokens int32     `db:"invite_tokens" json:"invite_tokens"`
}

func (q *Queries) UpdateUserInviteTokenCount(ctx context.Context, arg UpdateUserInviteTokenCountParams) error {
	_, err := q.db.Exec(ctx, updateUserInviteTokenCount, arg.ID, arg.InviteTokens)
	return err
}

const updateUserPartial = `-- name: UpdateUserPartial :one
UPDATE users 
SET name = COALESCE($3, name),
    password_hash = COALESCE($4, password_hash),
    email = COALESCE($5, email),
    api_key = COALESCE($6, api_key),
    api_calls = COALESCE($7, api_calls),
    invite_tokens = COALESCE($8, invite_tokens),
    invited_by = COALESCE($9, invited_by),
    last_api_call = COALESCE($10, last_api_call),
    updated_at = $2
WHERE id = $1
RETURNING id, name, password_hash, email, api_key, api_calls, last_api_call, created_at, updated_at, invited_by, invite_tokens
`

type UpdateUserPartialParams struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Name         pgtype.Text      `db:"name" json:"name"`
	PasswordHash pgtype.Text      `db:"password_hash" json:"password_hash"`
	Email        pgtype.Text      `db:"email" json:"email"`
	ApiKey       pgtype.Text      `db:"api_key" json:"api_key"`
	ApiCalls     pgtype.Int4      `db:"api_calls" json:"api_calls"`
	InviteTokens pgtype.Int4      `db:"invite_tokens" json:"invite_tokens"`
	InvitedBy    uuid.NullUUID    `db:"invited_by" json:"invited_by"`
	LastApiCall  pgtype.Timestamp `db:"last_api_call" json:"last_api_call"`
}

func (q *Queries) UpdateUserPartial(ctx context.Context, arg UpdateUserPartialParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPartial,
		arg.ID,
		arg.UpdatedAt,
		arg.Name,
		arg.PasswordHash,
		arg.Email,
		arg.ApiKey,
		arg.ApiCalls,
		arg.InviteTokens,
		arg.InvitedBy,
		arg.LastApiCall,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PasswordHash,
		&i.Email,
		&i.ApiKey,
		&i.ApiCalls,
		&i.LastApiCall,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InvitedBy,
		&i.InviteTokens,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	PasswordHash string    `db:"password_hash" json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const userHasRole = `-- name: UserHasRole :one
SELECT EXISTS(SELECT 1 FROM user_roles WHERE user_id = $1 AND role = $2)
`

type UserHasRoleParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Role   string    `db:"role" json:"role"`
}

func (q *Queries) UserHasRole(ctx context.Context, arg UserHasRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, userHasRole, arg.UserID, arg.Role)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
