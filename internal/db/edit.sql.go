// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: edit.sql

package db

import (
	"context"
	"time"

	"github.com/gofrs/uuid"
)

const cancelUserEdits = `-- name: CancelUserEdits :exec
UPDATE edits SET status = 'CANCELED', updated_at = NOW() WHERE user_id = $1
`

func (q *Queries) CancelUserEdits(ctx context.Context, userID uuid.NullUUID) error {
	_, err := q.db.Exec(ctx, cancelUserEdits, userID)
	return err
}

const createEdit = `-- name: CreateEdit :one

INSERT INTO edits (
    id, user_id, target_type, operation, data, votes, status, applied,
    created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, now(), now())
RETURNING id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count
`

type CreateEditParams struct {
	ID         uuid.UUID     `db:"id" json:"id"`
	UserID     uuid.NullUUID `db:"user_id" json:"user_id"`
	TargetType string        `db:"target_type" json:"target_type"`
	Operation  string        `db:"operation" json:"operation"`
	Data       []byte        `db:"data" json:"data"`
	Votes      int           `db:"votes" json:"votes"`
	Status     string        `db:"status" json:"status"`
	Applied    bool          `db:"applied" json:"applied"`
}

// Edit queries
func (q *Queries) CreateEdit(ctx context.Context, arg CreateEditParams) (Edit, error) {
	row := q.db.QueryRow(ctx, createEdit,
		arg.ID,
		arg.UserID,
		arg.TargetType,
		arg.Operation,
		arg.Data,
		arg.Votes,
		arg.Status,
		arg.Applied,
	)
	var i Edit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Operation,
		&i.TargetType,
		&i.Data,
		&i.Votes,
		&i.Status,
		&i.Applied,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.Bot,
		&i.UpdateCount,
	)
	return i, err
}

const createEditComment = `-- name: CreateEditComment :one

INSERT INTO edit_comments (id, edit_id, user_id, text, created_at)
VALUES ($1, $2, $3, $4, NOW())
RETURNING id, edit_id, user_id, created_at, text
`

type CreateEditCommentParams struct {
	ID     uuid.UUID     `db:"id" json:"id"`
	EditID uuid.UUID     `db:"edit_id" json:"edit_id"`
	UserID uuid.NullUUID `db:"user_id" json:"user_id"`
	Text   string        `db:"text" json:"text"`
}

// Edit comments
func (q *Queries) CreateEditComment(ctx context.Context, arg CreateEditCommentParams) (EditComment, error) {
	row := q.db.QueryRow(ctx, createEditComment,
		arg.ID,
		arg.EditID,
		arg.UserID,
		arg.Text,
	)
	var i EditComment
	err := row.Scan(
		&i.ID,
		&i.EditID,
		&i.UserID,
		&i.CreatedAt,
		&i.Text,
	)
	return i, err
}

const createEditVote = `-- name: CreateEditVote :exec

INSERT INTO edit_votes (edit_id, user_id, vote, created_at) VALUES ($1, $2, $3, NOW())
`

type CreateEditVoteParams struct {
	EditID uuid.UUID `db:"edit_id" json:"edit_id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Vote   string    `db:"vote" json:"vote"`
}

// Edit votes
func (q *Queries) CreateEditVote(ctx context.Context, arg CreateEditVoteParams) error {
	_, err := q.db.Exec(ctx, createEditVote, arg.EditID, arg.UserID, arg.Vote)
	return err
}

const createPerformerEdit = `-- name: CreatePerformerEdit :exec
INSERT INTO performer_edits (edit_id, performer_id) VALUES ($1, $2)
`

type CreatePerformerEditParams struct {
	EditID      uuid.UUID `db:"edit_id" json:"edit_id"`
	PerformerID uuid.UUID `db:"performer_id" json:"performer_id"`
}

func (q *Queries) CreatePerformerEdit(ctx context.Context, arg CreatePerformerEditParams) error {
	_, err := q.db.Exec(ctx, createPerformerEdit, arg.EditID, arg.PerformerID)
	return err
}

const createSceneEdit = `-- name: CreateSceneEdit :exec
INSERT INTO scene_edits (edit_id, scene_id) VALUES ($1, $2)
`

type CreateSceneEditParams struct {
	EditID  uuid.UUID `db:"edit_id" json:"edit_id"`
	SceneID uuid.UUID `db:"scene_id" json:"scene_id"`
}

func (q *Queries) CreateSceneEdit(ctx context.Context, arg CreateSceneEditParams) error {
	_, err := q.db.Exec(ctx, createSceneEdit, arg.EditID, arg.SceneID)
	return err
}

const createStudioEdit = `-- name: CreateStudioEdit :exec
INSERT INTO studio_edits (edit_id, studio_id) VALUES ($1, $2)
`

type CreateStudioEditParams struct {
	EditID   uuid.UUID `db:"edit_id" json:"edit_id"`
	StudioID uuid.UUID `db:"studio_id" json:"studio_id"`
}

func (q *Queries) CreateStudioEdit(ctx context.Context, arg CreateStudioEditParams) error {
	_, err := q.db.Exec(ctx, createStudioEdit, arg.EditID, arg.StudioID)
	return err
}

const createTagEdit = `-- name: CreateTagEdit :exec
INSERT INTO tag_edits (edit_id, tag_id) VALUES ($1, $2)
`

type CreateTagEditParams struct {
	EditID uuid.UUID `db:"edit_id" json:"edit_id"`
	TagID  uuid.UUID `db:"tag_id" json:"tag_id"`
}

func (q *Queries) CreateTagEdit(ctx context.Context, arg CreateTagEditParams) error {
	_, err := q.db.Exec(ctx, createTagEdit, arg.EditID, arg.TagID)
	return err
}

const deleteEdit = `-- name: DeleteEdit :exec
DELETE FROM edits WHERE id = $1
`

func (q *Queries) DeleteEdit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEdit, id)
	return err
}

const findCompletedEdits = `-- name: FindCompletedEdits :many
SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits
WHERE status = 'PENDING'
AND (
    (created_at <= (now()::timestamp - (INTERVAL '1 second' * $1)) AND updated_at IS NULL)
    OR
    (updated_at <= (now()::timestamp - (INTERVAL '1 second' * $1)) AND updated_at IS NOT NULL)
    OR (
        votes >= $2
        AND (
            (created_at <= (now()::timestamp - (INTERVAL '1 second' * $3)) AND updated_at IS NULL)
            OR
            (updated_at <= (now()::timestamp - (INTERVAL '1 second' * $3)) AND updated_at IS NOT NULL)
        )
    )
)
`

type FindCompletedEditsParams struct {
	VotingPeriod        interface{} `db:"voting_period" json:"voting_period"`
	MinimumVotes        int         `db:"minimum_votes" json:"minimum_votes"`
	MinimumVotingPeriod interface{} `db:"minimum_voting_period" json:"minimum_voting_period"`
}

// Returns pending edits that fulfill one of the criteria for being closed:
// * The full voting period has passed
// * The minimum voting period has passed, and the number of votes has crossed the voting threshold.
// The latter only applies for destructive edits. Non-destructive edits get auto-applied when sufficient votes are cast.
func (q *Queries) FindCompletedEdits(ctx context.Context, arg FindCompletedEditsParams) ([]Edit, error) {
	rows, err := q.db.Query(ctx, findCompletedEdits, arg.VotingPeriod, arg.MinimumVotes, arg.MinimumVotingPeriod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findEdit = `-- name: FindEdit :one
SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = $1
`

func (q *Queries) FindEdit(ctx context.Context, id uuid.UUID) (Edit, error) {
	row := q.db.QueryRow(ctx, findEdit, id)
	var i Edit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Operation,
		&i.TargetType,
		&i.Data,
		&i.Votes,
		&i.Status,
		&i.Applied,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.Bot,
		&i.UpdateCount,
	)
	return i, err
}

const findPendingPerformerCreation = `-- name: FindPendingPerformerCreation :many
SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits
WHERE status = 'PENDING'
AND target_type = 'PERFORMER'
AND (
    ($1::text IS NOT NULL AND data->'new_data'->>'name' = $1)
    OR
    ($2::text[] IS NOT NULL AND jsonb_exists_any(jsonb_path_query_array(data, '$.new_data.added_urls[*].url'), $2))
)
`

type FindPendingPerformerCreationParams struct {
	Name *string  `db:"name" json:"name"`
	Urls []string `db:"urls" json:"urls"`
}

func (q *Queries) FindPendingPerformerCreation(ctx context.Context, arg FindPendingPerformerCreationParams) ([]Edit, error) {
	rows, err := q.db.Query(ctx, findPendingPerformerCreation, arg.Name, arg.Urls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPendingSceneCreation = `-- name: FindPendingSceneCreation :many
SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits
WHERE status = 'PENDING'
AND target_type = 'SCENE'
AND (
    ($1::text IS NOT NULL AND $2::uuid IS NOT NULL
     AND data->'new_data'->>'title' = $1
     AND (data->'new_data'->>'studio_id')::uuid = $2)
    OR
    ($3::text[] IS NOT NULL AND jsonb_exists_any(jsonb_path_query_array(data, '$.new_data.added_fingerprints[*].hash'), $3))
)
`

type FindPendingSceneCreationParams struct {
	Title    *string       `db:"title" json:"title"`
	StudioID uuid.NullUUID `db:"studio_id" json:"studio_id"`
	Hashes   []string      `db:"hashes" json:"hashes"`
}

func (q *Queries) FindPendingSceneCreation(ctx context.Context, arg FindPendingSceneCreationParams) ([]Edit, error) {
	rows, err := q.db.Query(ctx, findPendingSceneCreation, arg.Title, arg.StudioID, arg.Hashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditComments = `-- name: GetEditComments :many
SELECT id, edit_id, user_id, created_at, text FROM edit_comments WHERE edit_id = $1 ORDER BY created_at ASC
`

func (q *Queries) GetEditComments(ctx context.Context, editID uuid.UUID) ([]EditComment, error) {
	rows, err := q.db.Query(ctx, getEditComments, editID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EditComment{}
	for rows.Next() {
		var i EditComment
		if err := rows.Scan(
			&i.ID,
			&i.EditID,
			&i.UserID,
			&i.CreatedAt,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditCommentsByIds = `-- name: GetEditCommentsByIds :many
SELECT id, edit_id, user_id, created_at, text FROM edit_comments WHERE id = ANY($1::UUID[])
`

func (q *Queries) GetEditCommentsByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]EditComment, error) {
	rows, err := q.db.Query(ctx, getEditCommentsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EditComment{}
	for rows.Next() {
		var i EditComment
		if err := rows.Scan(
			&i.ID,
			&i.EditID,
			&i.UserID,
			&i.CreatedAt,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditPerformerAliases = `-- name: GetEditPerformerAliases :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = $1
)
(
  SELECT alias
  FROM edit E
  JOIN performer_edits PE ON E.id = PE.edit_id
  JOIN performer_aliases PA ON PE.performer_id = PA.performer_id
  EXCEPT
  SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'removed_aliases', '[]'::jsonb)) AS alias FROM edit
)
UNION
SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'added_aliases', '[]'::jsonb)) AS alias FROM edit
`

func (q *Queries) GetEditPerformerAliases(ctx context.Context, id uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getEditPerformerAliases, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var alias string
		if err := rows.Scan(&alias); err != nil {
			return nil, err
		}
		items = append(items, alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditPerformerPiercings = `-- name: GetEditPerformerPiercings :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = $1
),
current_piercings AS (
    SELECT location, description
    FROM edit E
    JOIN performer_edits PE ON E.id = PE.edit_id
    JOIN performer_piercings PP ON PE.performer_id = PP.performer_id
),
removed_piercings AS (
    SELECT
        elem->>'location' AS location,
        elem->>'description' AS description
    FROM edit, jsonb_array_elements(COALESCE(data->'new_data'->'removed_piercings', '[]'::jsonb)) AS elem
),
added_piercings AS (
    SELECT
        elem->>'location' AS location,
        elem->>'description' AS description
    FROM edit, jsonb_array_elements(COALESCE(data->'new_data'->'added_piercings', '[]'::jsonb)) AS elem
),
final_piercings AS (
    SELECT location, description FROM current_piercings
    EXCEPT
    SELECT location, description FROM removed_piercings
    UNION
    SELECT location, description FROM added_piercings
)
SELECT DISTINCT location, description FROM final_piercings
`

type GetEditPerformerPiercingsRow struct {
	Location    *string `db:"location" json:"location"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) GetEditPerformerPiercings(ctx context.Context, id uuid.UUID) ([]GetEditPerformerPiercingsRow, error) {
	rows, err := q.db.Query(ctx, getEditPerformerPiercings, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEditPerformerPiercingsRow{}
	for rows.Next() {
		var i GetEditPerformerPiercingsRow
		if err := rows.Scan(&i.Location, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditPerformerTattoos = `-- name: GetEditPerformerTattoos :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = $1
),
current_tattoos AS (
    SELECT location, description
    FROM edit E
    JOIN performer_edits PE ON E.id = PE.edit_id
    JOIN performer_tattoos PT ON PE.performer_id = PT.performer_id
),
removed_tattoos AS (
    SELECT
        elem->>'location' AS location,
        elem->>'description' AS description
    FROM edit, jsonb_array_elements(COALESCE(data->'new_data'->'removed_tattoos', '[]'::jsonb)) AS elem
),
added_tattoos AS (
    SELECT
        elem->>'location' AS location,
        elem->>'description' AS description
    FROM edit, jsonb_array_elements(COALESCE(data->'new_data'->'added_tattoos', '[]'::jsonb)) AS elem
),
final_tattoos AS (
    SELECT location, description FROM current_tattoos
    EXCEPT
    SELECT location, description FROM removed_tattoos
    UNION
    SELECT location, description FROM added_tattoos
)
SELECT DISTINCT location, description FROM final_tattoos
`

type GetEditPerformerTattoosRow struct {
	Location    *string `db:"location" json:"location"`
	Description *string `db:"description" json:"description"`
}

func (q *Queries) GetEditPerformerTattoos(ctx context.Context, id uuid.UUID) ([]GetEditPerformerTattoosRow, error) {
	rows, err := q.db.Query(ctx, getEditPerformerTattoos, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEditPerformerTattoosRow{}
	for rows.Next() {
		var i GetEditPerformerTattoosRow
		if err := rows.Scan(&i.Location, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditTargetID = `-- name: GetEditTargetID :one
SELECT CASE e.target_type
            WHEN 'SCENE' THEN se.scene_id
            WHEN 'PERFORMER' THEN pe.performer_id
            WHEN 'STUDIO' THEN ste.studio_id
            WHEN 'TAG' THEN te.tag_id
       END::UUID AS id, e.target_type
FROM edits e
LEFT JOIN scene_edits se ON e.id = se.edit_id
LEFT JOIN performer_edits pe ON e.id = pe.edit_id
LEFT JOIN studio_edits ste ON e.id = ste.edit_id
LEFT JOIN tag_edits te ON e.id = te.edit_id
WHERE e.id = $1
`

type GetEditTargetIDRow struct {
	ID         uuid.UUID `db:"id" json:"id"`
	TargetType string    `db:"target_type" json:"target_type"`
}

func (q *Queries) GetEditTargetID(ctx context.Context, id uuid.UUID) (GetEditTargetIDRow, error) {
	row := q.db.QueryRow(ctx, getEditTargetID, id)
	var i GetEditTargetIDRow
	err := row.Scan(&i.ID, &i.TargetType)
	return i, err
}

const getEditVotes = `-- name: GetEditVotes :many
SELECT edit_id, user_id, created_at, vote FROM edit_votes WHERE edit_id = $1
`

func (q *Queries) GetEditVotes(ctx context.Context, editID uuid.UUID) ([]EditVote, error) {
	rows, err := q.db.Query(ctx, getEditVotes, editID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EditVote{}
	for rows.Next() {
		var i EditVote
		if err := rows.Scan(
			&i.EditID,
			&i.UserID,
			&i.CreatedAt,
			&i.Vote,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditsByIds = `-- name: GetEditsByIds :many
SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = ANY($1::UUID[])
`

func (q *Queries) GetEditsByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]Edit, error) {
	rows, err := q.db.Query(ctx, getEditsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditsByPerformer = `-- name: GetEditsByPerformer :many
SELECT e.id, e.user_id, e.operation, e.target_type, e.data, e.votes, e.status, e.applied, e.created_at, e.updated_at, e.closed_at, e.bot, e.update_count FROM edits e
JOIN performer_edits pe ON e.id = pe.edit_id
WHERE pe.performer_id = $1
ORDER BY e.created_at DESC
`

func (q *Queries) GetEditsByPerformer(ctx context.Context, performerID uuid.UUID) ([]Edit, error) {
	rows, err := q.db.Query(ctx, getEditsByPerformer, performerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditsByScene = `-- name: GetEditsByScene :many
SELECT e.id, e.user_id, e.operation, e.target_type, e.data, e.votes, e.status, e.applied, e.created_at, e.updated_at, e.closed_at, e.bot, e.update_count FROM edits e
JOIN scene_edits se ON e.id = se.edit_id
WHERE se.scene_id = $1
ORDER BY e.created_at DESC
`

func (q *Queries) GetEditsByScene(ctx context.Context, sceneID uuid.UUID) ([]Edit, error) {
	rows, err := q.db.Query(ctx, getEditsByScene, sceneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditsByStudio = `-- name: GetEditsByStudio :many
SELECT e.id, e.user_id, e.operation, e.target_type, e.data, e.votes, e.status, e.applied, e.created_at, e.updated_at, e.closed_at, e.bot, e.update_count FROM edits e
JOIN studio_edits se ON e.id = se.edit_id
WHERE se.studio_id = $1
ORDER BY e.created_at DESC
`

func (q *Queries) GetEditsByStudio(ctx context.Context, studioID uuid.UUID) ([]Edit, error) {
	rows, err := q.db.Query(ctx, getEditsByStudio, studioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditsByTag = `-- name: GetEditsByTag :many
SELECT e.id, e.user_id, e.operation, e.target_type, e.data, e.votes, e.status, e.applied, e.created_at, e.updated_at, e.closed_at, e.bot, e.update_count FROM edits e
JOIN tag_edits te ON e.id = te.edit_id
WHERE te.tag_id = $1
ORDER BY e.created_at DESC
`

func (q *Queries) GetEditsByTag(ctx context.Context, tagID uuid.UUID) ([]Edit, error) {
	rows, err := q.db.Query(ctx, getEditsByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Edit{}
	for rows.Next() {
		var i Edit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Operation,
			&i.TargetType,
			&i.Data,
			&i.Votes,
			&i.Status,
			&i.Applied,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.Bot,
			&i.UpdateCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImagesForEdit = `-- name: GetImagesForEdit :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE edits.id = $1
), current_images AS (
    SELECT si.image_id FROM edit e
    JOIN scene_edits se ON e.id = se.edit_id
    JOIN scene_images si ON se.scene_id = si.scene_id
    UNION ALL
    SELECT pi.image_id FROM edit e
    JOIN performer_edits pe ON e.id = pe.edit_id
    JOIN performer_images pi ON pe.performer_id = pi.performer_id
    UNION ALL
    SELECT sti.image_id FROM edit e
    JOIN studio_edits ste ON e.id = ste.edit_id
    JOIN studio_images sti ON ste.studio_id = sti.studio_id
),
removed_images AS (
    SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'removed_images', '[]'::jsonb))::uuid AS image_id
    FROM edit
),
added_images AS (
    SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'added_images', '[]'::jsonb))::uuid AS image_id
    FROM edit
),
final_images AS (
    SELECT image_id FROM current_images
    WHERE image_id NOT IN (SELECT image_id FROM removed_images)
    UNION
    SELECT image_id FROM added_images
)
SELECT i.id, i.url, i.width, i.height, i.checksum FROM final_images fi
JOIN images i ON fi.image_id = i.id
ORDER BY i.id
`

// Gets current images for target entity and merges with edit's added_images/removed_images
func (q *Queries) GetImagesForEdit(ctx context.Context, id uuid.UUID) ([]Image, error) {
	rows, err := q.db.Query(ctx, getImagesForEdit, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Width,
			&i.Height,
			&i.Checksum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMergedPerformersForEdit = `-- name: GetMergedPerformersForEdit :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE edits.id = $1
), current_performers AS (
    SELECT sp.performer_id, sp."as" FROM edit e
    JOIN scene_edits se ON e.id = se.edit_id
    JOIN scene_performers sp ON se.scene_id = sp.scene_id
    WHERE e.target_type = 'SCENE'
),
removed_performers AS (
    SELECT
        (elem->>'performer_id')::uuid AS performer_id,
        elem->>'as' AS "as"
    FROM edit, jsonb_array_elements(COALESCE(data->'new_data'->'removed_performers', '[]'::jsonb)) AS elem
),
added_performers AS (
    SELECT
        (elem->>'performer_id')::uuid AS performer_id,
        elem->>'as' AS "as"
    FROM edit, jsonb_array_elements(COALESCE(data->'new_data'->'added_performers', '[]'::jsonb)) AS elem
),
final_performers AS (
    SELECT performer_id, "as" FROM current_performers
    EXCEPT
    SELECT performer_id, "as" FROM removed_performers
    UNION
    SELECT performer_id, "as" FROM added_performers
)
SELECT p.id, p.name, p.disambiguation, p.gender, p.ethnicity, p.country, p.eye_color, p.hair_color, p.height, p.cup_size, p.band_size, p.hip_size, p.waist_size, p.breast_type, p.career_start_year, p.career_end_year, p.created_at, p.updated_at, p.deleted, p.birthdate, p.deathdate, fp."as" FROM final_performers fp
JOIN performers p ON fp.performer_id = p.id
WHERE p.deleted = FALSE
ORDER BY p.name
`

type GetMergedPerformersForEditRow struct {
	Performer Performer `db:"performer" json:"performer"`
	As        *string   `db:"as" json:"as"`
}

// Gets current performers for target entity and merges with edit's added_performers/removed_performers
func (q *Queries) GetMergedPerformersForEdit(ctx context.Context, id uuid.UUID) ([]GetMergedPerformersForEditRow, error) {
	rows, err := q.db.Query(ctx, getMergedPerformersForEdit, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMergedPerformersForEditRow{}
	for rows.Next() {
		var i GetMergedPerformersForEditRow
		if err := rows.Scan(
			&i.Performer.ID,
			&i.Performer.Name,
			&i.Performer.Disambiguation,
			&i.Performer.Gender,
			&i.Performer.Ethnicity,
			&i.Performer.Country,
			&i.Performer.EyeColor,
			&i.Performer.HairColor,
			&i.Performer.Height,
			&i.Performer.CupSize,
			&i.Performer.BandSize,
			&i.Performer.HipSize,
			&i.Performer.WaistSize,
			&i.Performer.BreastType,
			&i.Performer.CareerStartYear,
			&i.Performer.CareerEndYear,
			&i.Performer.CreatedAt,
			&i.Performer.UpdatedAt,
			&i.Performer.Deleted,
			&i.Performer.Birthdate,
			&i.Performer.Deathdate,
			&i.As,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMergedStudioAliasesForEdit = `-- name: GetMergedStudioAliasesForEdit :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = $1
)
(
  SELECT alias
  FROM edit E
  JOIN studio_edits SE ON E.id = SE.edit_id
  JOIN studio_aliases SA ON SE.studio_id = SA.studio_id
  WHERE E.target_type = 'STUDIO'
  EXCEPT
  SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'removed_aliases', '[]'::jsonb)) AS alias FROM edit
)
UNION
SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'added_aliases', '[]'::jsonb)) AS alias FROM edit
`

// Gets current aliases for target studio entity and merges with edit's added_aliases/removed_aliases
func (q *Queries) GetMergedStudioAliasesForEdit(ctx context.Context, id uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getMergedStudioAliasesForEdit, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var alias string
		if err := rows.Scan(&alias); err != nil {
			return nil, err
		}
		items = append(items, alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMergedTagAliasesForEdit = `-- name: GetMergedTagAliasesForEdit :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE id = $1
)
(
  SELECT alias
  FROM edit E
  JOIN tag_edits TE ON E.id = TE.edit_id
  JOIN tag_aliases TA ON TE.tag_id = TA.tag_id
  EXCEPT
  SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'removed_aliases', '[]'::jsonb)) AS alias FROM edit
)
UNION
SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'added_aliases', '[]'::jsonb)) AS alias FROM edit
`

// Gets current aliases for target tag entity and merges with edit's added_aliases/removed_aliases
func (q *Queries) GetMergedTagAliasesForEdit(ctx context.Context, id uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getMergedTagAliasesForEdit, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var alias string
		if err := rows.Scan(&alias); err != nil {
			return nil, err
		}
		items = append(items, alias)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMergedTagsForEdit = `-- name: GetMergedTagsForEdit :many
WITH edit AS (
  SELECT id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count FROM edits WHERE edits.id = $1
), current_tags AS (
    SELECT st.tag_id FROM edit e
    JOIN scene_edits se ON e.id = se.edit_id
    JOIN scene_tags st ON se.scene_id = st.scene_id
    WHERE e.target_type = 'SCENE'
),
removed_tags AS (
    SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'removed_tags', '[]'::jsonb))::uuid AS tag_id
    FROM edit
),
added_tags AS (
    SELECT jsonb_array_elements_text(COALESCE(data->'new_data'->'added_tags', '[]'::jsonb))::uuid AS tag_id
    FROM edit
),
final_tags AS (
    SELECT tag_id FROM current_tags
    EXCEPT
    SELECT tag_id FROM removed_tags
    UNION
    SELECT tag_id FROM added_tags
)
SELECT t.id, t.name, t.description, t.created_at, t.updated_at, t.deleted, t.category_id FROM final_tags ft
JOIN tags t ON ft.tag_id = t.id
WHERE t.deleted = FALSE
ORDER BY t.name
`

// Gets current tags for target entity and merges with edit's added_tags/removed_tags
func (q *Queries) GetMergedTagsForEdit(ctx context.Context, id uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getMergedTagsForEdit, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMergedURLsForEdit = `-- name: GetMergedURLsForEdit :many

WITH current_urls AS (
    SELECT su.url, su.site_id FROM edits e
    JOIN scene_edits se ON e.id = se.edit_id 
    JOIN scene_urls su ON se.scene_id = su.scene_id
    WHERE e.id = $1 AND e.target_type = 'SCENE'
    UNION ALL
    SELECT pu.url, pu.site_id FROM edits e  
    JOIN performer_edits pe ON e.id = pe.edit_id
    JOIN performer_urls pu ON pe.performer_id = pu.performer_id  
    WHERE e.id = $1 AND e.target_type = 'PERFORMER'
    UNION ALL
    SELECT stu.url, stu.site_id FROM edits e
    JOIN studio_edits ste ON e.id = ste.edit_id
    JOIN studio_urls stu ON ste.studio_id = stu.studio_id
    WHERE e.id = $1 AND e.target_type = 'STUDIO'
),
removed_urls AS (
    SELECT
        elem->>'url' AS url,
        (elem->>'site_id')::uuid AS site_id
    FROM edits, jsonb_array_elements(COALESCE(data->'new_data'->'removed_urls', '[]'::jsonb)) AS elem
    WHERE id = $1
),
added_urls AS (
    SELECT
        elem->>'url' AS url,
        (elem->>'site_id')::uuid AS site_id
    FROM edits, jsonb_array_elements(COALESCE(data->'new_data'->'added_urls', '[]'::jsonb)) AS elem
    WHERE id = $1
),
final_urls AS (
    SELECT url, site_id FROM current_urls
    WHERE (url, site_id) NOT IN (SELECT url, site_id FROM removed_urls)
    UNION
    SELECT url, site_id FROM added_urls
)
SELECT DISTINCT url, site_id FROM final_urls
ORDER BY url
`

type GetMergedURLsForEditRow struct {
	Url    string    `db:"url" json:"url"`
	SiteID uuid.UUID `db:"site_id" json:"site_id"`
}

// URL merging queries for edits
// result: URL
// Gets current URLs for target entity and merges with edit's added_urls/removed_urls
func (q *Queries) GetMergedURLsForEdit(ctx context.Context, id uuid.UUID) ([]GetMergedURLsForEditRow, error) {
	rows, err := q.db.Query(ctx, getMergedURLsForEdit, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMergedURLsForEditRow{}
	for rows.Next() {
		var i GetMergedURLsForEditRow
		if err := rows.Scan(&i.Url, &i.SiteID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetVotes = `-- name: ResetVotes :exec
UPDATE edit_votes
SET vote = 'ABSTAIN'
WHERE edit_id = $1
`

func (q *Queries) ResetVotes(ctx context.Context, editID uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetVotes, editID)
	return err
}

const updateEdit = `-- name: UpdateEdit :one
UPDATE edits 
SET data = $2, votes = $3,
    status = $4, applied = $5, closed_at = $6, updated_at = now()
WHERE id = $1
RETURNING id, user_id, operation, target_type, data, votes, status, applied, created_at, updated_at, closed_at, bot, update_count
`

type UpdateEditParams struct {
	ID       uuid.UUID  `db:"id" json:"id"`
	Data     []byte     `db:"data" json:"data"`
	Votes    int        `db:"votes" json:"votes"`
	Status   string     `db:"status" json:"status"`
	Applied  bool       `db:"applied" json:"applied"`
	ClosedAt *time.Time `db:"closed_at" json:"closed_at"`
}

func (q *Queries) UpdateEdit(ctx context.Context, arg UpdateEditParams) (Edit, error) {
	row := q.db.QueryRow(ctx, updateEdit,
		arg.ID,
		arg.Data,
		arg.Votes,
		arg.Status,
		arg.Applied,
		arg.ClosedAt,
	)
	var i Edit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Operation,
		&i.TargetType,
		&i.Data,
		&i.Votes,
		&i.Status,
		&i.Applied,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.Bot,
		&i.UpdateCount,
	)
	return i, err
}
